{
    "origin": "codeshovel",
    "repositoryName": "pentaho-kettle",
    "repositoryPath": "/home/student/mortonss/research/better_bug_research/github_repos/pentaho-kettle/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "StreamLookup.java",
    "functionName": "lookupValues",
    "functionId": "lookupValues___rowMeta-RowMetaInterface__row-Object[]",
    "sourceFilePath": "engine/src/main/java/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
    "functionStartLine": 215,
    "functionEndLine": 284,
    "numCommitsSeen": 71,
    "timeTaken": 4932,
    "changeHistory": [
        "c1e82ac689ddbb8a40aa142a9294500143aac804",
        "b0f90c9c3053cdc2a4d2e48510ef75c3d8d9bfd6",
        "94cfff9d04254e88eaefd9e5bda0611efc133087",
        "8cbabac3f10796e6c64bbf8a6d04f8945ac1162c",
        "26b2d9cc609d575939e68f55cce86671fb4c54c3",
        "d440afbcb25ab8dc43ebafca88ca2340ae2b11c3",
        "97d77cd9f67d41901e9f5aa3899c40da173790f7",
        "b1f6ee29049d22e120573802a2d79891cbd0c169",
        "fb0913c9fc83add2b71024428a9327905067c207",
        "64c2d748ebc3a4de5fe715cdf71a186031778b4d",
        "3a0e1660877a13a4b92a96a85186fbd114795fa3",
        "19eeecd5426b9e977f948e783b5638b8e5907925",
        "2eaad7ec877978aee5e2e3b429002cbed85db450",
        "299b7c6933d259cfac52b7be050e1b1b3519a61a",
        "961d41fce33c408a84b9c5b93e656dc4324c8419",
        "8ea99afbc19a7e512f6c562edc3b57d283e59a64",
        "0be73dc4dba350b81e7bfa388fae664be9ecb688",
        "28004e6c5cbc120bf31a9961454af1166ed25114",
        "745c7e100e08aefb8345327435b3519a46ed3f23",
        "8a018e6caf5aa4c336832cb7a0191ac3db15ece7"
    ],
    "changeHistoryShort": {
        "8a018e6caf5aa4c336832cb7a0191ac3db15ece7": "Yfilerename",
        "745c7e100e08aefb8345327435b3519a46ed3f23": "Ybodychange",
        "28004e6c5cbc120bf31a9961454af1166ed25114": "Ybodychange",
        "0be73dc4dba350b81e7bfa388fae664be9ecb688": "Ybodychange",
        "8ea99afbc19a7e512f6c562edc3b57d283e59a64": "Ybodychange",
        "961d41fce33c408a84b9c5b93e656dc4324c8419": "Yfilerename",
        "299b7c6933d259cfac52b7be050e1b1b3519a61a": "Ybodychange",
        "2eaad7ec877978aee5e2e3b429002cbed85db450": "Ymultichange(Yexceptionschange,Ybodychange)",
        "19eeecd5426b9e977f948e783b5638b8e5907925": "Ybodychange",
        "3a0e1660877a13a4b92a96a85186fbd114795fa3": "Ybodychange",
        "64c2d748ebc3a4de5fe715cdf71a186031778b4d": "Ybodychange",
        "fb0913c9fc83add2b71024428a9327905067c207": "Ybodychange",
        "b1f6ee29049d22e120573802a2d79891cbd0c169": "Ybodychange",
        "97d77cd9f67d41901e9f5aa3899c40da173790f7": "Ybodychange",
        "d440afbcb25ab8dc43ebafca88ca2340ae2b11c3": "Ybodychange",
        "26b2d9cc609d575939e68f55cce86671fb4c54c3": "Ybodychange",
        "8cbabac3f10796e6c64bbf8a6d04f8945ac1162c": "Yfilerename",
        "94cfff9d04254e88eaefd9e5bda0611efc133087": "Yfilerename",
        "b0f90c9c3053cdc2a4d2e48510ef75c3d8d9bfd6": "Yfilerename",
        "c1e82ac689ddbb8a40aa142a9294500143aac804": "Yintroduced"
    },
    "changeHistoryDetails": {
        "8a018e6caf5aa4c336832cb7a0191ac3db15ece7": {
            "type": "Yfilerename",
            "commitMessage": "[BACKLOG-12977] First structural changes\n",
            "commitDate": "29/06/17 3:47 AM",
            "commitName": "8a018e6caf5aa4c336832cb7a0191ac3db15ece7",
            "commitAuthor": "Hilario Fernandes",
            "commitDateOld": "29/06/17 3:47 AM",
            "commitNameOld": "ffdd1fa341a7a9b2c802fbe1768d24eb0bb5ae65",
            "commitAuthorOld": "ecuellar",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n    // See if we need to stop.\n    if ( isStopped() ) {\n      return null;\n    }\n\n    if ( data.lookupColumnIndex == null ) {\n      String[] names = data.lookupMeta.getFieldNames();\n      data.lookupColumnIndex = new int[names.length];\n\n      for ( int i = 0; i < names.length; i++ ) {\n        data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n        if ( data.lookupColumnIndex[i] < 0 ) {\n          // we should not get here\n          throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n        }\n      }\n    }\n\n    // Copy value references to lookup table.\n    //\n    Object[] lu = new Object[data.keynrs.length];\n    for ( int i = 0; i < data.keynrs.length; i++ ) {\n      // If the input is binary storage data, we convert it to normal storage.\n      //\n      if ( data.convertKeysToNative[i] ) {\n        lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n      } else {\n        lu[i] = row[data.keynrs[i]];\n      }\n    }\n\n    // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n    if ( data.keyTypes != null ) {\n      for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n        ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n        ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n        if ( inputValue.getType() != lookupValue.getType() ) {\n          try {\n            // Change the input value to match the lookup value\n            //\n            lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n          } catch ( KettleValueException e ) {\n            throw new KettleStepException( \"Error converting data while looking up value\", e );\n          }\n        }\n      }\n    }\n\n    Object[] add = null;\n\n    if ( data.hasLookupRows ) {\n      try {\n        if ( meta.getKeystream().length > 0 ) {\n          add = getFromCache( data.cacheKeyMeta, lu );\n        } else {\n   // Just take the first element in the hashtable...\n          throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n        }\n      } catch ( Exception e ) {\n        throw new KettleStepException( e );\n      }\n    }\n\n    if ( add == null ) { // nothing was found, unknown code: add the specified default value...\n      add = data.nullIf;\n    }\n\n    return RowDataUtil.addRowData( row, rowMeta.size(), add );\n  }",
            "path": "engine/src/main/java/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {
                "oldPath": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                "newPath": "engine/src/main/java/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java"
            }
        },
        "745c7e100e08aefb8345327435b3519a46ed3f23": {
            "type": "Ybodychange",
            "commitMessage": "[PDI-682] - Replace StringBuffer with StringBuilder for performance\n\n[CHECKSTYLE] - Fix checkstyle on non-test classes\n",
            "commitDate": "25/02/16 12:22 PM",
            "commitName": "745c7e100e08aefb8345327435b3519a46ed3f23",
            "commitAuthor": "mbatchelor",
            "commitDateOld": "14/01/14 5:51 AM",
            "commitNameOld": "28004e6c5cbc120bf31a9961454af1166ed25114",
            "commitAuthorOld": "Pavel Sakun",
            "daysBetweenCommits": 772.27,
            "commitsBetweenForRepo": 1824,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,71 +1,70 @@\n   private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n     // See if we need to stop.\n     if ( isStopped() ) {\n       return null;\n     }\n \n     if ( data.lookupColumnIndex == null ) {\n       String[] names = data.lookupMeta.getFieldNames();\n       data.lookupColumnIndex = new int[names.length];\n \n       for ( int i = 0; i < names.length; i++ ) {\n         data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n         if ( data.lookupColumnIndex[i] < 0 ) {\n           // we should not get here\n           throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n         }\n       }\n     }\n \n     // Copy value references to lookup table.\n     //\n     Object[] lu = new Object[data.keynrs.length];\n     for ( int i = 0; i < data.keynrs.length; i++ ) {\n       // If the input is binary storage data, we convert it to normal storage.\n       //\n       if ( data.convertKeysToNative[i] ) {\n         lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n       } else {\n         lu[i] = row[data.keynrs[i]];\n       }\n     }\n \n     // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n     if ( data.keyTypes != null ) {\n       for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n         ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n         ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n         if ( inputValue.getType() != lookupValue.getType() ) {\n           try {\n             // Change the input value to match the lookup value\n             //\n             lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n           } catch ( KettleValueException e ) {\n             throw new KettleStepException( \"Error converting data while looking up value\", e );\n           }\n         }\n       }\n     }\n \n     Object[] add = null;\n \n     if ( data.hasLookupRows ) {\n       try {\n         if ( meta.getKeystream().length > 0 ) {\n           add = getFromCache( data.cacheKeyMeta, lu );\n         } else {\n    // Just take the first element in the hashtable...\n           throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n         }\n       } catch ( Exception e ) {\n         throw new KettleStepException( e );\n       }\n     }\n \n-    if ( add == null ) // nothing was found, unknown code: add the specified default value...\n-    {\n+    if ( add == null ) { // nothing was found, unknown code: add the specified default value...\n       add = data.nullIf;\n     }\n \n     return RowDataUtil.addRowData( row, rowMeta.size(), add );\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n    // See if we need to stop.\n    if ( isStopped() ) {\n      return null;\n    }\n\n    if ( data.lookupColumnIndex == null ) {\n      String[] names = data.lookupMeta.getFieldNames();\n      data.lookupColumnIndex = new int[names.length];\n\n      for ( int i = 0; i < names.length; i++ ) {\n        data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n        if ( data.lookupColumnIndex[i] < 0 ) {\n          // we should not get here\n          throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n        }\n      }\n    }\n\n    // Copy value references to lookup table.\n    //\n    Object[] lu = new Object[data.keynrs.length];\n    for ( int i = 0; i < data.keynrs.length; i++ ) {\n      // If the input is binary storage data, we convert it to normal storage.\n      //\n      if ( data.convertKeysToNative[i] ) {\n        lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n      } else {\n        lu[i] = row[data.keynrs[i]];\n      }\n    }\n\n    // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n    if ( data.keyTypes != null ) {\n      for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n        ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n        ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n        if ( inputValue.getType() != lookupValue.getType() ) {\n          try {\n            // Change the input value to match the lookup value\n            //\n            lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n          } catch ( KettleValueException e ) {\n            throw new KettleStepException( \"Error converting data while looking up value\", e );\n          }\n        }\n      }\n    }\n\n    Object[] add = null;\n\n    if ( data.hasLookupRows ) {\n      try {\n        if ( meta.getKeystream().length > 0 ) {\n          add = getFromCache( data.cacheKeyMeta, lu );\n        } else {\n   // Just take the first element in the hashtable...\n          throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n        }\n      } catch ( Exception e ) {\n        throw new KettleStepException( e );\n      }\n    }\n\n    if ( add == null ) { // nothing was found, unknown code: add the specified default value...\n      add = data.nullIf;\n    }\n\n    return RowDataUtil.addRowData( row, rowMeta.size(), add );\n  }",
            "path": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {}
        },
        "28004e6c5cbc120bf31a9961454af1166ed25114": {
            "type": "Ybodychange",
            "commitMessage": "PDI-10197 - Stream lookup issue with lazy conversion (was: Possible bug in CSV file input with lazy conversion)\n",
            "commitDate": "14/01/14 5:51 AM",
            "commitName": "28004e6c5cbc120bf31a9961454af1166ed25114",
            "commitAuthor": "Pavel Sakun",
            "commitDateOld": "12/12/13 5:05 AM",
            "commitNameOld": "16f99832975bfb5658d987679d397f9c30d8c0da",
            "commitAuthorOld": "Matt Casters",
            "daysBetweenCommits": 33.03,
            "commitsBetweenForRepo": 28,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,71 +1,71 @@\n   private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n     // See if we need to stop.\n     if ( isStopped() ) {\n       return null;\n     }\n \n     if ( data.lookupColumnIndex == null ) {\n       String[] names = data.lookupMeta.getFieldNames();\n       data.lookupColumnIndex = new int[names.length];\n \n       for ( int i = 0; i < names.length; i++ ) {\n         data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n         if ( data.lookupColumnIndex[i] < 0 ) {\n           // we should not get here\n           throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n         }\n       }\n     }\n \n     // Copy value references to lookup table.\n     //\n     Object[] lu = new Object[data.keynrs.length];\n     for ( int i = 0; i < data.keynrs.length; i++ ) {\n       // If the input is binary storage data, we convert it to normal storage.\n       //\n       if ( data.convertKeysToNative[i] ) {\n         lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n       } else {\n         lu[i] = row[data.keynrs[i]];\n       }\n     }\n \n     // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n     if ( data.keyTypes != null ) {\n       for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n         ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n         ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n         if ( inputValue.getType() != lookupValue.getType() ) {\n           try {\n             // Change the input value to match the lookup value\n             //\n             lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n           } catch ( KettleValueException e ) {\n             throw new KettleStepException( \"Error converting data while looking up value\", e );\n           }\n         }\n       }\n     }\n \n     Object[] add = null;\n \n     if ( data.hasLookupRows ) {\n       try {\n         if ( meta.getKeystream().length > 0 ) {\n-          add = getFromCache( data.keyTypes, lu );\n+          add = getFromCache( data.cacheKeyMeta, lu );\n         } else {\n-          // Just take the first element in the hashtable...\n+   // Just take the first element in the hashtable...\n           throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n         }\n       } catch ( Exception e ) {\n         throw new KettleStepException( e );\n       }\n     }\n \n     if ( add == null ) // nothing was found, unknown code: add the specified default value...\n     {\n       add = data.nullIf;\n     }\n \n     return RowDataUtil.addRowData( row, rowMeta.size(), add );\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n    // See if we need to stop.\n    if ( isStopped() ) {\n      return null;\n    }\n\n    if ( data.lookupColumnIndex == null ) {\n      String[] names = data.lookupMeta.getFieldNames();\n      data.lookupColumnIndex = new int[names.length];\n\n      for ( int i = 0; i < names.length; i++ ) {\n        data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n        if ( data.lookupColumnIndex[i] < 0 ) {\n          // we should not get here\n          throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n        }\n      }\n    }\n\n    // Copy value references to lookup table.\n    //\n    Object[] lu = new Object[data.keynrs.length];\n    for ( int i = 0; i < data.keynrs.length; i++ ) {\n      // If the input is binary storage data, we convert it to normal storage.\n      //\n      if ( data.convertKeysToNative[i] ) {\n        lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n      } else {\n        lu[i] = row[data.keynrs[i]];\n      }\n    }\n\n    // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n    if ( data.keyTypes != null ) {\n      for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n        ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n        ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n        if ( inputValue.getType() != lookupValue.getType() ) {\n          try {\n            // Change the input value to match the lookup value\n            //\n            lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n          } catch ( KettleValueException e ) {\n            throw new KettleStepException( \"Error converting data while looking up value\", e );\n          }\n        }\n      }\n    }\n\n    Object[] add = null;\n\n    if ( data.hasLookupRows ) {\n      try {\n        if ( meta.getKeystream().length > 0 ) {\n          add = getFromCache( data.cacheKeyMeta, lu );\n        } else {\n   // Just take the first element in the hashtable...\n          throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n        }\n      } catch ( Exception e ) {\n        throw new KettleStepException( e );\n      }\n    }\n\n    if ( add == null ) // nothing was found, unknown code: add the specified default value...\n    {\n      add = data.nullIf;\n    }\n\n    return RowDataUtil.addRowData( row, rowMeta.size(), add );\n  }",
            "path": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {}
        },
        "0be73dc4dba350b81e7bfa388fae664be9ecb688": {
            "type": "Ybodychange",
            "commitMessage": "Apply format, first pass at checkstyle",
            "commitDate": "12/10/13 1:35 PM",
            "commitName": "0be73dc4dba350b81e7bfa388fae664be9ecb688",
            "commitAuthor": "bkemper",
            "commitDateOld": "23/09/13 6:43 AM",
            "commitNameOld": "297a21c7246899afd30bbbc0508763373d5d28f4",
            "commitAuthorOld": "buildguy",
            "daysBetweenCommits": 19.29,
            "commitsBetweenForRepo": 27,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,86 +1,71 @@\n-    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n-\t{\n-\t\t// See if we need to stop.\n-\t\tif (isStopped()) return null;\n-\t\t\n-\t\tif ( data.lookupColumnIndex == null ) \n-\t\t{\n-\t\t\tString names[] = data.lookupMeta.getFieldNames();\n-\t\t\tdata.lookupColumnIndex = new int[names.length];\n-\t\t\t\n-\t\t\tfor( int i=0; i<names.length; i++ ) \n-\t\t\t{\n-\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n-\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n-\t\t\t\t{\n-\t\t\t\t\t// we should not get here\n-\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\t// Copy value references to lookup table.\n-\t\t//\n-        Object[] lu = new Object[data.keynrs.length];\n-        for (int i=0;i<data.keynrs.length;i++) {\n-        \t// If the input is binary storage data, we convert it to normal storage.\n-        \t//\n-        \tif (data.convertKeysToNative[i]) {\n-        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n-        \t} else {\n-        \t\tlu[i] = row[data.keynrs[i]];\n-        \t}\n-        }\n+  private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n+    // See if we need to stop.\n+    if ( isStopped() ) {\n+      return null;\n+    }\n \n-        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n-        if (data.keyTypes!=null)\n-        {\n-            for (int i=0;i<data.lookupMeta.size();i++)\n-            {\n-                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n-                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n-                if (inputValue.getType()!=lookupValue.getType())\n-                {\n-                    try\n-                    {\n-                    \t// Change the input value to match the lookup value\n-                    \t//\n-                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n-                    }\n-                    catch (KettleValueException e)\n-                    {\n-                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n-                    }\n-                }\n-            }\n+    if ( data.lookupColumnIndex == null ) {\n+      String[] names = data.lookupMeta.getFieldNames();\n+      data.lookupColumnIndex = new int[names.length];\n+\n+      for ( int i = 0; i < names.length; i++ ) {\n+        data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n+        if ( data.lookupColumnIndex[i] < 0 ) {\n+          // we should not get here\n+          throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n         }\n-        \n-        Object[] add = null;\n-        \n-\t\tif (data.hasLookupRows) \n-\t\t{\n-\t\t\ttry\n-\t\t\t{\n-\t\t\t\tif (meta.getKeystream().length>0)\n-\t\t\t\t{\n-\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\t// Just take the first element in the hashtable...\n-\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); \n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tcatch(Exception e)\n-\t\t\t{\n-\t\t\t\tthrow new KettleStepException(e);\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n-\t\t{\n-\t\t\tadd=data.nullIf;\n-\t\t} \n-\t\t\n-        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n-\t}\n\\ No newline at end of file\n+      }\n+    }\n+\n+    // Copy value references to lookup table.\n+    //\n+    Object[] lu = new Object[data.keynrs.length];\n+    for ( int i = 0; i < data.keynrs.length; i++ ) {\n+      // If the input is binary storage data, we convert it to normal storage.\n+      //\n+      if ( data.convertKeysToNative[i] ) {\n+        lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n+      } else {\n+        lu[i] = row[data.keynrs[i]];\n+      }\n+    }\n+\n+    // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n+    if ( data.keyTypes != null ) {\n+      for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n+        ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n+        ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n+        if ( inputValue.getType() != lookupValue.getType() ) {\n+          try {\n+            // Change the input value to match the lookup value\n+            //\n+            lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n+          } catch ( KettleValueException e ) {\n+            throw new KettleStepException( \"Error converting data while looking up value\", e );\n+          }\n+        }\n+      }\n+    }\n+\n+    Object[] add = null;\n+\n+    if ( data.hasLookupRows ) {\n+      try {\n+        if ( meta.getKeystream().length > 0 ) {\n+          add = getFromCache( data.keyTypes, lu );\n+        } else {\n+          // Just take the first element in the hashtable...\n+          throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n+        }\n+      } catch ( Exception e ) {\n+        throw new KettleStepException( e );\n+      }\n+    }\n+\n+    if ( add == null ) // nothing was found, unknown code: add the specified default value...\n+    {\n+      add = data.nullIf;\n+    }\n+\n+    return RowDataUtil.addRowData( row, rowMeta.size(), add );\n+  }\n\\ No newline at end of file\n",
            "actualSource": "  private Object[] lookupValues( RowMetaInterface rowMeta, Object[] row ) throws KettleException {\n    // See if we need to stop.\n    if ( isStopped() ) {\n      return null;\n    }\n\n    if ( data.lookupColumnIndex == null ) {\n      String[] names = data.lookupMeta.getFieldNames();\n      data.lookupColumnIndex = new int[names.length];\n\n      for ( int i = 0; i < names.length; i++ ) {\n        data.lookupColumnIndex[i] = rowMeta.indexOfValue( names[i] );\n        if ( data.lookupColumnIndex[i] < 0 ) {\n          // we should not get here\n          throw new KettleStepException( \"The lookup column '\" + names[i] + \"' could not be found\" );\n        }\n      }\n    }\n\n    // Copy value references to lookup table.\n    //\n    Object[] lu = new Object[data.keynrs.length];\n    for ( int i = 0; i < data.keynrs.length; i++ ) {\n      // If the input is binary storage data, we convert it to normal storage.\n      //\n      if ( data.convertKeysToNative[i] ) {\n        lu[i] = data.lookupMeta.getValueMeta( i ).convertBinaryStringToNativeType( (byte[]) row[data.keynrs[i]] );\n      } else {\n        lu[i] = row[data.keynrs[i]];\n      }\n    }\n\n    // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n    if ( data.keyTypes != null ) {\n      for ( int i = 0; i < data.lookupMeta.size(); i++ ) {\n        ValueMetaInterface inputValue = data.lookupMeta.getValueMeta( i );\n        ValueMetaInterface lookupValue = data.keyTypes.getValueMeta( i );\n        if ( inputValue.getType() != lookupValue.getType() ) {\n          try {\n            // Change the input value to match the lookup value\n            //\n            lu[i] = lookupValue.convertDataCompatible( inputValue, lu[i] );\n          } catch ( KettleValueException e ) {\n            throw new KettleStepException( \"Error converting data while looking up value\", e );\n          }\n        }\n      }\n    }\n\n    Object[] add = null;\n\n    if ( data.hasLookupRows ) {\n      try {\n        if ( meta.getKeystream().length > 0 ) {\n          add = getFromCache( data.keyTypes, lu );\n        } else {\n          // Just take the first element in the hashtable...\n          throw new KettleStepException( BaseMessages.getString( PKG, \"StreamLookup.Log.GotRowWithoutKeys\" ) );\n        }\n      } catch ( Exception e ) {\n        throw new KettleStepException( e );\n      }\n    }\n\n    if ( add == null ) // nothing was found, unknown code: add the specified default value...\n    {\n      add = data.nullIf;\n    }\n\n    return RowDataUtil.addRowData( row, rowMeta.size(), add );\n  }",
            "path": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {}
        },
        "8ea99afbc19a7e512f6c562edc3b57d283e59a64": {
            "type": "Ybodychange",
            "commitMessage": "PDI-2694 : Allow setting of special characters as delimiter or enclosures in Textfile Input does not work (allow variables to use in different places)\nPDI-9810 : KTR can't be saved when field delimiter for any step is non-printable ASCII character\nPDI-9823 : Remove the $NON-NLS-1$ comments in the Kettle code since these are not used anywhere\nPDI-2306 : Sort step should support pre-sorted data\nPDI-9787 : The Kettle5 StepMetaInterface is behaving incompatible wrt getFields() and check()\nPDI-9728 : Apache Commons VFS library kettle-vfs-20100924.jar needs to be replaced with regular commons-vfs-1.0.jar\nPDI-8966 : EPIC: As a PDI plugin writer I want to be able to store my own shared objects in a repository or shared.xml\nPDI-8028 : Less intrusive Log4J usage\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@18354 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "25/04/13 4:11 PM",
            "commitName": "8ea99afbc19a7e512f6c562edc3b57d283e59a64",
            "commitAuthor": "mcasters",
            "commitDateOld": "05/04/13 10:27 AM",
            "commitNameOld": "a4bba8d75398234ec692c6d737f30e5437ebaf0a",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 20.24,
            "commitsBetweenForRepo": 64,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,86 +1,86 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \t\t\n \t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n \t\t//\n         Object[] lu = new Object[data.keynrs.length];\n         for (int i=0;i<data.keynrs.length;i++) {\n         \t// If the input is binary storage data, we convert it to normal storage.\n         \t//\n         \tif (data.convertKeysToNative[i]) {\n         \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n         \t} else {\n         \t\tlu[i] = row[data.keynrs[i]];\n         \t}\n         }\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                     \t// Change the input value to match the lookup value\n                     \t//\n                         lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n \t\tif (data.hasLookupRows) \n \t\t{\n \t\t\ttry\n \t\t\t{\n \t\t\t\tif (meta.getKeystream().length>0)\n \t\t\t\t{\n \t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\t// Just take the first element in the hashtable...\n-\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n+\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); \n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch(Exception e)\n \t\t\t{\n \t\t\t\tthrow new KettleStepException(e);\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n \t\t{\n \t\t\tadd=data.nullIf;\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) {\n        \t// If the input is binary storage data, we convert it to normal storage.\n        \t//\n        \tif (data.convertKeysToNative[i]) {\n        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n        \t} else {\n        \t\tlu[i] = row[data.keynrs[i]];\n        \t}\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); \n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {}
        },
        "961d41fce33c408a84b9c5b93e656dc4324c8419": {
            "type": "Yfilerename",
            "commitMessage": "\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/branches/trunk-restruct@17636 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "05/12/12 2:16 PM",
            "commitName": "961d41fce33c408a84b9c5b93e656dc4324c8419",
            "commitAuthor": "sflatley",
            "commitDateOld": "05/12/12 2:15 PM",
            "commitNameOld": "12dee89bbdc6e1bbf3fd7082b9d5b3feb31a3a05",
            "commitAuthorOld": "sflatley",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) {\n        \t// If the input is binary storage data, we convert it to normal storage.\n        \t//\n        \tif (data.convertKeysToNative[i]) {\n        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n        \t} else {\n        \t\tlu[i] = row[data.keynrs[i]];\n        \t}\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {
                "oldPath": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                "newPath": "engine/src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java"
            }
        },
        "299b7c6933d259cfac52b7be050e1b1b3519a61a": {
            "type": "Ybodychange",
            "commitMessage": "PDI-2135 : Get rid of Messages classes\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@10600 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "18/05/09 2:33 PM",
            "commitName": "299b7c6933d259cfac52b7be050e1b1b3519a61a",
            "commitAuthor": "mcasters",
            "commitDateOld": "03/09/08 11:49 AM",
            "commitNameOld": "eee813268b04bba5410b6564f6f07789f63fffc8",
            "commitAuthorOld": "jbleuel",
            "daysBetweenCommits": 257.11,
            "commitsBetweenForRepo": 1064,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,86 +1,86 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \t\t\n \t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n \t\t//\n         Object[] lu = new Object[data.keynrs.length];\n         for (int i=0;i<data.keynrs.length;i++) {\n         \t// If the input is binary storage data, we convert it to normal storage.\n         \t//\n         \tif (data.convertKeysToNative[i]) {\n         \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n         \t} else {\n         \t\tlu[i] = row[data.keynrs[i]];\n         \t}\n         }\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                     \t// Change the input value to match the lookup value\n                     \t//\n                         lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n \t\tif (data.hasLookupRows) \n \t\t{\n \t\t\ttry\n \t\t\t{\n \t\t\t\tif (meta.getKeystream().length>0)\n \t\t\t\t{\n \t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\t// Just take the first element in the hashtable...\n-\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n+\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch(Exception e)\n \t\t\t{\n \t\t\t\tthrow new KettleStepException(e);\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n \t\t{\n \t\t\tadd=data.nullIf;\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) {\n        \t// If the input is binary storage data, we convert it to normal storage.\n        \t//\n        \tif (data.convertKeysToNative[i]) {\n        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n        \t} else {\n        \t\tlu[i] = row[data.keynrs[i]];\n        \t}\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(BaseMessages.getString(PKG, \"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1607"
        },
        "2eaad7ec877978aee5e2e3b429002cbed85db450": {
            "type": "Ymultichange(Yexceptionschange,Ybodychange)",
            "commitMessage": "PDI-1003 : Stream Lookup : class cast exceptions are thrown with binary storage input data and normal lookup data\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@7225 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "14/04/08 7:59 AM",
            "commitName": "2eaad7ec877978aee5e2e3b429002cbed85db450",
            "commitAuthor": "mcasters",
            "subchanges": [
                {
                    "type": "Yexceptionschange",
                    "commitMessage": "PDI-1003 : Stream Lookup : class cast exceptions are thrown with binary storage input data and normal lookup data\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@7225 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
                    "commitDate": "14/04/08 7:59 AM",
                    "commitName": "2eaad7ec877978aee5e2e3b429002cbed85db450",
                    "commitAuthor": "mcasters",
                    "commitDateOld": "09/01/08 7:48 AM",
                    "commitNameOld": "9be37156f1023db4aeba47161ad8d2139a38cb00",
                    "commitAuthorOld": "mcasters",
                    "daysBetweenCommits": 95.97,
                    "commitsBetweenForRepo": 559,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,78 +1,86 @@\n-    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n+    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n-\n+\t\t\n \t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n \t\t//\n         Object[] lu = new Object[data.keynrs.length];\n-        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n+        for (int i=0;i<data.keynrs.length;i++) {\n+        \t// If the input is binary storage data, we convert it to normal storage.\n+        \t//\n+        \tif (data.convertKeysToNative[i]) {\n+        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n+        \t} else {\n+        \t\tlu[i] = row[data.keynrs[i]];\n+        \t}\n+        }\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                     \t// Change the input value to match the lookup value\n                     \t//\n                         lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n \t\tif (data.hasLookupRows) \n \t\t{\n \t\t\ttry\n \t\t\t{\n \t\t\t\tif (meta.getKeystream().length>0)\n \t\t\t\t{\n \t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch(Exception e)\n \t\t\t{\n \t\t\t\tthrow new KettleStepException(e);\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n \t\t{\n \t\t\tadd=data.nullIf;\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
                    "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) {\n        \t// If the input is binary storage data, we convert it to normal storage.\n        \t//\n        \tif (data.convertKeysToNative[i]) {\n        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n        \t} else {\n        \t\tlu[i] = row[data.keynrs[i]];\n        \t}\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
                    "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                    "extendedDetails": {
                        "oldValue": "[KettleStepException]",
                        "newValue": "[KettleException]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "PDI-1003 : Stream Lookup : class cast exceptions are thrown with binary storage input data and normal lookup data\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@7225 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
                    "commitDate": "14/04/08 7:59 AM",
                    "commitName": "2eaad7ec877978aee5e2e3b429002cbed85db450",
                    "commitAuthor": "mcasters",
                    "commitDateOld": "09/01/08 7:48 AM",
                    "commitNameOld": "9be37156f1023db4aeba47161ad8d2139a38cb00",
                    "commitAuthorOld": "mcasters",
                    "daysBetweenCommits": 95.97,
                    "commitsBetweenForRepo": 559,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,78 +1,86 @@\n-    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n+    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n-\n+\t\t\n \t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n \t\t//\n         Object[] lu = new Object[data.keynrs.length];\n-        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n+        for (int i=0;i<data.keynrs.length;i++) {\n+        \t// If the input is binary storage data, we convert it to normal storage.\n+        \t//\n+        \tif (data.convertKeysToNative[i]) {\n+        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n+        \t} else {\n+        \t\tlu[i] = row[data.keynrs[i]];\n+        \t}\n+        }\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                     \t// Change the input value to match the lookup value\n                     \t//\n                         lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n \t\tif (data.hasLookupRows) \n \t\t{\n \t\t\ttry\n \t\t\t{\n \t\t\t\tif (meta.getKeystream().length>0)\n \t\t\t\t{\n \t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch(Exception e)\n \t\t\t{\n \t\t\t\tthrow new KettleStepException(e);\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n \t\t{\n \t\t\tadd=data.nullIf;\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
                    "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) {\n        \t// If the input is binary storage data, we convert it to normal storage.\n        \t//\n        \tif (data.convertKeysToNative[i]) {\n        \t\tlu[i] = data.lookupMeta.getValueMeta(i).convertBinaryStringToNativeType((byte[])row[data.keynrs[i]]);\n        \t} else {\n        \t\tlu[i] = row[data.keynrs[i]];\n        \t}\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
                    "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "19eeecd5426b9e977f948e783b5638b8e5907925": {
            "type": "Ybodychange",
            "commitMessage": "PDI-352 - adding compatible Type-to-String data conversion methods, making Stream Lookup and ValueMapper compatible with 2.5.x\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@5586 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "24/10/07 3:51 PM",
            "commitName": "19eeecd5426b9e977f948e783b5638b8e5907925",
            "commitAuthor": "mcasters",
            "commitDateOld": "24/09/07 2:33 PM",
            "commitNameOld": "3a0e1660877a13a4b92a96a85186fbd114795fa3",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 30.05,
            "commitsBetweenForRepo": 302,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,78 +1,78 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \n \t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n \t\t//\n         Object[] lu = new Object[data.keynrs.length];\n         for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                     \t// Change the input value to match the lookup value\n                     \t//\n-                        lu[i] = lookupValue.convertData(inputValue, lu[i]);\n+                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n \t\tif (data.hasLookupRows) \n \t\t{\n \t\t\ttry\n \t\t\t{\n \t\t\t\tif (meta.getKeystream().length>0)\n \t\t\t\t{\n \t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch(Exception e)\n \t\t\t{\n \t\t\t\tthrow new KettleStepException(e);\n \t\t\t}\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n \t\t{\n \t\t\tadd=data.nullIf;\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertDataCompatible(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "8"
        },
        "3a0e1660877a13a4b92a96a85186fbd114795fa3": {
            "type": "Ybodychange",
            "commitMessage": "Fix for bug PDI-146 : Stream lookup doesn't do default values anymore in v3\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@5117 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "24/09/07 2:33 PM",
            "commitName": "3a0e1660877a13a4b92a96a85186fbd114795fa3",
            "commitAuthor": "mcasters",
            "commitDateOld": "20/09/07 5:53 PM",
            "commitNameOld": "64c2d748ebc3a4de5fe715cdf71a186031778b4d",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 3.86,
            "commitsBetweenForRepo": 28,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,78 +1,78 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \n \t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n \t\t//\n         Object[] lu = new Object[data.keynrs.length];\n         for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                     \t// Change the input value to match the lookup value\n                     \t//\n                         lu[i] = lookupValue.convertData(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n \t\tif (data.hasLookupRows) \n \t\t{\n \t\t\ttry\n \t\t\t{\n \t\t\t\tif (meta.getKeystream().length>0)\n \t\t\t\t{\n \t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n \t\t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch(Exception e)\n \t\t\t{\n \t\t\t\tthrow new KettleStepException(e);\n \t\t\t}\n \t\t}\n \t\t\n-\t\tif (add==null) // nothing was found, unknown code: add null-values\n+\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n \t\t{\n-\t\t\tadd=new Object[meta.getValue().length];\n+\t\t\tadd=data.nullIf;\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertData(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add the specified default value...\n\t\t{\n\t\t\tadd=data.nullIf;\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "64c2d748ebc3a4de5fe715cdf71a186031778b4d": {
            "type": "Ybodychange",
            "commitMessage": "Metadata fix for the Row Normaliser step\nData conversion fix for the Stream Lookup step\nRace condition fix for the preview rows dialog (close before the display is fully refreshed)\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@5079 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "20/09/07 5:53 PM",
            "commitName": "64c2d748ebc3a4de5fe715cdf71a186031778b4d",
            "commitAuthor": "mcasters",
            "commitDateOld": "20/09/07 3:40 PM",
            "commitNameOld": "fb0913c9fc83add2b71024428a9327905067c207",
            "commitAuthorOld": "sboden",
            "daysBetweenCommits": 0.09,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,76 +1,78 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \n-\t\tif( data.lookupColumnIndex == null ) \n+\t\tif ( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n-        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n+\t\t//\n+        Object[] lu = new Object[data.keynrs.length];\n+        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n-                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n+                    \t// Change the input value to match the lookup value\n+                    \t//\n+                        lu[i] = lookupValue.convertData(inputValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add = null;\n         \n-        if ( data.hasLookupRows )  \n-        {\n-\t\t    try\n-\t\t    {\n-  \t\t\t    if (meta.getKeystream().length>0)\n-\t\t\t    {\n-\t\t\t\t    Object lookupData[] = new Object[data.lookupColumnIndex.length];\n-\t\t\t\t    for (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n-\t\t\t\t    add=getFromCache(data.lookupMeta, lookupData);\n-\t\t\t    }\n-\t\t\t    else\n-\t\t\t    {\n-\t\t\t\t    // Just take the first element in the hashtable...\n-\t\t\t\t    throw new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n-\t\t\t    }\n-\t\t    }\n-\t\t    catch(Exception e)\n-\t\t    {\n-\t\t\t    throw new KettleStepException(e);\n-\t\t    }\n-        }\n+\t\tif (data.hasLookupRows) \n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\tif (meta.getKeystream().length>0)\n+\t\t\t\t{\n+\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\t// Just take the first element in the hashtable...\n+\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcatch(Exception e)\n+\t\t\t{\n+\t\t\t\tthrow new KettleStepException(e);\n+\t\t\t}\n+\t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add null-values\n \t\t{\n \t\t\tadd=new Object[meta.getValue().length];\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif ( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n\t\t//\n        Object[] lu = new Object[data.keynrs.length];\n        for (int i=0;i<data.keynrs.length;i++) lu[i] = row[data.keynrs[i]];\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                    \t// Change the input value to match the lookup value\n                    \t//\n                        lu[i] = lookupValue.convertData(inputValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n\t\tif (data.hasLookupRows) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (meta.getKeystream().length>0)\n\t\t\t\t{\n\t\t\t\t\tadd=getFromCache(data.keyTypes, lu);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow new KettleStepException(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "fb0913c9fc83add2b71024428a9327905067c207": {
            "type": "Ybodychange",
            "commitMessage": "Fix for PDI-194 : special case when no lookup rows are present\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@5077 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "20/09/07 3:40 PM",
            "commitName": "fb0913c9fc83add2b71024428a9327905067c207",
            "commitAuthor": "sboden",
            "commitDateOld": "18/09/07 8:14 AM",
            "commitNameOld": "d81a0f9f13cc393694b11a88a9ea39a98550fe46",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 2.31,
            "commitsBetweenForRepo": 29,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,73 +1,76 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \n \t\tif( data.lookupColumnIndex == null ) \n \t\t{\n \t\t\tString names[] = data.lookupMeta.getFieldNames();\n \t\t\tdata.lookupColumnIndex = new int[names.length];\n \t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n \t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n \t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n \t\t\t\t\t// we should not get here\n \t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n         Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                         lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n-        Object[] add;\n+        Object[] add = null;\n         \n-\t\ttry\n-\t\t{\n-\t\t\tif (meta.getKeystream().length>0)\n-\t\t\t{\n-\t\t\t\tObject lookupData[] = new Object[data.lookupColumnIndex.length];\n-\t\t\t\tfor (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n-\t\t\t\tadd=getFromCache(data.lookupMeta, lookupData);\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// Just take the first element in the hashtable...\n-\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n-\t\t\t}\n-\t\t}\n-\t\tcatch(Exception e)\n-\t\t{\n-\t\t\tthrow new KettleStepException(e);\n-\t\t}\n+        if ( data.hasLookupRows )  \n+        {\n+\t\t    try\n+\t\t    {\n+  \t\t\t    if (meta.getKeystream().length>0)\n+\t\t\t    {\n+\t\t\t\t    Object lookupData[] = new Object[data.lookupColumnIndex.length];\n+\t\t\t\t    for (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n+\t\t\t\t    add=getFromCache(data.lookupMeta, lookupData);\n+\t\t\t    }\n+\t\t\t    else\n+\t\t\t    {\n+\t\t\t\t    // Just take the first element in the hashtable...\n+\t\t\t\t    throw new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n+\t\t\t    }\n+\t\t    }\n+\t\t    catch(Exception e)\n+\t\t    {\n+\t\t\t    throw new KettleStepException(e);\n+\t\t    }\n+        }\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add null-values\n \t\t{\n \t\t\tadd=new Object[meta.getValue().length];\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add = null;\n        \n        if ( data.hasLookupRows )  \n        {\n\t\t    try\n\t\t    {\n  \t\t\t    if (meta.getKeystream().length>0)\n\t\t\t    {\n\t\t\t\t    Object lookupData[] = new Object[data.lookupColumnIndex.length];\n\t\t\t\t    for (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n\t\t\t\t    add=getFromCache(data.lookupMeta, lookupData);\n\t\t\t    }\n\t\t\t    else\n\t\t\t    {\n\t\t\t\t    // Just take the first element in the hashtable...\n\t\t\t\t    throw new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t    }\n\t\t    }\n\t\t    catch(Exception e)\n\t\t    {\n\t\t\t    throw new KettleStepException(e);\n\t\t    }\n        }\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "b1f6ee29049d22e120573802a2d79891cbd0c169": {
            "type": "Ybodychange",
            "commitMessage": "Fix for PDI-100\nAlso compatibility fix for Integer-to-String (default = without decimal .)\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@4811 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "05/09/07 1:47 PM",
            "commitName": "b1f6ee29049d22e120573802a2d79891cbd0c169",
            "commitAuthor": "mcasters",
            "commitDateOld": "24/08/07 2:57 PM",
            "commitNameOld": "27dfc80bc3a03eedc801b0d3a19e65a295641cff",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 11.95,
            "commitsBetweenForRepo": 66,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,74 +1,73 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \n-\t\tif( lookupColumnIndex == -1 ) \n+\t\tif( data.lookupColumnIndex == null ) \n \t\t{\n-\t\t\tString names[] = rowMeta.getFieldNames();\n+\t\t\tString names[] = data.lookupMeta.getFieldNames();\n+\t\t\tdata.lookupColumnIndex = new int[names.length];\n+\t\t\t\n \t\t\tfor( int i=0; i<names.length; i++ ) \n \t\t\t{\n-\t\t\t\tif( names[i].equals( data.lookupMeta.getValueMeta(0).getName() ) ) \n+\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n+\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n \t\t\t\t{\n-\t\t\t\t\tlookupColumnIndex = i;\n-\t\t\t\t\tbreak;\n+\t\t\t\t\t// we should not get here\n+\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\tif( lookupColumnIndex == - 1 ) \n-\t\t{\n-\t\t\t// we should not get here\n-\t\t\tthrow new KettleStepException( \"The lookup column could not be found\" );\n-\t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n         Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                         lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add;\n         \n \t\ttry\n \t\t{\n \t\t\tif (meta.getKeystream().length>0)\n \t\t\t{\n-\t\t\t\tObject lookupData[] = new Object[] { row[ lookupColumnIndex ] };\n+\t\t\t\tObject lookupData[] = new Object[data.lookupColumnIndex.length];\n+\t\t\t\tfor (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n \t\t\t\tadd=getFromCache(data.lookupMeta, lookupData);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t}\n \t\t}\n \t\tcatch(Exception e)\n \t\t{\n \t\t\tthrow new KettleStepException(e);\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add null-values\n \t\t{\n \t\t\tadd=new Object[meta.getValue().length];\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif( data.lookupColumnIndex == null ) \n\t\t{\n\t\t\tString names[] = data.lookupMeta.getFieldNames();\n\t\t\tdata.lookupColumnIndex = new int[names.length];\n\t\t\t\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tdata.lookupColumnIndex[i] = rowMeta.indexOfValue(names[i]);\n\t\t\t\tif ( data.lookupColumnIndex[i] < 0 ) \n\t\t\t\t{\n\t\t\t\t\t// we should not get here\n\t\t\t\t\tthrow new KettleStepException( \"The lookup column '\"+names[i]+\"' could not be found\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tObject lookupData[] = new Object[data.lookupColumnIndex.length];\n\t\t\t\tfor (int i=0;i<lookupData.length;i++) lookupData[i] = row[data.lookupColumnIndex[i]];\n\t\t\t\tadd=getFromCache(data.lookupMeta, lookupData);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "97d77cd9f67d41901e9f5aa3899c40da173790f7": {
            "type": "Ybodychange",
            "commitMessage": "Fixed a problem where the stream lookup would only use the first column of the input rowset to use for the lookup.\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@4382 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "24/07/07 9:14 PM",
            "commitName": "97d77cd9f67d41901e9f5aa3899c40da173790f7",
            "commitAuthor": "jdixon",
            "commitDateOld": "20/07/07 12:49 PM",
            "commitNameOld": "afa3ceb590b7928258b31232e9bddaca0eefe3b0",
            "commitAuthorOld": "sboden",
            "daysBetweenCommits": 4.35,
            "commitsBetweenForRepo": 70,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,55 +1,74 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n+\n+\t\tif( lookupColumnIndex == -1 ) \n+\t\t{\n+\t\t\tString names[] = rowMeta.getFieldNames();\n+\t\t\tfor( int i=0; i<names.length; i++ ) \n+\t\t\t{\n+\t\t\t\tif( names[i].equals( data.lookupMeta.getValueMeta(0).getName() ) ) \n+\t\t\t\t{\n+\t\t\t\t\tlookupColumnIndex = i;\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif( lookupColumnIndex == - 1 ) \n+\t\t{\n+\t\t\t// we should not get here\n+\t\t\tthrow new KettleStepException( \"The lookup column could not be found\" );\n+\t\t}\n \t\t\n \t\t// Copy value references to lookup table.\n         Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                         lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add;\n         \n \t\ttry\n \t\t{\n \t\t\tif (meta.getKeystream().length>0)\n \t\t\t{\n-\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n+\t\t\t\tObject lookupData[] = new Object[] { row[ lookupColumnIndex ] };\n+\t\t\t\tadd=getFromCache(data.lookupMeta, lookupData);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t}\n \t\t}\n \t\tcatch(Exception e)\n \t\t{\n \t\t\tthrow new KettleStepException(e);\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add null-values\n \t\t{\n \t\t\tadd=new Object[meta.getValue().length];\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\n\t\tif( lookupColumnIndex == -1 ) \n\t\t{\n\t\t\tString names[] = rowMeta.getFieldNames();\n\t\t\tfor( int i=0; i<names.length; i++ ) \n\t\t\t{\n\t\t\t\tif( names[i].equals( data.lookupMeta.getValueMeta(0).getName() ) ) \n\t\t\t\t{\n\t\t\t\t\tlookupColumnIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( lookupColumnIndex == - 1 ) \n\t\t{\n\t\t\t// we should not get here\n\t\t\tthrow new KettleStepException( \"The lookup column could not be found\" );\n\t\t}\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tObject lookupData[] = new Object[] { row[ lookupColumnIndex ] };\n\t\t\t\tadd=getFromCache(data.lookupMeta, lookupData);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "d440afbcb25ab8dc43ebafca88ca2340ae2b11c3": {
            "type": "Ybodychange",
            "commitMessage": "A whole slew of performance updates and architecture changes in the recently ported steps.\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@3984 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "04/07/07 9:33 AM",
            "commitName": "d440afbcb25ab8dc43ebafca88ca2340ae2b11c3",
            "commitAuthor": "mcasters",
            "commitDateOld": "03/07/07 12:10 PM",
            "commitNameOld": "26b2d9cc609d575939e68f55cce86671fb4c54c3",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 0.89,
            "commitsBetweenForRepo": 22,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,55 +1,55 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n \t\tif (isStopped()) return null;\n \t\t\n \t\t// Copy value references to lookup table.\n         Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                         lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add;\n         \n \t\ttry\n \t\t{\n \t\t\tif (meta.getKeystream().length>0)\n \t\t\t{\n \t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t}\n \t\t}\n \t\tcatch(Exception e)\n \t\t{\n \t\t\tthrow new KettleStepException(e);\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add null-values\n \t\t{\n \t\t\tadd=new Object[meta.getValue().length];\n \t\t} \n \t\t\n-        return RowDataUtil.addRowData(row, add);\n+        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, rowMeta.size(), add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "41"
        },
        "26b2d9cc609d575939e68f55cce86671fb4c54c3": {
            "type": "Ybodychange",
            "commitMessage": "First step at improving speed by reducing locking in BaseStep/RowSet, needs more testing\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@3961 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "03/07/07 12:10 PM",
            "commitName": "26b2d9cc609d575939e68f55cce86671fb4c54c3",
            "commitAuthor": "mcasters",
            "commitDateOld": "30/06/07 12:35 PM",
            "commitNameOld": "0710612b0487a026c94db27f06c10ee0362e7da7",
            "commitAuthorOld": "sboden",
            "daysBetweenCommits": 2.98,
            "commitsBetweenForRepo": 57,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,59 +1,55 @@\n     private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n \t{\n \t\t// See if we need to stop.\n-\t\tif (stopped) return null;\n+\t\tif (isStopped()) return null;\n \t\t\n \t\t// Copy value references to lookup table.\n-        Object[] lu = new Object[data.keynrs.length];\n-\t\tfor (int i=0;i<meta.getKeystream().length;i++) \n-        {\n-            lu[i] = row[data.keynrs[i]];\n-        }\n+        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n \n         // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n         if (data.keyTypes!=null)\n         {\n             for (int i=0;i<data.lookupMeta.size();i++)\n             {\n                 ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                 ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                 if (inputValue.getType()!=lookupValue.getType())\n                 {\n                     try\n                     {\n                         lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                     }\n                     catch (KettleValueException e)\n                     {\n                         throw new KettleStepException(\"Error converting data while looking up value\", e);\n                     }\n                 }\n             }\n         }\n         \n         Object[] add;\n         \n \t\ttry\n \t\t{\n \t\t\tif (meta.getKeystream().length>0)\n \t\t\t{\n \t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\t// Just take the first element in the hashtable...\n \t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n \t\t\t}\n \t\t}\n \t\tcatch(Exception e)\n \t\t{\n \t\t\tthrow new KettleStepException(e);\n \t\t}\n \t\t\n \t\tif (add==null) // nothing was found, unknown code: add null-values\n \t\t{\n \t\t\tadd=new Object[meta.getValue().length];\n \t\t} \n \t\t\n         return RowDataUtil.addRowData(row, add);\n \t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (isStopped()) return null;\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = RowDataUtil.resizeArray(row, data.keynrs.length);\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "65"
        },
        "8cbabac3f10796e6c64bbf8a6d04f8945ac1162c": {
            "type": "Yfilerename",
            "commitMessage": "Renamed remotely\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@3644 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "16/06/07 2:25 PM",
            "commitName": "8cbabac3f10796e6c64bbf8a6d04f8945ac1162c",
            "commitAuthor": "mcasters",
            "commitDateOld": "16/06/07 2:25 PM",
            "commitNameOld": "ee88e4957d94d904b2c0b744d9811bd98390764a",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (stopped) return null;\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = new Object[data.keynrs.length];\n\t\tfor (int i=0;i<meta.getKeystream().length;i++) \n        {\n            lu[i] = row[data.keynrs[i]];\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {
                "oldPath": "experimental/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                "newPath": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        },
        "94cfff9d04254e88eaefd9e5bda0611efc133087": {
            "type": "Yfilerename",
            "commitMessage": "Renamed remotely\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@3642 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "16/06/07 2:25 PM",
            "commitName": "94cfff9d04254e88eaefd9e5bda0611efc133087",
            "commitAuthor": "mcasters",
            "commitDateOld": "16/06/07 2:23 PM",
            "commitNameOld": "f776cb62cbd3c0b8cf87b24448fbf6a106ea7001",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (stopped) return null;\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = new Object[data.keynrs.length];\n\t\tfor (int i=0;i<meta.getKeystream().length;i++) \n        {\n            lu[i] = row[data.keynrs[i]];\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, add);\n\t}",
            "path": "experimental/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {
                "oldPath": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                "newPath": "experimental/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        },
        "b0f90c9c3053cdc2a4d2e48510ef75c3d8d9bfd6": {
            "type": "Yfilerename",
            "commitMessage": "Renamed remotely\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@3640 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "16/06/07 2:23 PM",
            "commitName": "b0f90c9c3053cdc2a4d2e48510ef75c3d8d9bfd6",
            "commitAuthor": "mcasters",
            "commitDateOld": "16/06/07 2:15 PM",
            "commitNameOld": "d38ced60b16fd378b413b97e799317c67abb7538",
            "commitAuthorOld": "mcasters",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (stopped) return null;\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = new Object[data.keynrs.length];\n\t\tfor (int i=0;i<meta.getKeystream().length;i++) \n        {\n            lu[i] = row[data.keynrs[i]];\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, add);\n\t}",
            "path": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "extendedDetails": {
                "oldPath": "experimental/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
                "newPath": "src/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        },
        "c1e82ac689ddbb8a40aa142a9294500143aac804": {
            "type": "Yintroduced",
            "commitMessage": "3.0 : Adding stream lookup, another clear performance winner\n\ngit-svn-id: svn://source.pentaho.org/svnkettleroot/Kettle/trunk@3465 5fb7f6ec-07c1-534a-b4ca-9155e429e800\n",
            "commitDate": "16/05/07 9:26 AM",
            "commitName": "c1e82ac689ddbb8a40aa142a9294500143aac804",
            "commitAuthor": "mcasters",
            "diff": "@@ -0,0 +1,59 @@\n+    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n+\t{\n+\t\t// See if we need to stop.\n+\t\tif (stopped) return null;\n+\t\t\n+\t\t// Copy value references to lookup table.\n+        Object[] lu = new Object[data.keynrs.length];\n+\t\tfor (int i=0;i<meta.getKeystream().length;i++) \n+        {\n+            lu[i] = row[data.keynrs[i]];\n+        }\n+\n+        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n+        if (data.keyTypes!=null)\n+        {\n+            for (int i=0;i<data.lookupMeta.size();i++)\n+            {\n+                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n+                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n+                if (inputValue.getType()!=lookupValue.getType())\n+                {\n+                    try\n+                    {\n+                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n+                    }\n+                    catch (KettleValueException e)\n+                    {\n+                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n+                    }\n+                }\n+            }\n+        }\n+        \n+        Object[] add;\n+        \n+\t\ttry\n+\t\t{\n+\t\t\tif (meta.getKeystream().length>0)\n+\t\t\t{\n+\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\t// Just take the first element in the hashtable...\n+\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t}\n+\t\tcatch(Exception e)\n+\t\t{\n+\t\t\tthrow new KettleStepException(e);\n+\t\t}\n+\t\t\n+\t\tif (add==null) // nothing was found, unknown code: add null-values\n+\t\t{\n+\t\t\tadd=new Object[meta.getValue().length];\n+\t\t} \n+\t\t\n+        return RowDataUtil.addRowData(row, add);\n+\t}\n\\ No newline at end of file\n",
            "actualSource": "    private Object[] lookupValues(RowMetaInterface rowMeta, Object[] row) throws KettleStepException\n\t{\n\t\t// See if we need to stop.\n\t\tif (stopped) return null;\n\t\t\n\t\t// Copy value references to lookup table.\n        Object[] lu = new Object[data.keynrs.length];\n\t\tfor (int i=0;i<meta.getKeystream().length;i++) \n        {\n            lu[i] = row[data.keynrs[i]];\n        }\n\n        // Handle conflicting types (Number-Integer-String conversion to lookup type in hashtable)\n        if (data.keyTypes!=null)\n        {\n            for (int i=0;i<data.lookupMeta.size();i++)\n            {\n                ValueMetaInterface inputValue  = data.lookupMeta.getValueMeta(i);\n                ValueMetaInterface lookupValue = data.keyTypes.getValueMeta(i);\n                if (inputValue.getType()!=lookupValue.getType())\n                {\n                    try\n                    {\n                        lu[i] = inputValue.convertData(lookupValue, lu[i]);\n                    }\n                    catch (KettleValueException e)\n                    {\n                        throw new KettleStepException(\"Error converting data while looking up value\", e);\n                    }\n                }\n            }\n        }\n        \n        Object[] add;\n        \n\t\ttry\n\t\t{\n\t\t\tif (meta.getKeystream().length>0)\n\t\t\t{\n\t\t\t\tadd=getFromCache(data.lookupMeta, lu);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Just take the first element in the hashtable...\n\t\t\t\tthrow new KettleStepException(Messages.getString(\"StreamLookup.Log.GotRowWithoutKeys\")); //$NON-NLS-1$\n\t\t\t}\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tthrow new KettleStepException(e);\n\t\t}\n\t\t\n\t\tif (add==null) // nothing was found, unknown code: add null-values\n\t\t{\n\t\t\tadd=new Object[meta.getValue().length];\n\t\t} \n\t\t\n        return RowDataUtil.addRowData(row, add);\n\t}",
            "path": "experimental/org/pentaho/di/trans/steps/streamlookup/StreamLookup.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "30038.json"
}