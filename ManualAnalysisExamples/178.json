{
    "origin": "codeshovel",
    "repositoryName": "xerces2-j",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/xerces2-j/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "XPath.java",
    "functionName": "scanExpr",
    "functionId": "scanExpr___symbolTable-SymbolTable__tokens-XPath.Tokens__data-String__currentOffset-int__endOffset-int",
    "sourceFilePath": "src/org/apache/xerces/impl/xpath/XPath.java",
    "functionStartLine": 1325,
    "functionEndLine": 1894,
    "numCommitsSeen": 27,
    "timeTaken": 3148,
    "changeHistory": [
        "c0c0d3d4cf931ea4401135e6917f7007137f1740",
        "1dffa6c09c417fda5c8d5d28646d635fa7ace0e3",
        "b323cf979641925ef931a13bd932ae5a3e7ff824",
        "22c0e12e4b704d038f0b290865301ebf56f40455",
        "fbb0c02a970ab50fab7c77653b51e9fe8b09ff62",
        "3bb87fab1dd1396b8a11798849e522cb89594f6e",
        "7ff1ee2bfcb0c6c0fc2da1f083be16336576b89c",
        "9762a66d10ed1eeee1e05e81d378d67e574c914b",
        "ff27e70a869dad4629cf6d0421ad4aa00baa1088"
    ],
    "changeHistoryShort": {
        "ff27e70a869dad4629cf6d0421ad4aa00baa1088": "Ybodychange",
        "9762a66d10ed1eeee1e05e81d378d67e574c914b": "Ybodychange",
        "7ff1ee2bfcb0c6c0fc2da1f083be16336576b89c": "Ybodychange",
        "3bb87fab1dd1396b8a11798849e522cb89594f6e": "Ybodychange",
        "fbb0c02a970ab50fab7c77653b51e9fe8b09ff62": "Ybodychange",
        "22c0e12e4b704d038f0b290865301ebf56f40455": "Yfilerename",
        "b323cf979641925ef931a13bd932ae5a3e7ff824": "Ybodychange",
        "1dffa6c09c417fda5c8d5d28646d635fa7ace0e3": "Ybodychange",
        "c0c0d3d4cf931ea4401135e6917f7007137f1740": "Yintroduced"
    },
    "changeHistoryDetails": {
        "ff27e70a869dad4629cf6d0421ad4aa00baa1088": {
            "type": "Ybodychange",
            "commitMessage": "Fixing JIRA Bug #1280:\nhttp://issues.apache.org/jira/browse/XERCESJ-1280\n\nIn the XPath scanner there's a large case block which is missing a \"default:\". This caused\nit to loop forever on the same invalid character without ever progressing to the next one \nin the string (or breaking out of the loop if it's at the end of the string). Should be\nfixed now.\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@595205 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "14/11/07 8:56 PM",
            "commitName": "ff27e70a869dad4629cf6d0421ad4aa00baa1088",
            "commitAuthor": "Michael Glavassevich",
            "commitDateOld": "02/09/07 11:40 AM",
            "commitNameOld": "3ba5f1a061eb8a0c3ea5157735e0b468967cfeab",
            "commitAuthorOld": "Michael Glavassevich",
            "daysBetweenCommits": 73.43,
            "commitsBetweenForRepo": 28,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,566 +1,570 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n \n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                     } else if (ch == '|') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     } else if (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         // this is legal if the next token is non-existent or |\n                         do {\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                             ch = data.charAt(currentOffset);\n                         } while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D); \n                         if (currentOffset == endOffset || ch == '|') {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                             starIsMultiplyOperator = true;\n                             break;\n                         }\n                         throw new XPathException (\"c-general-xpath\");\n                     } else {                    // '.'\n                         throw new XPathException (\"c-general-xpath\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n                         prefixHandle = XMLSymbols.EMPTY_STRING;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n                     prefixHandle = XMLSymbols.EMPTY_STRING;\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n+                default:\n+                    // CHARTYPE_INVALID or CHARTYPE_OTHER\n+                    // We're not expecting to find either of these in a valid expression.\n+                    return false;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else if (ch == '|') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    } else if (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        // this is legal if the next token is non-existent or |\n                        do {\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                            ch = data.charAt(currentOffset);\n                        } while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D); \n                        if (currentOffset == endOffset || ch == '|') {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                            starIsMultiplyOperator = true;\n                            break;\n                        }\n                        throw new XPathException (\"c-general-xpath\");\n                    } else {                    // '.'\n                        throw new XPathException (\"c-general-xpath\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = XMLSymbols.EMPTY_STRING;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = XMLSymbols.EMPTY_STRING;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                default:\n                    // CHARTYPE_INVALID or CHARTYPE_OTHER\n                    // We're not expecting to find either of these in a valid expression.\n                    return false;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/xpath/XPath.java",
            "extendedDetails": {}
        },
        "9762a66d10ed1eeee1e05e81d378d67e574c914b": {
            "type": "Ybodychange",
            "commitMessage": "\"fix\" for bug 5950.  The bug itself is not valid,\nbut a modification of it whowed that our handling of . in XPath expressions--both\nwith and without surrounding whitespace--was broken when unions are in use.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@318687 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "04/09/02 8:51 AM",
            "commitName": "9762a66d10ed1eeee1e05e81d378d67e574c914b",
            "commitAuthor": "Neil Graham",
            "commitDateOld": "29/08/02 4:25 PM",
            "commitNameOld": "6f6a4b81a04241b053b5d02981daf8494d57fc9d",
            "commitAuthorOld": "Neil Graham",
            "daysBetweenCommits": 5.68,
            "commitsBetweenForRepo": 4,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,547 +1,566 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n \n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n+                    } else if (ch == '|') {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n+                        starIsMultiplyOperator = true;\n+                        currentOffset++;\n+                        break;\n+                    } else if (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n+                        // this is legal if the next token is non-existent or |\n+                        do {\n+                            if (++currentOffset == endOffset) {\n+                                break;\n+                            }\n+                            ch = data.charAt(currentOffset);\n+                        } while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D); \n+                        if (currentOffset == endOffset || ch == '|') {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n+                            starIsMultiplyOperator = true;\n+                            break;\n+                        }\n+                        throw new XPathException (\"c-general-xpath\");\n                     } else {                    // '.'\n                         throw new XPathException (\"c-general-xpath\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n                         prefixHandle = XMLSymbols.EMPTY_STRING;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n                     prefixHandle = XMLSymbols.EMPTY_STRING;\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else if (ch == '|') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    } else if (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        // this is legal if the next token is non-existent or |\n                        do {\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                            ch = data.charAt(currentOffset);\n                        } while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D); \n                        if (currentOffset == endOffset || ch == '|') {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                            starIsMultiplyOperator = true;\n                            break;\n                        }\n                        throw new XPathException (\"c-general-xpath\");\n                    } else {                    // '.'\n                        throw new XPathException (\"c-general-xpath\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = XMLSymbols.EMPTY_STRING;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = XMLSymbols.EMPTY_STRING;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/xpath/XPath.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "7ff1ee2bfcb0c6c0fc2da1f083be16336576b89c": {
            "type": "Ybodychange",
            "commitMessage": "1. Trying to improve the use of symbol tables. Many predefined Strings are\nadded to symbol tables every time the parser is reset. For small documents,\nthis would be a significant cost. Now since we call String#intern for Strings\nin the symbol table, it's sufficient to use String#intern for those predefined\nsymbols. This only needs to be performed once.\n2. These commonly used symbols are gethered together in a new class\nXMLSymbols.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@318617 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "13/08/02 3:57 PM",
            "commitName": "7ff1ee2bfcb0c6c0fc2da1f083be16336576b89c",
            "commitAuthor": "Shudi Gao",
            "commitDateOld": "09/07/02 1:49 PM",
            "commitNameOld": "d106a79f5ebe26ce7873bd0d8b56c0d125afc501",
            "commitAuthorOld": "Neil Graham",
            "daysBetweenCommits": 35.09,
            "commitsBetweenForRepo": 88,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,548 +1,547 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n-            final String emptySymbol = fSymbolTable.addSymbol(\"\");\n \n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                     } else {                    // '.'\n                         throw new XPathException (\"c-general-xpath\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n-                        prefixHandle = emptySymbol;\n+                        prefixHandle = XMLSymbols.EMPTY_STRING;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n-                    prefixHandle = emptySymbol;\n+                    prefixHandle = XMLSymbols.EMPTY_STRING;\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"c-general-xpath\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = XMLSymbols.EMPTY_STRING;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = XMLSymbols.EMPTY_STRING;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/xpath/XPath.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "29"
        },
        "3bb87fab1dd1396b8a11798849e522cb89594f6e": {
            "type": "Ybodychange",
            "commitMessage": "cleaning up hardcoded error message strings in the identity constraint code.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@318335 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "15/04/02 12:46 PM",
            "commitName": "3bb87fab1dd1396b8a11798849e522cb89594f6e",
            "commitAuthor": "Neil Graham",
            "commitDateOld": "27/03/02 3:09 PM",
            "commitNameOld": "fbb0c02a970ab50fab7c77653b51e9fe8b09ff62",
            "commitAuthorOld": "Neil Graham",
            "daysBetweenCommits": 18.86,
            "commitsBetweenForRepo": 37,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,548 +1,548 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n             final String emptySymbol = fSymbolTable.addSymbol(\"\");\n \n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                     } else {                    // '.'\n-                        throw new XPathException (\"Invalid character following '.'\");\n+                        throw new XPathException (\"c-general-xpath\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n                         prefixHandle = emptySymbol;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n                     prefixHandle = emptySymbol;\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n            final String emptySymbol = fSymbolTable.addSymbol(\"\");\n\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"c-general-xpath\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = emptySymbol;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = emptySymbol;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/xpath/XPath.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "fbb0c02a970ab50fab7c77653b51e9fe8b09ff62": {
            "type": "Ybodychange",
            "commitMessage": "getting rid of dead, commented-out code.  Hopefully this will make this lengthy class easier to understnnd; if we ever want the commented-out sections, we have no further to look than version 1.3 of this file.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@318298 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "27/03/02 3:09 PM",
            "commitName": "fbb0c02a970ab50fab7c77653b51e9fe8b09ff62",
            "commitAuthor": "Neil Graham",
            "commitDateOld": "28/01/02 5:15 PM",
            "commitNameOld": "925a49f1bb1418723537dce4c3d24344f0ff29c1",
            "commitAuthorOld": "Arnaud Le Hors",
            "daysBetweenCommits": 57.91,
            "commitsBetweenForRepo": 129,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,556 +1,548 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n             final String emptySymbol = fSymbolTable.addSymbol(\"\");\n \n-            /***\n-            if (XPath.Tokens.DUMP_TOKENS) {\n-                System.out.println(\"  <test>\");\n-                System.out.println(\"    <expression>\");\n-                System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n-                System.out.println(\"    </expression>\");\n-            }\n-            /***/\n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                     } else {                    // '.'\n                         throw new XPathException (\"Invalid character following '.'\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n                         prefixHandle = emptySymbol;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n                     prefixHandle = emptySymbol;\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n            final String emptySymbol = fSymbolTable.addSymbol(\"\");\n\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"Invalid character following '.'\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = emptySymbol;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = emptySymbol;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/xpath/XPath.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "22c0e12e4b704d038f0b290865301ebf56f40455": {
            "type": "Yfilerename",
            "commitMessage": "Package reorganization to include alpha XML Schema support.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@317824 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "25/10/01 1:36 PM",
            "commitName": "22c0e12e4b704d038f0b290865301ebf56f40455",
            "commitAuthor": "Elena Litani",
            "commitDateOld": "25/10/01 1:19 PM",
            "commitNameOld": "3df24be68cb7f1e208f460c2ab20fae4b605f528",
            "commitAuthorOld": "Shudi Gao",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n            final String emptySymbol = fSymbolTable.addSymbol(\"\");\n\n            /***\n            if (XPath.Tokens.DUMP_TOKENS) {\n                System.out.println(\"  <test>\");\n                System.out.println(\"    <expression>\");\n                System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n                System.out.println(\"    </expression>\");\n            }\n            /***/\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"Invalid character following '.'\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = emptySymbol;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = emptySymbol;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/xpath/XPath.java",
            "extendedDetails": {
                "oldPath": "src/org/apache/xerces/impl/v2/xpath/XPath.java",
                "newPath": "src/org/apache/xerces/impl/xpath/XPath.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "305"
        },
        "b323cf979641925ef931a13bd932ae5a3e7ff824": {
            "type": "Ybodychange",
            "commitMessage": "consistently use empty string for prefix and null for uri when absent\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@317795 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "23/10/01 12:39 PM",
            "commitName": "b323cf979641925ef931a13bd932ae5a3e7ff824",
            "commitAuthor": "Lisa Martin",
            "commitDateOld": "05/10/01 3:28 PM",
            "commitNameOld": "1dffa6c09c417fda5c8d5d28646d635fa7ace0e3",
            "commitAuthorOld": "Neil Graham",
            "daysBetweenCommits": 17.88,
            "commitsBetweenForRepo": 117,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,555 +1,556 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n+            final String emptySymbol = fSymbolTable.addSymbol(\"\");\n \n             /***\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 System.out.println(\"  <test>\");\n                 System.out.println(\"    <expression>\");\n                 System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n                 System.out.println(\"    </expression>\");\n             }\n             /***/\n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                     } else {                    // '.'\n                         throw new XPathException (\"Invalid character following '.'\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n-                        prefixHandle = null;\n+                        prefixHandle = emptySymbol;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n-                    prefixHandle = \"\";\n+                    prefixHandle = emptySymbol;\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n            final String emptySymbol = fSymbolTable.addSymbol(\"\");\n\n            /***\n            if (XPath.Tokens.DUMP_TOKENS) {\n                System.out.println(\"  <test>\");\n                System.out.println(\"    <expression>\");\n                System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n                System.out.println(\"    </expression>\");\n            }\n            /***/\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"Invalid character following '.'\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = emptySymbol;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = emptySymbol;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/v2/xpath/XPath.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "1dffa6c09c417fda5c8d5d28646d635fa7ace0e3": {
            "type": "Ybodychange",
            "commitMessage": "fixed some bugs; generally prepared the way for dropping in the changes to the validator to accomodate Identity Constraints.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@317673 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "05/10/01 3:28 PM",
            "commitName": "1dffa6c09c417fda5c8d5d28646d635fa7ace0e3",
            "commitAuthor": "Neil Graham",
            "commitDateOld": "21/09/01 9:22 AM",
            "commitNameOld": "377abac3783b33ec43b60cd46f89ea8c86f639a1",
            "commitAuthorOld": "Shudi Gao",
            "daysBetweenCommits": 14.25,
            "commitsBetweenForRepo": 66,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,555 +1,555 @@\n         public boolean scanExpr(SymbolTable symbolTable,\n                                 XPath.Tokens tokens, String data,\n                                 int currentOffset, int endOffset)\n             throws XPathException {\n \n             int nameOffset;\n             String nameHandle, prefixHandle;\n             boolean starIsMultiplyOperator = false;\n             int ch;\n \n             /***\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 System.out.println(\"  <test>\");\n                 System.out.println(\"    <expression>\");\n                 System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n                 System.out.println(\"    </expression>\");\n             }\n             /***/\n             while (true) {\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 ch = data.charAt(currentOffset);\n                 //\n                 // [39] ExprWhitespace ::= S\n                 //\n                 while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                 }\n                 if (currentOffset == endOffset) {\n                     break;\n                 }\n                 //\n                 // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                 //                  | NameTest | NodeType | Operator | FunctionName\n                 //                  | AxisName | Literal | Number | VariableReference\n                 //\n                 byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                 switch (chartype) {\n                 case CHARTYPE_OPEN_PAREN:       // '('\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_PAREN:      // ')'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_OPEN_BRACKET:     // '['\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_CLOSE_BRACKET:    // ']'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                     starIsMultiplyOperator = true;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 //                                         ^^^^^^^^^^\n                 //\n                 case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                     if (currentOffset + 1 == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset + 1);\n                     if (ch == '.') {            // '..'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset += 2;\n                     } else if (ch >= '0' && ch <= '9') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                         starIsMultiplyOperator = true;\n                         currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     } else if (ch == '/') {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                         starIsMultiplyOperator = true;\n                         currentOffset++;\n                     } else {                    // '.'\n                         throw new XPathException (\"Invalid character following '.'\");\n                     }\n                     if (currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_ATSIGN:           // '@'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COMMA:            // ','\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_COLON:            // '::'\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 1a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != ':') {\n                 // System.out.println(\"abort 1b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_SLASH:            // '/' and '//'\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '/') { // '//'\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_UNION:            // '|'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_PLUS:             // '+'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_MINUS:            // '-'\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EQUAL:            // '='\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_EXCLAMATION:      // '!='\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2a\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch != '=') {\n                 // System.out.println(\"abort 2b\");\n                         return false; // REVISIT\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                     starIsMultiplyOperator = false;\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 case CHARTYPE_LESS: // '<' and '<='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '<='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 case CHARTYPE_GREATER: // '>' and '>='\n                     if (++currentOffset == endOffset) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                         break;\n                     }\n                     ch = data.charAt(currentOffset);\n                     if (ch == '=') { // '>='\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                         starIsMultiplyOperator = false;\n                     }\n                     break;\n                 //\n                 // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                 //\n                 case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                     int qchar = ch;\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2c\");\n                         return false; // REVISIT\n                     }\n                     ch = data.charAt(currentOffset);\n                     int litOffset = currentOffset;\n                     while (ch != qchar) {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 2d\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     int litLength = currentOffset - litOffset;\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                 // [31] Digits ::= [0-9]+\n                 //\n                 case CHARTYPE_DIGIT:\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                     starIsMultiplyOperator = true;\n                     currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                     break;\n                 //\n                 // [36] VariableReference ::= '$' QName\n                 //\n                 case CHARTYPE_DOLLAR:\n                     if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 3a\");\n                         return false; // REVISIT\n                     }\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 3b\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     if (ch != ':') {\n                         prefixHandle = null;\n                     } else {\n                         prefixHandle = nameHandle;\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 4a\");\n                             return false; // REVISIT\n                         }\n                         nameOffset = currentOffset;\n                         currentOffset = scanNCName(data, endOffset, currentOffset);\n                         if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4b\");\n                             return false; // REVISIT\n                         }\n                         if (currentOffset < endOffset) {\n                             ch = data.charAt(currentOffset);\n                         }\n                         else {\n                             ch = -1;\n                         }\n                         nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     }\n                     addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                     starIsMultiplyOperator = true;\n                     tokens.addToken(prefixHandle);\n                     tokens.addToken(nameHandle);\n                     break;\n                 //\n                 // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                 // [34] MultiplyOperator ::= '*'\n                 //\n                 case CHARTYPE_STAR:             // '*'\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then a * must be recognized as a MultiplyOperator.\n                     //\n                     // Otherwise, the token must not be recognized as a MultiplyOperator.\n                     //\n                     if (starIsMultiplyOperator) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                         starIsMultiplyOperator = false;\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                         starIsMultiplyOperator = true;\n                     }\n                     if (++currentOffset == endOffset) {\n                         break;\n                     }\n                     break;\n                 //\n                 // NCName, QName and non-terminals\n                 //\n                 case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                 case CHARTYPE_LETTER:\n                 case CHARTYPE_UNDERSCORE:\n                     //\n                     // 3.7 Lexical Structure\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                     // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                     // [35] FunctionName ::= QName - NodeType\n                     // [6] AxisName ::= (see above)\n                     //\n                     // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                     // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                     // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                     // [?] QName ::= (NCName ':')? NCName\n                     // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                     // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                     //\n                     nameOffset = currentOffset;\n                     currentOffset = scanNCName(data, endOffset, currentOffset);\n                     if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 4c\");\n                         return false; // REVISIT\n                     }\n                     if (currentOffset < endOffset) {\n                         ch = data.charAt(currentOffset);\n                     }\n                     else {\n                         ch = -1;\n                     }\n                     nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                     boolean isNameTestNCName = false;\n                     boolean isAxisName = false;\n-                    prefixHandle = null;\n+                    prefixHandle = \"\";\n                     if (ch == ':') {\n                         if (++currentOffset == endOffset) {\n                 // System.out.println(\"abort 5\");\n                             return false; // REVISIT\n                         }\n                         ch = data.charAt(currentOffset);\n                         if (ch == '*') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isNameTestNCName = true;\n                         } else if (ch == ':') {\n                             if (++currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             isAxisName = true;\n                         } else {\n                             prefixHandle = nameHandle;\n                             nameOffset = currentOffset;\n                             currentOffset = scanNCName(data, endOffset, currentOffset);\n                             if (currentOffset == nameOffset) {\n                 // System.out.println(\"abort 5b\");\n                                 return false; // REVISIT\n                             }\n                             if (currentOffset < endOffset) {\n                                 ch = data.charAt(currentOffset);\n                             }\n                             else {\n                                 ch = -1;\n                             }\n                             nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                         }\n                     }\n                     //\n                     // [39] ExprWhitespace ::= S\n                     //\n                     while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         ch = data.charAt(currentOffset);\n                     }\n                     //\n                     //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                     //  an Operator, then an NCName must be recognized as an OperatorName.\n                     //\n                     if (starIsMultiplyOperator) {\n                         if (nameHandle == fAndSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fOrSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fModSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                             starIsMultiplyOperator = false;\n                         } else if (nameHandle == fDivSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                             starIsMultiplyOperator = false;\n                         } else {\n                 // System.out.println(\"abort 6\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 7\");\n                             return false; // REVISIT - NCName:* where an OperatorName is required\n                         } else if (isAxisName) {\n                 // System.out.println(\"abort 8\");\n                             return false; // REVISIT - AxisName:: where an OperatorName is required\n                         }\n                         break;\n                     }\n                     //\n                     //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                     //  then the token must be recognized as a NodeType or a FunctionName.\n                     //\n                     if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                         if (nameHandle == fCommentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                         } else if (nameHandle == fTextSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                         } else if (nameHandle == fPISymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                         } else if (nameHandle == fNodeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                         } else {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                             tokens.addToken(prefixHandle);\n                             tokens.addToken(nameHandle);\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                         starIsMultiplyOperator = false;\n                         if (++currentOffset == endOffset) {\n                             break;\n                         }\n                         break;\n                     }\n                     //\n                     //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                     //  are ::, then the token must be recognized as an AxisName.\n                     //\n                     if (isAxisName ||\n                         (ch == ':' && currentOffset + 1 < endOffset &&\n                          data.charAt(currentOffset + 1) == ':')) {\n                         if (nameHandle == fAncestorSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                         } else if (nameHandle == fAncestorOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                         } else if (nameHandle == fAttributeSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                         } else if (nameHandle == fChildSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                         } else if (nameHandle == fDescendantSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                         } else if (nameHandle == fDescendantOrSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                         } else if (nameHandle == fFollowingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                         } else if (nameHandle == fFollowingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                         } else if (nameHandle == fNamespaceSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                         } else if (nameHandle == fParentSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                         } else if (nameHandle == fPrecedingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                         } else if (nameHandle == fPrecedingSiblingSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                         } else if (nameHandle == fSelfSymbol) {\n                             addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                         } else {\n                 // System.out.println(\"abort 9\");\n                             return false; // REVISIT\n                         }\n                         if (isNameTestNCName) {\n                 // System.out.println(\"abort 10\");\n                             return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                         }\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                         starIsMultiplyOperator = false;\n                         if (!isAxisName) {\n                             currentOffset++;\n                             if (++currentOffset == endOffset) {\n                                 break;\n                             }\n                         }\n                         break;\n                     }\n                     //\n                     //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                     //  FunctionName, or an AxisName.\n                     //\n                     if (isNameTestNCName) {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(nameHandle);\n                     } else {\n                         addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                         starIsMultiplyOperator = true;\n                         tokens.addToken(prefixHandle);\n                         tokens.addToken(nameHandle);\n                     }\n                     break;\n                 }\n             }\n             if (XPath.Tokens.DUMP_TOKENS) {\n                 tokens.dumpTokens();\n             }\n             return true;\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n\n            /***\n            if (XPath.Tokens.DUMP_TOKENS) {\n                System.out.println(\"  <test>\");\n                System.out.println(\"    <expression>\");\n                System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n                System.out.println(\"    </expression>\");\n            }\n            /***/\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"Invalid character following '.'\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n                // System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n                // System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = null;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = \"\";\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n                // System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n                // System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n                // System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n                // System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n                // System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n                // System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/v2/xpath/XPath.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "c0c0d3d4cf931ea4401135e6917f7007137f1740": {
            "type": "Yintroduced",
            "commitMessage": "Added identity constraint code, ported from the v1 package.  Several\nthings to note:\n\n1.  Broke out an xpath package from the original \"identity\" package.\nI did this so that, should we need the xpath code for something other\nthan identity constraint support (such as DOM level 3), it's there.\n\n2.  I've merged the unique and key classes and also their traversers.\nI did this because, from a schema compilation prospective, they're\nvirtually identical; the differences with respect to validation can be\naccomodated with the type field of the base class.\n\n3.  I've also changed the storage implementation in the grammar class\nfrom being Vector'based to being array based.  This allows <keyref>s\nto store indeces of the keys they reference rather than object\nreferences.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/xerces/java/trunk@317576 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "13/09/01 2:26 PM",
            "commitName": "c0c0d3d4cf931ea4401135e6917f7007137f1740",
            "commitAuthor": "Neil Graham",
            "diff": "@@ -0,0 +1,555 @@\n+        public boolean scanExpr(SymbolTable symbolTable,\n+                                XPath.Tokens tokens, String data,\n+                                int currentOffset, int endOffset)\n+            throws XPathException {\n+\n+            int nameOffset;\n+            String nameHandle, prefixHandle;\n+            boolean starIsMultiplyOperator = false;\n+            int ch;\n+\n+            /***\n+            if (XPath.Tokens.DUMP_TOKENS) {\n+                System.out.println(\"  <test>\");\n+                System.out.println(\"    <expression>\");\n+                System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n+                System.out.println(\"    </expression>\");\n+            }\n+            /***/\n+            while (true) {\n+                if (currentOffset == endOffset) {\n+                    break;\n+                }\n+                ch = data.charAt(currentOffset);\n+                //\n+                // [39] ExprWhitespace ::= S\n+                //\n+                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                }\n+                if (currentOffset == endOffset) {\n+                    break;\n+                }\n+                //\n+                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n+                //                  | NameTest | NodeType | Operator | FunctionName\n+                //                  | AxisName | Literal | Number | VariableReference\n+                //\n+                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n+                switch (chartype) {\n+                case CHARTYPE_OPEN_PAREN:       // '('\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_CLOSE_PAREN:      // ')'\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n+                    starIsMultiplyOperator = true;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_OPEN_BRACKET:     // '['\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_CLOSE_BRACKET:    // ']'\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n+                    starIsMultiplyOperator = true;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                //\n+                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n+                //                                         ^^^^^^^^^^\n+                //\n+                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n+                    if (currentOffset + 1 == endOffset) {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n+                        starIsMultiplyOperator = true;\n+                        currentOffset++;\n+                        break;\n+                    }\n+                    ch = data.charAt(currentOffset + 1);\n+                    if (ch == '.') {            // '..'\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n+                        starIsMultiplyOperator = true;\n+                        currentOffset += 2;\n+                    } else if (ch >= '0' && ch <= '9') {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n+                        starIsMultiplyOperator = true;\n+                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n+                    } else if (ch == '/') {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n+                        starIsMultiplyOperator = true;\n+                        currentOffset++;\n+                    } else {                    // '.'\n+                        throw new XPathException (\"Invalid character following '.'\");\n+                    }\n+                    if (currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_ATSIGN:           // '@'\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_COMMA:            // ','\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_COLON:            // '::'\n+                    if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 1a\");\n+                        return false; // REVISIT\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                    if (ch != ':') {\n+\t\t\t\t// System.out.println(\"abort 1b\");\n+                        return false; // REVISIT\n+                    }\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_SLASH:            // '/' and '//'\n+                    if (++currentOffset == endOffset) {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n+                        starIsMultiplyOperator = false;\n+                        break;\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                    if (ch == '/') { // '//'\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n+                        starIsMultiplyOperator = false;\n+                        if (++currentOffset == endOffset) {\n+                            break;\n+                        }\n+                    } else {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n+                        starIsMultiplyOperator = false;\n+                    }\n+                    break;\n+                case CHARTYPE_UNION:            // '|'\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_PLUS:             // '+'\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_MINUS:            // '-'\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_EQUAL:            // '='\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_EXCLAMATION:      // '!='\n+                    if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 2a\");\n+                        return false; // REVISIT\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                    if (ch != '=') {\n+\t\t\t\t// System.out.println(\"abort 2b\");\n+                        return false; // REVISIT\n+                    }\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n+                    starIsMultiplyOperator = false;\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                case CHARTYPE_LESS: // '<' and '<='\n+                    if (++currentOffset == endOffset) {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n+                        starIsMultiplyOperator = false;\n+                        break;\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                    if (ch == '=') { // '<='\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n+                        starIsMultiplyOperator = false;\n+                        if (++currentOffset == endOffset) {\n+                            break;\n+                        }\n+                    } else {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n+                        starIsMultiplyOperator = false;\n+                    }\n+                    break;\n+                case CHARTYPE_GREATER: // '>' and '>='\n+                    if (++currentOffset == endOffset) {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n+                        starIsMultiplyOperator = false;\n+                        break;\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                    if (ch == '=') { // '>='\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n+                        starIsMultiplyOperator = false;\n+                        if (++currentOffset == endOffset) {\n+                            break;\n+                        }\n+                    } else {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n+                        starIsMultiplyOperator = false;\n+                    }\n+                    break;\n+                //\n+                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n+                //\n+                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n+                    int qchar = ch;\n+                    if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 2c\");\n+                        return false; // REVISIT\n+                    }\n+                    ch = data.charAt(currentOffset);\n+                    int litOffset = currentOffset;\n+                    while (ch != qchar) {\n+                        if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 2d\");\n+                            return false; // REVISIT\n+                        }\n+                        ch = data.charAt(currentOffset);\n+                    }\n+                    int litLength = currentOffset - litOffset;\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n+                    starIsMultiplyOperator = true;\n+                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                //\n+                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n+                // [31] Digits ::= [0-9]+\n+                //\n+                case CHARTYPE_DIGIT:\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n+                    starIsMultiplyOperator = true;\n+                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n+                    break;\n+                //\n+                // [36] VariableReference ::= '$' QName\n+                //\n+                case CHARTYPE_DOLLAR:\n+                    if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 3a\");\n+                        return false; // REVISIT\n+                    }\n+                    nameOffset = currentOffset;\n+                    currentOffset = scanNCName(data, endOffset, currentOffset);\n+                    if (currentOffset == nameOffset) {\n+\t\t\t\t// System.out.println(\"abort 3b\");\n+                        return false; // REVISIT\n+                    }\n+                    if (currentOffset < endOffset) {\n+                        ch = data.charAt(currentOffset);\n+                    }\n+                    else {\n+                        ch = -1;\n+                    }\n+                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n+                    if (ch != ':') {\n+                        prefixHandle = null;\n+                    } else {\n+                        prefixHandle = nameHandle;\n+                        if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 4a\");\n+                            return false; // REVISIT\n+                        }\n+                        nameOffset = currentOffset;\n+                        currentOffset = scanNCName(data, endOffset, currentOffset);\n+                        if (currentOffset == nameOffset) {\n+\t\t\t\t// System.out.println(\"abort 4b\");\n+                            return false; // REVISIT\n+                        }\n+                        if (currentOffset < endOffset) {\n+                            ch = data.charAt(currentOffset);\n+                        }\n+                        else {\n+                            ch = -1;\n+                        }\n+                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n+                    }\n+                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n+                    starIsMultiplyOperator = true;\n+                    tokens.addToken(prefixHandle);\n+                    tokens.addToken(nameHandle);\n+                    break;\n+                //\n+                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n+                // [34] MultiplyOperator ::= '*'\n+                //\n+                case CHARTYPE_STAR:             // '*'\n+                    //\n+                    // 3.7 Lexical Structure\n+                    //\n+                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n+                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n+                    //\n+                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n+                    //\n+                    if (starIsMultiplyOperator) {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n+                        starIsMultiplyOperator = false;\n+                    } else {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n+                        starIsMultiplyOperator = true;\n+                    }\n+                    if (++currentOffset == endOffset) {\n+                        break;\n+                    }\n+                    break;\n+                //\n+                // NCName, QName and non-terminals\n+                //\n+                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n+                case CHARTYPE_LETTER:\n+                case CHARTYPE_UNDERSCORE:\n+                    //\n+                    // 3.7 Lexical Structure\n+                    //\n+                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n+                    //  an Operator, then an NCName must be recognized as an OperatorName.\n+                    //\n+                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n+                    //  then the token must be recognized as a NodeType or a FunctionName.\n+                    //\n+                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n+                    //  are ::, then the token must be recognized as an AxisName.\n+                    //\n+                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n+                    //  FunctionName, or an AxisName.\n+                    //\n+                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n+                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n+                    // [35] FunctionName ::= QName - NodeType\n+                    // [6] AxisName ::= (see above)\n+                    //\n+                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n+                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n+                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n+                    // [?] QName ::= (NCName ':')? NCName\n+                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n+                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n+                    //\n+                    nameOffset = currentOffset;\n+                    currentOffset = scanNCName(data, endOffset, currentOffset);\n+                    if (currentOffset == nameOffset) {\n+\t\t\t\t// System.out.println(\"abort 4c\");\n+                        return false; // REVISIT\n+                    }\n+                    if (currentOffset < endOffset) {\n+                        ch = data.charAt(currentOffset);\n+                    }\n+                    else {\n+                        ch = -1;\n+                    }\n+                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n+                    boolean isNameTestNCName = false;\n+                    boolean isAxisName = false;\n+                    prefixHandle = null;\n+                    if (ch == ':') {\n+                        if (++currentOffset == endOffset) {\n+\t\t\t\t// System.out.println(\"abort 5\");\n+                            return false; // REVISIT\n+                        }\n+                        ch = data.charAt(currentOffset);\n+                        if (ch == '*') {\n+                            if (++currentOffset < endOffset) {\n+                                ch = data.charAt(currentOffset);\n+                            }\n+                            isNameTestNCName = true;\n+                        } else if (ch == ':') {\n+                            if (++currentOffset < endOffset) {\n+                                ch = data.charAt(currentOffset);\n+                            }\n+                            isAxisName = true;\n+                        } else {\n+                            prefixHandle = nameHandle;\n+                            nameOffset = currentOffset;\n+                            currentOffset = scanNCName(data, endOffset, currentOffset);\n+                            if (currentOffset == nameOffset) {\n+\t\t\t\t// System.out.println(\"abort 5b\");\n+                                return false; // REVISIT\n+                            }\n+                            if (currentOffset < endOffset) {\n+                                ch = data.charAt(currentOffset);\n+                            }\n+                            else {\n+                                ch = -1;\n+                            }\n+                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n+                        }\n+                    }\n+                    //\n+                    // [39] ExprWhitespace ::= S\n+                    //\n+                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n+                        if (++currentOffset == endOffset) {\n+                            break;\n+                        }\n+                        ch = data.charAt(currentOffset);\n+                    }\n+                    //\n+                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n+                    //  an Operator, then an NCName must be recognized as an OperatorName.\n+                    //\n+                    if (starIsMultiplyOperator) {\n+                        if (nameHandle == fAndSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n+                            starIsMultiplyOperator = false;\n+                        } else if (nameHandle == fOrSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n+                            starIsMultiplyOperator = false;\n+                        } else if (nameHandle == fModSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n+                            starIsMultiplyOperator = false;\n+                        } else if (nameHandle == fDivSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n+                            starIsMultiplyOperator = false;\n+                        } else {\n+\t\t\t\t// System.out.println(\"abort 6\");\n+                            return false; // REVISIT\n+                        }\n+                        if (isNameTestNCName) {\n+\t\t\t\t// System.out.println(\"abort 7\");\n+                            return false; // REVISIT - NCName:* where an OperatorName is required\n+                        } else if (isAxisName) {\n+\t\t\t\t// System.out.println(\"abort 8\");\n+                            return false; // REVISIT - AxisName:: where an OperatorName is required\n+                        }\n+                        break;\n+                    }\n+                    //\n+                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n+                    //  then the token must be recognized as a NodeType or a FunctionName.\n+                    //\n+                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n+                        if (nameHandle == fCommentSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n+                        } else if (nameHandle == fTextSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n+                        } else if (nameHandle == fPISymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n+                        } else if (nameHandle == fNodeSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n+                        } else {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n+                            tokens.addToken(prefixHandle);\n+                            tokens.addToken(nameHandle);\n+                        }\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n+                        starIsMultiplyOperator = false;\n+                        if (++currentOffset == endOffset) {\n+                            break;\n+                        }\n+                        break;\n+                    }\n+                    //\n+                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n+                    //  are ::, then the token must be recognized as an AxisName.\n+                    //\n+                    if (isAxisName ||\n+                        (ch == ':' && currentOffset + 1 < endOffset &&\n+                         data.charAt(currentOffset + 1) == ':')) {\n+                        if (nameHandle == fAncestorSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n+                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n+                        } else if (nameHandle == fAttributeSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n+                        } else if (nameHandle == fChildSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n+                        } else if (nameHandle == fDescendantSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n+                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n+                        } else if (nameHandle == fFollowingSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n+                        } else if (nameHandle == fFollowingSiblingSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n+                        } else if (nameHandle == fNamespaceSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n+                        } else if (nameHandle == fParentSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n+                        } else if (nameHandle == fPrecedingSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n+                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n+                        } else if (nameHandle == fSelfSymbol) {\n+                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n+                        } else {\n+\t\t\t\t// System.out.println(\"abort 9\");\n+                            return false; // REVISIT\n+                        }\n+                        if (isNameTestNCName) {\n+\t\t\t\t// System.out.println(\"abort 10\");\n+                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n+                        }\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n+                        starIsMultiplyOperator = false;\n+                        if (!isAxisName) {\n+                            currentOffset++;\n+                            if (++currentOffset == endOffset) {\n+                                break;\n+                            }\n+                        }\n+                        break;\n+                    }\n+                    //\n+                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n+                    //  FunctionName, or an AxisName.\n+                    //\n+                    if (isNameTestNCName) {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n+                        starIsMultiplyOperator = true;\n+                        tokens.addToken(nameHandle);\n+                    } else {\n+                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n+                        starIsMultiplyOperator = true;\n+                        tokens.addToken(prefixHandle);\n+                        tokens.addToken(nameHandle);\n+                    }\n+                    break;\n+                }\n+            }\n+            if (XPath.Tokens.DUMP_TOKENS) {\n+                tokens.dumpTokens();\n+            }\n+            return true;\n+        }\n\\ No newline at end of file\n",
            "actualSource": "        public boolean scanExpr(SymbolTable symbolTable,\n                                XPath.Tokens tokens, String data,\n                                int currentOffset, int endOffset)\n            throws XPathException {\n\n            int nameOffset;\n            String nameHandle, prefixHandle;\n            boolean starIsMultiplyOperator = false;\n            int ch;\n\n            /***\n            if (XPath.Tokens.DUMP_TOKENS) {\n                System.out.println(\"  <test>\");\n                System.out.println(\"    <expression>\");\n                System.out.println(\"      \" + encoding.createString(data, currentOffset, endOffset - currentOffset));\n                System.out.println(\"    </expression>\");\n            }\n            /***/\n            while (true) {\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                ch = data.charAt(currentOffset);\n                //\n                // [39] ExprWhitespace ::= S\n                //\n                while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                }\n                if (currentOffset == endOffset) {\n                    break;\n                }\n                //\n                // [28] ExprToken ::= '(' | ')' | '[' | ']' | '.' | '..' | '@' | ',' | '::'\n                //                  | NameTest | NodeType | Operator | FunctionName\n                //                  | AxisName | Literal | Number | VariableReference\n                //\n                byte chartype = (ch >= 0x80) ? CHARTYPE_NONASCII : fASCIICharMap[ch];\n                switch (chartype) {\n                case CHARTYPE_OPEN_PAREN:       // '('\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_PAREN:      // ')'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_PAREN);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_OPEN_BRACKET:     // '['\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_BRACKET);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_CLOSE_BRACKET:    // ']'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_CLOSE_BRACKET);\n                    starIsMultiplyOperator = true;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                //                                         ^^^^^^^^^^\n                //\n                case CHARTYPE_PERIOD:           // '.', '..' or '.' Digits\n                    if (currentOffset + 1 == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset + 1);\n                    if (ch == '.') {            // '..'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset += 2;\n                    } else if (ch >= '0' && ch <= '9') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                        starIsMultiplyOperator = true;\n                        currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    } else if (ch == '/') {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_PERIOD);\n                        starIsMultiplyOperator = true;\n                        currentOffset++;\n                    } else {                    // '.'\n                        throw new XPathException (\"Invalid character following '.'\");\n                    }\n                    if (currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_ATSIGN:           // '@'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_ATSIGN);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COMMA:            // ','\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_COMMA);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_COLON:            // '::'\n                    if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 1a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != ':') {\n\t\t\t\t// System.out.println(\"abort 1b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_SLASH:            // '/' and '//'\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '/') { // '//'\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DOUBLE_SLASH);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_SLASH);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_UNION:            // '|'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_UNION);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_PLUS:             // '+'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_PLUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_MINUS:            // '-'\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MINUS);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EQUAL:            // '='\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_EXCLAMATION:      // '!='\n                    if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 2a\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch != '=') {\n\t\t\t\t// System.out.println(\"abort 2b\");\n                        return false; // REVISIT\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_NOT_EQUAL);\n                    starIsMultiplyOperator = false;\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                case CHARTYPE_LESS: // '<' and '<='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '<='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_LESS);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                case CHARTYPE_GREATER: // '>' and '>='\n                    if (++currentOffset == endOffset) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                        break;\n                    }\n                    ch = data.charAt(currentOffset);\n                    if (ch == '=') { // '>='\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER_EQUAL);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_GREATER);\n                        starIsMultiplyOperator = false;\n                    }\n                    break;\n                //\n                // [29] Literal ::= '\"' [^\"]* '\"' | \"'\" [^']* \"'\"\n                //\n                case CHARTYPE_QUOTE:            // '\\\"' or '\\''\n                    int qchar = ch;\n                    if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 2c\");\n                        return false; // REVISIT\n                    }\n                    ch = data.charAt(currentOffset);\n                    int litOffset = currentOffset;\n                    while (ch != qchar) {\n                        if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 2d\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    int litLength = currentOffset - litOffset;\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_LITERAL);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(symbolTable.addSymbol(data.substring(litOffset, litOffset + litLength)));\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // [30] Number ::= Digits ('.' Digits?)? | '.' Digits\n                // [31] Digits ::= [0-9]+\n                //\n                case CHARTYPE_DIGIT:\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_NUMBER);\n                    starIsMultiplyOperator = true;\n                    currentOffset = scanNumber(tokens, data, endOffset, currentOffset/*, encoding*/);\n                    break;\n                //\n                // [36] VariableReference ::= '$' QName\n                //\n                case CHARTYPE_DOLLAR:\n                    if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 3a\");\n                        return false; // REVISIT\n                    }\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n\t\t\t\t// System.out.println(\"abort 3b\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    if (ch != ':') {\n                        prefixHandle = null;\n                    } else {\n                        prefixHandle = nameHandle;\n                        if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 4a\");\n                            return false; // REVISIT\n                        }\n                        nameOffset = currentOffset;\n                        currentOffset = scanNCName(data, endOffset, currentOffset);\n                        if (currentOffset == nameOffset) {\n\t\t\t\t// System.out.println(\"abort 4b\");\n                            return false; // REVISIT\n                        }\n                        if (currentOffset < endOffset) {\n                            ch = data.charAt(currentOffset);\n                        }\n                        else {\n                            ch = -1;\n                        }\n                        nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    }\n                    addToken(tokens, XPath.Tokens.EXPRTOKEN_VARIABLE_REFERENCE);\n                    starIsMultiplyOperator = true;\n                    tokens.addToken(prefixHandle);\n                    tokens.addToken(nameHandle);\n                    break;\n                //\n                // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                // [34] MultiplyOperator ::= '*'\n                //\n                case CHARTYPE_STAR:             // '*'\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then a * must be recognized as a MultiplyOperator.\n                    //\n                    // Otherwise, the token must not be recognized as a MultiplyOperator.\n                    //\n                    if (starIsMultiplyOperator) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MULT);\n                        starIsMultiplyOperator = false;\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_ANY);\n                        starIsMultiplyOperator = true;\n                    }\n                    if (++currentOffset == endOffset) {\n                        break;\n                    }\n                    break;\n                //\n                // NCName, QName and non-terminals\n                //\n                case CHARTYPE_NONASCII: // possibly a valid non-ascii 'Letter' (BaseChar | Ideographic)\n                case CHARTYPE_LETTER:\n                case CHARTYPE_UNDERSCORE:\n                    //\n                    // 3.7 Lexical Structure\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    // [33] OperatorName ::= 'and' | 'or' | 'mod' | 'div'\n                    // [38] NodeType ::= 'comment' | 'text' | 'processing-instruction' | 'node'\n                    // [35] FunctionName ::= QName - NodeType\n                    // [6] AxisName ::= (see above)\n                    //\n                    // [37] NameTest ::= '*' | NCName ':' '*' | QName\n                    // [5] NCName ::= (Letter | '_') (NCNameChar)*\n                    // [?] NCNameChar ::= Letter | Digit | '.' | '-' | '_'  (ascii subset of 'NCNameChar')\n                    // [?] QName ::= (NCName ':')? NCName\n                    // [?] Letter ::= [A-Za-z]                              (ascii subset of 'Letter')\n                    // [?] Digit ::= [0-9]                                  (ascii subset of 'Digit')\n                    //\n                    nameOffset = currentOffset;\n                    currentOffset = scanNCName(data, endOffset, currentOffset);\n                    if (currentOffset == nameOffset) {\n\t\t\t\t// System.out.println(\"abort 4c\");\n                        return false; // REVISIT\n                    }\n                    if (currentOffset < endOffset) {\n                        ch = data.charAt(currentOffset);\n                    }\n                    else {\n                        ch = -1;\n                    }\n                    nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                    boolean isNameTestNCName = false;\n                    boolean isAxisName = false;\n                    prefixHandle = null;\n                    if (ch == ':') {\n                        if (++currentOffset == endOffset) {\n\t\t\t\t// System.out.println(\"abort 5\");\n                            return false; // REVISIT\n                        }\n                        ch = data.charAt(currentOffset);\n                        if (ch == '*') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isNameTestNCName = true;\n                        } else if (ch == ':') {\n                            if (++currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            isAxisName = true;\n                        } else {\n                            prefixHandle = nameHandle;\n                            nameOffset = currentOffset;\n                            currentOffset = scanNCName(data, endOffset, currentOffset);\n                            if (currentOffset == nameOffset) {\n\t\t\t\t// System.out.println(\"abort 5b\");\n                                return false; // REVISIT\n                            }\n                            if (currentOffset < endOffset) {\n                                ch = data.charAt(currentOffset);\n                            }\n                            else {\n                                ch = -1;\n                            }\n                            nameHandle = symbolTable.addSymbol(data.substring(nameOffset, currentOffset));\n                        }\n                    }\n                    //\n                    // [39] ExprWhitespace ::= S\n                    //\n                    while (ch == ' ' || ch == 0x0A || ch == 0x09 || ch == 0x0D) {\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        ch = data.charAt(currentOffset);\n                    }\n                    //\n                    //  If there is a preceding token and the preceding token is not one of @, ::, (, [, , or\n                    //  an Operator, then an NCName must be recognized as an OperatorName.\n                    //\n                    if (starIsMultiplyOperator) {\n                        if (nameHandle == fAndSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_AND);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fOrSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_OR);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fModSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_MOD);\n                            starIsMultiplyOperator = false;\n                        } else if (nameHandle == fDivSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_OPERATOR_DIV);\n                            starIsMultiplyOperator = false;\n                        } else {\n\t\t\t\t// System.out.println(\"abort 6\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n\t\t\t\t// System.out.println(\"abort 7\");\n                            return false; // REVISIT - NCName:* where an OperatorName is required\n                        } else if (isAxisName) {\n\t\t\t\t// System.out.println(\"abort 8\");\n                            return false; // REVISIT - AxisName:: where an OperatorName is required\n                        }\n                        break;\n                    }\n                    //\n                    //  If the character following an NCName (possibly after intervening ExprWhitespace) is (,\n                    //  then the token must be recognized as a NodeType or a FunctionName.\n                    //\n                    if (ch == '(' && !isNameTestNCName && !isAxisName) {\n                        if (nameHandle == fCommentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_COMMENT);\n                        } else if (nameHandle == fTextSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_TEXT);\n                        } else if (nameHandle == fPISymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_PI);\n                        } else if (nameHandle == fNodeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_NODETYPE_NODE);\n                        } else {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_FUNCTION_NAME);\n                            tokens.addToken(prefixHandle);\n                            tokens.addToken(nameHandle);\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_OPEN_PAREN);\n                        starIsMultiplyOperator = false;\n                        if (++currentOffset == endOffset) {\n                            break;\n                        }\n                        break;\n                    }\n                    //\n                    //  If the two characters following an NCName (possibly after intervening ExprWhitespace)\n                    //  are ::, then the token must be recognized as an AxisName.\n                    //\n                    if (isAxisName ||\n                        (ch == ':' && currentOffset + 1 < endOffset &&\n                         data.charAt(currentOffset + 1) == ':')) {\n                        if (nameHandle == fAncestorSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR);\n                        } else if (nameHandle == fAncestorOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ANCESTOR_OR_SELF);\n                        } else if (nameHandle == fAttributeSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_ATTRIBUTE);\n                        } else if (nameHandle == fChildSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_CHILD);\n                        } else if (nameHandle == fDescendantSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT);\n                        } else if (nameHandle == fDescendantOrSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_DESCENDANT_OR_SELF);\n                        } else if (nameHandle == fFollowingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING);\n                        } else if (nameHandle == fFollowingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_FOLLOWING_SIBLING);\n                        } else if (nameHandle == fNamespaceSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_NAMESPACE);\n                        } else if (nameHandle == fParentSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PARENT);\n                        } else if (nameHandle == fPrecedingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING);\n                        } else if (nameHandle == fPrecedingSiblingSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_PRECEDING_SIBLING);\n                        } else if (nameHandle == fSelfSymbol) {\n                            addToken(tokens, XPath.Tokens.EXPRTOKEN_AXISNAME_SELF);\n                        } else {\n\t\t\t\t// System.out.println(\"abort 9\");\n                            return false; // REVISIT\n                        }\n                        if (isNameTestNCName) {\n\t\t\t\t// System.out.println(\"abort 10\");\n                            return false; // REVISIT - \"NCName:* ::\" where \"AxisName ::\" is required\n                        }\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_DOUBLE_COLON);\n                        starIsMultiplyOperator = false;\n                        if (!isAxisName) {\n                            currentOffset++;\n                            if (++currentOffset == endOffset) {\n                                break;\n                            }\n                        }\n                        break;\n                    }\n                    //\n                    //  Otherwise, the token must not be recognized as an OperatorName, a NodeType, a\n                    //  FunctionName, or an AxisName.\n                    //\n                    if (isNameTestNCName) {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_NAMESPACE);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(nameHandle);\n                    } else {\n                        addToken(tokens, XPath.Tokens.EXPRTOKEN_NAMETEST_QNAME);\n                        starIsMultiplyOperator = true;\n                        tokens.addToken(prefixHandle);\n                        tokens.addToken(nameHandle);\n                    }\n                    break;\n                }\n            }\n            if (XPath.Tokens.DUMP_TOKENS) {\n                tokens.dumpTokens();\n            }\n            return true;\n        }",
            "path": "src/org/apache/xerces/impl/v2/xpath/XPath.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "5909.json"
}