{
    "origin": "codeshovel",
    "repositoryName": "intellij-community",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/intellij-community/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "PyUnusedLocalInspectionVisitor.java",
    "functionName": "processScope",
    "functionId": "processScope___owner-ScopeOwner(modifiers-final)",
    "sourceFilePath": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
    "functionStartLine": 80,
    "functionEndLine": 88,
    "numCommitsSeen": 201,
    "timeTaken": 7881,
    "changeHistory": [
        "e7d84d56ea26dabe5fe01f5bab0b6b2cc0ce2989",
        "5dc3b9e06f55b77c184475066e9f370e834a88d0",
        "9e16448b3edd1b563822b6cfafe539ada686c4a9",
        "ce7b27e7b1af2802f8fb879f5417ceccd2b5e011",
        "5d39123a02ee63df360ec8bf92ba1c0d553ad5e8",
        "f3c9b3e9d2d0429670de3cdcda4d3ca1a68ff579",
        "d9b439c1abc02ec1c1dcbe48ece898f4e73ab1b9",
        "568e09499678477678a5b2e2bc9b29fcc0c2c742",
        "06a18955c9660779123d302793977f26e8499d0b",
        "91e5e2f4bd63fcbf2c13b4be505323ab6e8db7de",
        "6dcc627bbc236abc583eb35edd7b93766b5672bd",
        "5b198ecf93cccb3f3aaeacd213744f1e3d9ae73a",
        "480b87542c989ddec5387f78a05b61b6b12128c4",
        "1c23e9b8e39917b94342c31e46eb0e3051ac579b",
        "64478767b4bb01a9b7bd887be493a817b09c9ecb",
        "767247bd51810381c1a857768484e3701b7cb3ac",
        "b054fe76759a3853ae3eed043630d0be34193c39",
        "56b55d562f9c5efa28e6d6c7476e4845a16726b8",
        "4d69d8d6c743bfe1e96010b6a066d9e4db0d697c",
        "87833e170bc8beb952c03fb6fe73cb598b88140e",
        "df7f4a9096011a27f1776c595b1ff231044fb3a5",
        "edc44bf967774e0adbcf20b75648a76ed6cd20f1",
        "609acb7b2ebd26f1e9f6de40e2b29bcb7680adf7",
        "571ce7a4a2c692562ef481907adcfb2c1e18c5e5",
        "bc4b933f63158cb38416c2a5a5097bf6646d08ca",
        "6dcd2aad7d31104b18f078e66ef535b28803582e",
        "ce06c9384421e2306ca2ae2132b538bd74a6b3cb",
        "e73c48a0f3e4147cf22a12b65e7059972d952b3d",
        "6faab1b6202b57c47531911aaf3f8c822ede7f7e",
        "6d4fa6426992795053b95a1bebf228214619b3db",
        "b790ba56ca2db3ffdb771d97a3a00753beb32e93",
        "5aec7849089e04b9492593a603f7801f02652eaa",
        "ac5d278c1141d73a0abe078c80b9b913b68cd6c6",
        "97de8bede89b353b92aa8d2e325b096dae6c6507",
        "9993d8bc2691603cca2bb41956ee9be2d1b03029",
        "70b4ec80acdb19d668825679dff38a2bb4f26059",
        "fdd0fa41e203ba91f428f2999b32103ad015b704",
        "14c4f6dbba8288015292b73335c827ce072bb803",
        "489ac7c34139fd5c84eeb389f00013a5153963a0",
        "647ac0f602c33ea37ee054ac36bb79ec925c1019",
        "18a23da5b76e9c633c71fbb4fa10432437b614ca",
        "36870c1700c772e2edda08daee36027e43dc19af",
        "424c9ad66805cd45e24d52efa0cbd5e911061848"
    ],
    "changeHistoryShort": {
        "424c9ad66805cd45e24d52efa0cbd5e911061848": "Ybodychange",
        "36870c1700c772e2edda08daee36027e43dc19af": "Ybodychange",
        "18a23da5b76e9c633c71fbb4fa10432437b614ca": "Ybodychange",
        "647ac0f602c33ea37ee054ac36bb79ec925c1019": "Ybodychange",
        "489ac7c34139fd5c84eeb389f00013a5153963a0": "Ymultichange(Yparameterchange,Ybodychange)",
        "14c4f6dbba8288015292b73335c827ce072bb803": "Ybodychange",
        "fdd0fa41e203ba91f428f2999b32103ad015b704": "Ybodychange",
        "70b4ec80acdb19d668825679dff38a2bb4f26059": "Ybodychange",
        "9993d8bc2691603cca2bb41956ee9be2d1b03029": "Ybodychange",
        "97de8bede89b353b92aa8d2e325b096dae6c6507": "Ybodychange",
        "ac5d278c1141d73a0abe078c80b9b913b68cd6c6": "Ybodychange",
        "5aec7849089e04b9492593a603f7801f02652eaa": "Ybodychange",
        "b790ba56ca2db3ffdb771d97a3a00753beb32e93": "Ybodychange",
        "6d4fa6426992795053b95a1bebf228214619b3db": "Ybodychange",
        "6faab1b6202b57c47531911aaf3f8c822ede7f7e": "Ybodychange",
        "e73c48a0f3e4147cf22a12b65e7059972d952b3d": "Ybodychange",
        "ce06c9384421e2306ca2ae2132b538bd74a6b3cb": "Ybodychange",
        "6dcd2aad7d31104b18f078e66ef535b28803582e": "Ybodychange",
        "bc4b933f63158cb38416c2a5a5097bf6646d08ca": "Ybodychange",
        "571ce7a4a2c692562ef481907adcfb2c1e18c5e5": "Ybodychange",
        "609acb7b2ebd26f1e9f6de40e2b29bcb7680adf7": "Ybodychange",
        "edc44bf967774e0adbcf20b75648a76ed6cd20f1": "Ybodychange",
        "df7f4a9096011a27f1776c595b1ff231044fb3a5": "Ybodychange",
        "87833e170bc8beb952c03fb6fe73cb598b88140e": "Ymultichange(Yfilerename,Ybodychange)",
        "4d69d8d6c743bfe1e96010b6a066d9e4db0d697c": "Ybodychange",
        "56b55d562f9c5efa28e6d6c7476e4845a16726b8": "Ymultichange(Yparameterchange,Ybodychange)",
        "b054fe76759a3853ae3eed043630d0be34193c39": "Ybodychange",
        "767247bd51810381c1a857768484e3701b7cb3ac": "Ybodychange",
        "64478767b4bb01a9b7bd887be493a817b09c9ecb": "Ybodychange",
        "1c23e9b8e39917b94342c31e46eb0e3051ac579b": "Ybodychange",
        "480b87542c989ddec5387f78a05b61b6b12128c4": "Ybodychange",
        "5b198ecf93cccb3f3aaeacd213744f1e3d9ae73a": "Ybodychange",
        "6dcc627bbc236abc583eb35edd7b93766b5672bd": "Ybodychange",
        "91e5e2f4bd63fcbf2c13b4be505323ab6e8db7de": "Ybodychange",
        "06a18955c9660779123d302793977f26e8499d0b": "Ybodychange",
        "568e09499678477678a5b2e2bc9b29fcc0c2c742": "Ybodychange",
        "d9b439c1abc02ec1c1dcbe48ece898f4e73ab1b9": "Ybodychange",
        "f3c9b3e9d2d0429670de3cdcda4d3ca1a68ff579": "Ybodychange",
        "5d39123a02ee63df360ec8bf92ba1c0d553ad5e8": "Ymultichange(Ymovefromfile,Ybodychange)",
        "ce7b27e7b1af2802f8fb879f5417ceccd2b5e011": "Ybodychange",
        "9e16448b3edd1b563822b6cfafe539ada686c4a9": "Ybodychange",
        "5dc3b9e06f55b77c184475066e9f370e834a88d0": "Ybodychange",
        "e7d84d56ea26dabe5fe01f5bab0b6b2cc0ce2989": "Yintroduced"
    },
    "changeHistoryDetails": {
        "424c9ad66805cd45e24d52efa0cbd5e911061848": {
            "type": "Ybodychange",
            "commitMessage": "PY-20655 Fixed: Calling `locals()` within decorator causes \"Unused Local\" Warning for Decorator Parameters\n\nDon't collect writes for scopes containing locals().\nReads inside such scopes are analyzed.\n",
            "commitDate": "01/08/17 2:47 AM",
            "commitName": "424c9ad66805cd45e24d52efa0cbd5e911061848",
            "commitAuthor": "Semyon Proshev",
            "commitDateOld": "24/07/17 4:38 AM",
            "commitNameOld": "247e0aeeb188122d2be005eeda8f78607e475597",
            "commitAuthorOld": "Mikhail Golubev",
            "daysBetweenCommits": 7.92,
            "commitsBetweenForRepo": 374,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,9 +1,9 @@\n   private void processScope(final ScopeOwner owner) {\n-    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || callsLocals(owner)) {\n+    if (owner.getContainingFile() instanceof PyExpressionCodeFragment) {\n       return;\n     }\n-    if (!(owner instanceof PyClass)) {\n+    if (!(owner instanceof PyClass) && !callsLocals(owner)) {\n       collectAllWrites(owner);\n     }\n     collectUsedReads(owner);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment) {\n      return;\n    }\n    if (!(owner instanceof PyClass) && !callsLocals(owner)) {\n      collectAllWrites(owner);\n    }\n    collectUsedReads(owner);\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {}
        },
        "36870c1700c772e2edda08daee36027e43dc19af": {
            "type": "Ybodychange",
            "commitMessage": "Cleanup\n",
            "commitDate": "28/02/12 8:03 AM",
            "commitName": "36870c1700c772e2edda08daee36027e43dc19af",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "14/12/11 8:56 AM",
            "commitNameOld": "2d78fea31661695c81bba4c4446ec4ffa7f7885d",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 75.96,
            "commitsBetweenForRepo": 341,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,10 +1,9 @@\n   private void processScope(final ScopeOwner owner) {\n-    if ((owner.getContainingFile() instanceof PyExpressionCodeFragment) ||\n-        callsLocals(owner)) {\n+    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || callsLocals(owner)) {\n       return;\n     }\n     if (!(owner instanceof PyClass)) {\n       collectAllWrites(owner);\n     }\n     collectUsedReads(owner);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || callsLocals(owner)) {\n      return;\n    }\n    if (!(owner instanceof PyClass)) {\n      collectAllWrites(owner);\n    }\n    collectUsedReads(owner);\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "18a23da5b76e9c633c71fbb4fa10432437b614ca": {
            "type": "Ybodychange",
            "commitMessage": "added console filter for inspections\n",
            "commitDate": "25/11/11 6:50 AM",
            "commitName": "18a23da5b76e9c633c71fbb4fa10432437b614ca",
            "commitAuthor": "Ekaterina Tuzova",
            "commitDateOld": "25/11/11 4:46 AM",
            "commitNameOld": "647ac0f602c33ea37ee054ac36bb79ec925c1019",
            "commitAuthorOld": "Ekaterina Tuzova",
            "daysBetweenCommits": 0.09,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,10 +1,10 @@\n   private void processScope(final ScopeOwner owner) {\n-    if ((owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n+    if ((owner.getContainingFile() instanceof PyExpressionCodeFragment) ||\n         callsLocals(owner)) {\n       return;\n     }\n     if (!(owner instanceof PyClass)) {\n       collectAllWrites(owner);\n     }\n     collectUsedReads(owner);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if ((owner.getContainingFile() instanceof PyExpressionCodeFragment) ||\n        callsLocals(owner)) {\n      return;\n    }\n    if (!(owner instanceof PyClass)) {\n      collectAllWrites(owner);\n    }\n    collectUsedReads(owner);\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "6"
        },
        "647ac0f602c33ea37ee054ac36bb79ec925c1019": {
            "type": "Ybodychange",
            "commitMessage": "removed mako/cython dependent code from python inspections. Created extention point to filter out some python visitors for custom languages\n",
            "commitDate": "25/11/11 4:46 AM",
            "commitName": "647ac0f602c33ea37ee054ac36bb79ec925c1019",
            "commitAuthor": "Ekaterina Tuzova",
            "commitDateOld": "18/11/11 10:31 AM",
            "commitNameOld": "3019a471c5bef4dcfd7863c870d8ccf6b931d069",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 6.76,
            "commitsBetweenForRepo": 58,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,11 +1,10 @@\n   private void processScope(final ScopeOwner owner) {\n-    if (CythonLanguageDialect._isDisabledFor(owner) ||\n-        (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n+    if ((owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n         callsLocals(owner)) {\n       return;\n     }\n     if (!(owner instanceof PyClass)) {\n       collectAllWrites(owner);\n     }\n     collectUsedReads(owner);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if ((owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n        callsLocals(owner)) {\n      return;\n    }\n    if (!(owner instanceof PyClass)) {\n      collectAllWrites(owner);\n    }\n    collectUsedReads(owner);\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "24"
        },
        "489ac7c34139fd5c84eeb389f00013a5153963a0": {
            "type": "Ymultichange(Yparameterchange,Ybodychange)",
            "commitMessage": "Fixed false positive in unused locals for class factories (PY-4147)\n",
            "commitDate": "17/11/11 6:04 AM",
            "commitName": "489ac7c34139fd5c84eeb389f00013a5153963a0",
            "commitAuthor": "Andrey Vlasovskikh",
            "subchanges": [
                {
                    "type": "Yparameterchange",
                    "commitMessage": "Fixed false positive in unused locals for class factories (PY-4147)\n",
                    "commitDate": "17/11/11 6:04 AM",
                    "commitName": "489ac7c34139fd5c84eeb389f00013a5153963a0",
                    "commitAuthor": "Andrey Vlasovskikh",
                    "commitDateOld": "17/11/11 5:07 AM",
                    "commitNameOld": "14c4f6dbba8288015292b73335c827ce072bb803",
                    "commitAuthorOld": "Andrey Vlasovskikh",
                    "daysBetweenCommits": 0.04,
                    "commitsBetweenForRepo": 2,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,119 +1,11 @@\n-  private void processScope(final ScopeOwner owner, final PyElement node) {\n-    if (CythonLanguageDialect._isDisabledFor(node)) {\n+  private void processScope(final ScopeOwner owner) {\n+    if (CythonLanguageDialect._isDisabledFor(owner) ||\n+        (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n+        callsLocals(owner)) {\n       return;\n     }\n-\n-    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n-      return;\n+    if (!(owner instanceof PyClass)) {\n+      collectAllWrites(owner);\n     }\n-\n-    if (callsLocals(owner)) return;\n-\n-    // If method overrides others or is overridden, do not mark parameters as unused if they are\n-    final Scope scope = ControlFlowCache.getScope(owner);\n-    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n-    final Instruction[] instructions = flow.getInstructions();\n-\n-    // Iteration over write accesses\n-    for (Instruction instruction : instructions) {\n-      final PsiElement element = instruction.getElement();\n-      if (element instanceof PyFunction && owner instanceof PyFunction) {\n-        if (!myUsedElements.contains(element)) {\n-          myUnusedElements.add(element);\n-        }\n-      }\n-      else if (instruction instanceof ReadWriteInstruction) {\n-        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n-        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n-        if (!access.isWriteAccess()) {\n-          continue;\n-        }\n-        final String name = readWriteInstruction.getName();\n-        // Ignore empty, wildcards, global and nonlocal names\n-        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n-          continue;\n-        }\n-        // Ignore elements out of scope\n-        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n-          continue;\n-        }\n-        // Ignore arguments of import statement\n-        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n-          continue;\n-        }\n-        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n-          continue;\n-        }\n-        if (!myUsedElements.contains(element)) {\n-          myUnusedElements.add(element);\n-        }\n-      }\n-    }\n-\n-    // Iteration over read accesses\n-    for (int i = 0; i < instructions.length; i++) {\n-      final Instruction instruction = instructions[i];\n-      if (instruction instanceof ReadWriteInstruction) {\n-        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n-        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n-        if (!access.isReadAccess()) {\n-          continue;\n-        }\n-        final String name = readWriteInstruction.getName();\n-        if (name == null) {\n-          continue;\n-        }\n-        final PsiElement element = instruction.getElement();\n-        // Ignore elements out of scope\n-        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n-          continue;\n-        }\n-        final int startInstruction;\n-        if (access.isWriteAccess()) {\n-          final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n-          startInstruction = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n-        }\n-        else {\n-          startInstruction = i;\n-        }\n-        // Check if the element is declared out of scope, mark all out of scope write accesses as used\n-        if (element instanceof PyReferenceExpression) {\n-          final PyReferenceExpression ref = (PyReferenceExpression)element;\n-          final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, name);\n-          if (declOwner != null && declOwner != owner) {\n-            Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n-            for (PsiElement e : writeElements) {\n-              myUsedElements.add(e);\n-              myUnusedElements.remove(e);\n-            }\n-          }\n-        }\n-        ControlFlowUtil.iteratePrev(startInstruction, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n-          public ControlFlowUtil.Operation fun(final Instruction inst) {\n-            final PsiElement element = inst.getElement();\n-            // Mark function as used\n-            if (element instanceof PyFunction) {\n-              if (name.equals(((PyFunction)element).getName())){\n-                myUsedElements.add(element);\n-                myUnusedElements.remove(element);\n-                return ControlFlowUtil.Operation.CONTINUE;\n-              }\n-            }\n-            // Mark write access as used\n-            else if (inst instanceof ReadWriteInstruction) {\n-              final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n-              if (rwInstruction.getAccess().isWriteAccess() && name.equals(rwInstruction.getName())) {\n-                // For elements in scope\n-                if (element != null && PsiTreeUtil.isAncestor(node, element, false)) {\n-                  myUsedElements.add(element);\n-                  myUnusedElements.remove(element);\n-                }\n-                return ControlFlowUtil.Operation.CONTINUE;\n-              }\n-            }\n-            return ControlFlowUtil.Operation.NEXT;\n-          }\n-        });\n-      }\n-    }\n+    collectUsedReads(owner);\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (CythonLanguageDialect._isDisabledFor(owner) ||\n        (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n        callsLocals(owner)) {\n      return;\n    }\n    if (!(owner instanceof PyClass)) {\n      collectAllWrites(owner);\n    }\n    collectUsedReads(owner);\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
                    "extendedDetails": {
                        "oldValue": "[owner-ScopeOwner(modifiers-final), node-PyElement(modifiers-final)]",
                        "newValue": "[owner-ScopeOwner(modifiers-final)]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Fixed false positive in unused locals for class factories (PY-4147)\n",
                    "commitDate": "17/11/11 6:04 AM",
                    "commitName": "489ac7c34139fd5c84eeb389f00013a5153963a0",
                    "commitAuthor": "Andrey Vlasovskikh",
                    "commitDateOld": "17/11/11 5:07 AM",
                    "commitNameOld": "14c4f6dbba8288015292b73335c827ce072bb803",
                    "commitAuthorOld": "Andrey Vlasovskikh",
                    "daysBetweenCommits": 0.04,
                    "commitsBetweenForRepo": 2,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,119 +1,11 @@\n-  private void processScope(final ScopeOwner owner, final PyElement node) {\n-    if (CythonLanguageDialect._isDisabledFor(node)) {\n+  private void processScope(final ScopeOwner owner) {\n+    if (CythonLanguageDialect._isDisabledFor(owner) ||\n+        (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n+        callsLocals(owner)) {\n       return;\n     }\n-\n-    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n-      return;\n+    if (!(owner instanceof PyClass)) {\n+      collectAllWrites(owner);\n     }\n-\n-    if (callsLocals(owner)) return;\n-\n-    // If method overrides others or is overridden, do not mark parameters as unused if they are\n-    final Scope scope = ControlFlowCache.getScope(owner);\n-    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n-    final Instruction[] instructions = flow.getInstructions();\n-\n-    // Iteration over write accesses\n-    for (Instruction instruction : instructions) {\n-      final PsiElement element = instruction.getElement();\n-      if (element instanceof PyFunction && owner instanceof PyFunction) {\n-        if (!myUsedElements.contains(element)) {\n-          myUnusedElements.add(element);\n-        }\n-      }\n-      else if (instruction instanceof ReadWriteInstruction) {\n-        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n-        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n-        if (!access.isWriteAccess()) {\n-          continue;\n-        }\n-        final String name = readWriteInstruction.getName();\n-        // Ignore empty, wildcards, global and nonlocal names\n-        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n-          continue;\n-        }\n-        // Ignore elements out of scope\n-        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n-          continue;\n-        }\n-        // Ignore arguments of import statement\n-        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n-          continue;\n-        }\n-        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n-          continue;\n-        }\n-        if (!myUsedElements.contains(element)) {\n-          myUnusedElements.add(element);\n-        }\n-      }\n-    }\n-\n-    // Iteration over read accesses\n-    for (int i = 0; i < instructions.length; i++) {\n-      final Instruction instruction = instructions[i];\n-      if (instruction instanceof ReadWriteInstruction) {\n-        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n-        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n-        if (!access.isReadAccess()) {\n-          continue;\n-        }\n-        final String name = readWriteInstruction.getName();\n-        if (name == null) {\n-          continue;\n-        }\n-        final PsiElement element = instruction.getElement();\n-        // Ignore elements out of scope\n-        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n-          continue;\n-        }\n-        final int startInstruction;\n-        if (access.isWriteAccess()) {\n-          final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n-          startInstruction = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n-        }\n-        else {\n-          startInstruction = i;\n-        }\n-        // Check if the element is declared out of scope, mark all out of scope write accesses as used\n-        if (element instanceof PyReferenceExpression) {\n-          final PyReferenceExpression ref = (PyReferenceExpression)element;\n-          final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, name);\n-          if (declOwner != null && declOwner != owner) {\n-            Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n-            for (PsiElement e : writeElements) {\n-              myUsedElements.add(e);\n-              myUnusedElements.remove(e);\n-            }\n-          }\n-        }\n-        ControlFlowUtil.iteratePrev(startInstruction, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n-          public ControlFlowUtil.Operation fun(final Instruction inst) {\n-            final PsiElement element = inst.getElement();\n-            // Mark function as used\n-            if (element instanceof PyFunction) {\n-              if (name.equals(((PyFunction)element).getName())){\n-                myUsedElements.add(element);\n-                myUnusedElements.remove(element);\n-                return ControlFlowUtil.Operation.CONTINUE;\n-              }\n-            }\n-            // Mark write access as used\n-            else if (inst instanceof ReadWriteInstruction) {\n-              final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n-              if (rwInstruction.getAccess().isWriteAccess() && name.equals(rwInstruction.getName())) {\n-                // For elements in scope\n-                if (element != null && PsiTreeUtil.isAncestor(node, element, false)) {\n-                  myUsedElements.add(element);\n-                  myUnusedElements.remove(element);\n-                }\n-                return ControlFlowUtil.Operation.CONTINUE;\n-              }\n-            }\n-            return ControlFlowUtil.Operation.NEXT;\n-          }\n-        });\n-      }\n-    }\n+    collectUsedReads(owner);\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (CythonLanguageDialect._isDisabledFor(owner) ||\n        (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)) ||\n        callsLocals(owner)) {\n      return;\n    }\n    if (!(owner instanceof PyClass)) {\n      collectAllWrites(owner);\n    }\n    collectUsedReads(owner);\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "14c4f6dbba8288015292b73335c827ce072bb803": {
            "type": "Ybodychange",
            "commitMessage": "Python unused locals inspection cleanup\n",
            "commitDate": "17/11/11 5:07 AM",
            "commitName": "14c4f6dbba8288015292b73335c827ce072bb803",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "28/09/11 10:31 AM",
            "commitNameOld": "fdd0fa41e203ba91f428f2999b32103ad015b704",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 49.82,
            "commitsBetweenForRepo": 276,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,127 +1,119 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (CythonLanguageDialect._isDisabledFor(node)) {\n       return;\n     }\n \n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n-    for (final Instruction instruction : instructions) {\n+    for (Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n-        final String name = ((ReadWriteInstruction)instruction).getName();\n+        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n+        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n+        if (!access.isWriteAccess()) {\n+          continue;\n+        }\n+        final String name = readWriteInstruction.getName();\n         // Ignore empty, wildcards, global and nonlocal names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n-        // Ignore self references assignments\n-        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n-          continue;\n-        }\n-        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n-        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n-          if (!myUsedElements.contains(element)) {\n-            myUnusedElements.add(element);\n-          }\n+        if (!myUsedElements.contains(element)) {\n+          myUnusedElements.add(element);\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n-        final String name = ((ReadWriteInstruction)instruction).getName();\n+        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n+        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n+        if (!access.isReadAccess()) {\n+          continue;\n+        }\n+        final String name = readWriteInstruction.getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n-        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n+        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n-        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-        // Read or self assign access\n-        if (access.isReadAccess()) {\n-          int number = i;\n-          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n-            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n-            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n-          }\n-\n-          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n-          if (element instanceof PyReferenceExpression) {\n-            final PyReferenceExpression ref = (PyReferenceExpression)element;\n-            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n-            if (declOwner != null && declOwner != owner) {\n-              Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n-              for (PsiElement e : writeElements) {\n-                myUsedElements.add(e);\n-                myUnusedElements.remove(e);\n-              }\n+        final int startInstruction;\n+        if (access.isWriteAccess()) {\n+          final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n+          startInstruction = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n+        }\n+        else {\n+          startInstruction = i;\n+        }\n+        // Check if the element is declared out of scope, mark all out of scope write accesses as used\n+        if (element instanceof PyReferenceExpression) {\n+          final PyReferenceExpression ref = (PyReferenceExpression)element;\n+          final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, name);\n+          if (declOwner != null && declOwner != owner) {\n+            Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n+            for (PsiElement e : writeElements) {\n+              myUsedElements.add(e);\n+              myUnusedElements.remove(e);\n             }\n           }\n-\n-          ControlFlowUtil\n-            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n-              public ControlFlowUtil.Operation fun(final Instruction inst) {\n-                final PsiElement element = inst.getElement();\n-                // Mark function as used\n-                if (element instanceof PyFunction){\n-                  if (name.equals(((PyFunction)element).getName())){\n-                    myUsedElements.add(element);\n-                    myUnusedElements.remove(element);\n-                    return ControlFlowUtil.Operation.CONTINUE;\n-                  }\n-                }\n-                // Mark write access as used\n-                else if (inst instanceof ReadWriteInstruction) {\n-                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n-                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n-                    return ControlFlowUtil.Operation.NEXT;\n-                  }\n-                  // Ignore elements out of scope\n-                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n-                    return ControlFlowUtil.Operation.CONTINUE;\n-                  }\n-                  // Ignore self references assignments\n-                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n-                    return ControlFlowUtil.Operation.NEXT;\n-                  }\n+        }\n+        ControlFlowUtil.iteratePrev(startInstruction, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n+          public ControlFlowUtil.Operation fun(final Instruction inst) {\n+            final PsiElement element = inst.getElement();\n+            // Mark function as used\n+            if (element instanceof PyFunction) {\n+              if (name.equals(((PyFunction)element).getName())){\n+                myUsedElements.add(element);\n+                myUnusedElements.remove(element);\n+                return ControlFlowUtil.Operation.CONTINUE;\n+              }\n+            }\n+            // Mark write access as used\n+            else if (inst instanceof ReadWriteInstruction) {\n+              final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n+              if (rwInstruction.getAccess().isWriteAccess() && name.equals(rwInstruction.getName())) {\n+                // For elements in scope\n+                if (element != null && PsiTreeUtil.isAncestor(node, element, false)) {\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n-                  return ControlFlowUtil.Operation.CONTINUE;\n                 }\n-                return ControlFlowUtil.Operation.NEXT;\n+                return ControlFlowUtil.Operation.CONTINUE;\n               }\n-            });\n-        }\n+            }\n+            return ControlFlowUtil.Operation.NEXT;\n+          }\n+        });\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (CythonLanguageDialect._isDisabledFor(node)) {\n      return;\n    }\n\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n        if (!access.isWriteAccess()) {\n          continue;\n        }\n        final String name = readWriteInstruction.getName();\n        // Ignore empty, wildcards, global and nonlocal names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final ReadWriteInstruction readWriteInstruction = (ReadWriteInstruction)instruction;\n        final ReadWriteInstruction.ACCESS access = readWriteInstruction.getAccess();\n        if (!access.isReadAccess()) {\n          continue;\n        }\n        final String name = readWriteInstruction.getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        final int startInstruction;\n        if (access.isWriteAccess()) {\n          final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n          startInstruction = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n        }\n        else {\n          startInstruction = i;\n        }\n        // Check if the element is declared out of scope, mark all out of scope write accesses as used\n        if (element instanceof PyReferenceExpression) {\n          final PyReferenceExpression ref = (PyReferenceExpression)element;\n          final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, name);\n          if (declOwner != null && declOwner != owner) {\n            Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n            for (PsiElement e : writeElements) {\n              myUsedElements.add(e);\n              myUnusedElements.remove(e);\n            }\n          }\n        }\n        ControlFlowUtil.iteratePrev(startInstruction, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n          public ControlFlowUtil.Operation fun(final Instruction inst) {\n            final PsiElement element = inst.getElement();\n            // Mark function as used\n            if (element instanceof PyFunction) {\n              if (name.equals(((PyFunction)element).getName())){\n                myUsedElements.add(element);\n                myUnusedElements.remove(element);\n                return ControlFlowUtil.Operation.CONTINUE;\n              }\n            }\n            // Mark write access as used\n            else if (inst instanceof ReadWriteInstruction) {\n              final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n              if (rwInstruction.getAccess().isWriteAccess() && name.equals(rwInstruction.getName())) {\n                // For elements in scope\n                if (element != null && PsiTreeUtil.isAncestor(node, element, false)) {\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                }\n                return ControlFlowUtil.Operation.CONTINUE;\n              }\n            }\n            return ControlFlowUtil.Operation.NEXT;\n          }\n        });\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "fdd0fa41e203ba91f428f2999b32103ad015b704": {
            "type": "Ybodychange",
            "commitMessage": "Fixed wrong test condition in disabling inspections for Cython\n",
            "commitDate": "28/09/11 10:31 AM",
            "commitName": "fdd0fa41e203ba91f428f2999b32103ad015b704",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "28/09/11 7:56 AM",
            "commitNameOld": "70b4ec80acdb19d668825679dff38a2bb4f26059",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 0.11,
            "commitsBetweenForRepo": 4,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,127 +1,127 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n-    if (CythonLanguageDialect._isDisabledFor(node.getLanguage())) {\n+    if (CythonLanguageDialect._isDisabledFor(node)) {\n       return;\n     }\n \n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards, global and nonlocal names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n         if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n             final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n             if (declOwner != null && declOwner != owner) {\n               Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (CythonLanguageDialect._isDisabledFor(node)) {\n      return;\n    }\n\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards, global and nonlocal names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "70b4ec80acdb19d668825679dff38a2bb4f26059": {
            "type": "Ybodychange",
            "commitMessage": "Temporarily disbaled some inspections for Cython files\n",
            "commitDate": "28/09/11 7:56 AM",
            "commitName": "70b4ec80acdb19d668825679dff38a2bb4f26059",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "29/08/11 10:52 AM",
            "commitNameOld": "91fce0a99addf625b219fd604d33b5577d6cbe7f",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 29.88,
            "commitsBetweenForRepo": 154,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,123 +1,127 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n+    if (CythonLanguageDialect._isDisabledFor(node.getLanguage())) {\n+      return;\n+    }\n+\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards, global and nonlocal names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n         if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n             final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n             if (declOwner != null && declOwner != owner) {\n               Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (CythonLanguageDialect._isDisabledFor(node.getLanguage())) {\n      return;\n    }\n\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards, global and nonlocal names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "9993d8bc2691603cca2bb41956ee9be2d1b03029": {
            "type": "Ybodychange",
            "commitMessage": "Removed special handling of try-except in unused locals inspection because of new try-except-finally CFG (PY-4151, PY-4154, PY-4157)\n",
            "commitDate": "18/07/11 5:29 AM",
            "commitName": "9993d8bc2691603cca2bb41956ee9be2d1b03029",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "26/05/11 7:35 AM",
            "commitNameOld": "97de8bede89b353b92aa8d2e325b096dae6c6507",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 52.91,
            "commitsBetweenForRepo": 319,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,123 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards, global and nonlocal names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n         if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n             final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n             if (declOwner != null && declOwner != owner) {\n               Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n-                  // In case when assignment is inside try part\n-                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n-                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n-                    return ControlFlowUtil.Operation.NEXT;\n-                  }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards, global and nonlocal names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "97de8bede89b353b92aa8d2e325b096dae6c6507": {
            "type": "Ybodychange",
            "commitMessage": "Fixed false positive in unresolved references inspection for try-except ImportError (PY-3678)\n",
            "commitDate": "26/05/11 7:35 AM",
            "commitName": "97de8bede89b353b92aa8d2e325b096dae6c6507",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "19/05/11 9:47 AM",
            "commitNameOld": "ac5d278c1141d73a0abe078c80b9b913b68cd6c6",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 6.91,
            "commitsBetweenForRepo": 82,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards, global and nonlocal names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n         if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n             final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n             if (declOwner != null && declOwner != owner) {\n-              Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n+              Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards, global and nonlocal names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = ScopeUtil.getReadWriteElements(name, declOwner, false, true);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "ac5d278c1141d73a0abe078c80b9b913b68cd6c6": {
            "type": "Ybodychange",
            "commitMessage": "Correct resolving and searching for nonlocals, updated appropriate inspections (PY-3603)\n",
            "commitDate": "19/05/11 9:47 AM",
            "commitName": "ac5d278c1141d73a0abe078c80b9b913b68cd6c6",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "19/05/11 6:36 AM",
            "commitNameOld": "5aec7849089e04b9492593a603f7801f02652eaa",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 0.13,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n-        // Ignore empty, wildcards or global names\n-        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n+        // Ignore empty, wildcards, global and nonlocal names\n+        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n         if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n             final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n             if (declOwner != null && declOwner != owner) {\n               Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards, global and nonlocal names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name) || scope.isNonlocal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "8"
        },
        "5aec7849089e04b9492593a603f7801f02652eaa": {
            "type": "Ybodychange",
            "commitMessage": "Transitive resolve during references search only for globals (PY-3547)\n",
            "commitDate": "19/05/11 6:36 AM",
            "commitName": "5aec7849089e04b9492593a603f7801f02652eaa",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "16/05/11 7:47 AM",
            "commitNameOld": "d6ab1ad0b504a259429a0f37789c2b5e8d57bc39",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 2.95,
            "commitsBetweenForRepo": 31,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n         if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n-            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref);\n+            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n             if (declOwner != null && declOwner != owner) {\n               Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref, ref.getName());\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "b790ba56ca2db3ffdb771d97a3a00753beb32e93": {
            "type": "Ybodychange",
            "commitMessage": "Fixed false unused locals inside if statements with isinstance checks (PY-2418)\n",
            "commitDate": "27/04/11 7:05 AM",
            "commitName": "b790ba56ca2db3ffdb771d97a3a00753beb32e93",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "27/04/11 4:12 AM",
            "commitNameOld": "6d4fa6426992795053b95a1bebf228214619b3db",
            "commitAuthorOld": "Andrey Vlasovskikh",
            "daysBetweenCommits": 0.12,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n-        // Ingore self references assignments\n+        // Ignore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-        // WriteAccess\n-        if (access.isWriteAccess()) {\n+        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n+        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check if the element is declared out of scope, mark all out of scope write accesses as used\n           if (element instanceof PyReferenceExpression) {\n             final PyReferenceExpression ref = (PyReferenceExpression)element;\n             final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref);\n             if (declOwner != null && declOwner != owner) {\n               Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n               for (PsiElement e : writeElements) {\n                 myUsedElements.add(e);\n                 myUnusedElements.remove(e);\n               }\n             }\n           }\n \n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ignore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Write access excluding WRITETYPE, because it's element is a type reference, not a variable of this type\n        if (access == ReadWriteInstruction.ACCESS.WRITE || access == ReadWriteInstruction.ACCESS.READWRITE) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref);\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "6d4fa6426992795053b95a1bebf228214619b3db": {
            "type": "Ybodychange",
            "commitMessage": "Fixed bugs in unused local variables inspection for nested functions (PY-3076, PY-3118)\n",
            "commitDate": "27/04/11 4:12 AM",
            "commitName": "6d4fa6426992795053b95a1bebf228214619b3db",
            "commitAuthor": "Andrey Vlasovskikh",
            "commitDateOld": "04/03/11 7:25 AM",
            "commitNameOld": "6faab1b6202b57c47531911aaf3f8c822ede7f7e",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 53.82,
            "commitsBetweenForRepo": 295,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = ControlFlowCache.getScope(owner);\n     final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ingore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n-          // Check out of scope resolve elements, processes nested scopes\n-          if (element instanceof PyReferenceExpression){\n-            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n-              final PsiElement resolveElement = result.getElement();\n-              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n-              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n-                myUsedElements.add(element);\n-                myUsedElements.add(resolveElement);\n-                myUnusedElements.remove(element);\n-                myUnusedElements.remove(resolveElement);\n+          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n+          if (element instanceof PyReferenceExpression) {\n+            final PyReferenceExpression ref = (PyReferenceExpression)element;\n+            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref);\n+            if (declOwner != null && declOwner != owner) {\n+              Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n+              for (PsiElement e : writeElements) {\n+                myUsedElements.add(e);\n+                myUnusedElements.remove(e);\n               }\n             }\n           }\n+\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n-                  // Ingore self references assignments\n+                  // Ignore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ingore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check if the element is declared out of scope, mark all out of scope write accesses as used\n          if (element instanceof PyReferenceExpression) {\n            final PyReferenceExpression ref = (PyReferenceExpression)element;\n            final ScopeOwner declOwner = ScopeUtil.getDeclarationScopeOwner(ref);\n            if (declOwner != null && declOwner != owner) {\n              Collection<PsiElement> writeElements = getWriteElements(name, declOwner);\n              for (PsiElement e : writeElements) {\n                myUsedElements.add(e);\n                myUnusedElements.remove(e);\n              }\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ignore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "6faab1b6202b57c47531911aaf3f8c822ede7f7e": {
            "type": "Ybodychange",
            "commitMessage": "refactoring: remove duplicate code for caching control flow from each ScopeOwner implementation\n",
            "commitDate": "04/03/11 7:25 AM",
            "commitName": "6faab1b6202b57c47531911aaf3f8c822ede7f7e",
            "commitAuthor": "Dmitry Jemerov",
            "commitDateOld": "04/10/10 5:58 AM",
            "commitNameOld": "e73c48a0f3e4147cf22a12b65e7059972d952b3d",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 151.1,
            "commitsBetweenForRepo": 855,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,128 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n-    final Scope scope = owner.getScope();\n-    final ControlFlow flow = owner.getControlFlow();\n+    final Scope scope = ControlFlowCache.getScope(owner);\n+    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction) {\n         if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ingore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n           }\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ingore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = ControlFlowCache.getScope(owner);\n    final ControlFlow flow = ControlFlowCache.getControlFlow(owner);\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ingore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ingore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "13"
        },
        "e73c48a0f3e4147cf22a12b65e7059972d952b3d": {
            "type": "Ybodychange",
            "commitMessage": "cleanup\n",
            "commitDate": "04/10/10 5:58 AM",
            "commitName": "e73c48a0f3e4147cf22a12b65e7059972d952b3d",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "04/10/10 12:20 AM",
            "commitNameOld": "ce06c9384421e2306ca2ae2132b538bd74a6b3cb",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.23,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,129 +1,128 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n-    for (int i = 0; i < instructions.length; i++) {\n-      final Instruction instruction = instructions[i];\n+    for (final Instruction instruction : instructions) {\n       final PsiElement element = instruction.getElement();\n-      if (element instanceof PyFunction && owner instanceof PyFunction){\n-        if (!myUsedElements.contains(element)){\n+      if (element instanceof PyFunction && owner instanceof PyFunction) {\n+        if (!myUsedElements.contains(element)) {\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n-        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n+        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ingore self references assignments\n-        if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n+        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n-          if (!myUsedElements.contains(element)){\n+          if (!myUsedElements.contains(element)) {\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n           }\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ingore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (final Instruction instruction : instructions) {\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction) {\n        if (!myUsedElements.contains(element)) {\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ingore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)) {\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ingore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "ce06c9384421e2306ca2ae2132b538bd74a6b3cb": {
            "type": "Ybodychange",
            "commitMessage": "Fix problem with try/except assignments#2\n",
            "commitDate": "04/10/10 12:20 AM",
            "commitName": "ce06c9384421e2306ca2ae2132b538bd74a6b3cb",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "01/10/10 9:01 AM",
            "commitNameOld": "6dcd2aad7d31104b18f078e66ef535b28803582e",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 2.64,
            "commitsBetweenForRepo": 6,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,158 +1,129 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ingore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n           }\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ingore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n-                  if (tryPart != null) {\n-                    boolean assignedOnEachFlow = true;\n-                    final PyTryExceptStatement tryStatement = (PyTryExceptStatement)tryPart.getParent();\n-                    for (final PyExceptPart exceptPart : tryStatement.getExceptParts()) {\n-                      final Ref<Boolean> assignedOnThisFlow = new Ref<Boolean>(false);\n-                      ControlFlowUtil.process(instructions, inst.num(), new Processor<Instruction>() {\n-                        @Override\n-                        public boolean process(final Instruction instruction) {\n-                          if (assignedOnThisFlow.get() == Boolean.TRUE){\n-                            return false;\n-                          }\n-                          final PsiElement instElement = instruction.getElement();\n-                          if (instElement == null || !PsiTreeUtil.isAncestor(tryStatement, instElement, false)){\n-                            return false;\n-                          }\n-                          if (((ReadWriteInstruction)inst).getAccess().isWriteAccess() &&\n-                              name.equals(((ReadWriteInstruction)inst).getName()) &&\n-                              PsiTreeUtil.isAncestor(exceptPart, instElement, false)){\n-                            assignedOnThisFlow.set(true);\n-                            return false;\n-                          }\n-                          return true;\n-                        }\n-                      });\n-                      assignedOnEachFlow = assignedOnEachFlow && assignedOnThisFlow.get() == Boolean.TRUE;\n-                      if (!assignedOnEachFlow){\n-                        break;\n-                      }\n-                    }\n-                    if (assignedOnEachFlow) {\n-                      return ControlFlowUtil.Operation.CONTINUE;\n-                    }\n+                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n+                    return ControlFlowUtil.Operation.NEXT;\n                   }\n+                  return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ingore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ingore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && !isAssignedOnEachExceptFlow(inst, tryPart, instructions, name)) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "6dcd2aad7d31104b18f078e66ef535b28803582e": {
            "type": "Ybodychange",
            "commitMessage": "Fix problem with try/except assignments\n",
            "commitDate": "01/10/10 9:01 AM",
            "commitName": "6dcd2aad7d31104b18f078e66ef535b28803582e",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "01/10/10 4:27 AM",
            "commitNameOld": "bc4b933f63158cb38416c2a5a5097bf6646d08ca",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.19,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,129 +1,158 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         // Ingore self references assignments\n         if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n           }\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   // Ingore self references assignments\n                   if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n-                  // In case when assignment is inside try part and there are no except statements we should move further\n+                  // In case when assignment is inside try part\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n-                  if (tryPart != null && ((PyTryExceptStatement)tryPart.getParent()).getExceptParts().length == 0) {\n-                    return ControlFlowUtil.Operation.NEXT;\n+                  if (tryPart != null) {\n+                    boolean assignedOnEachFlow = true;\n+                    final PyTryExceptStatement tryStatement = (PyTryExceptStatement)tryPart.getParent();\n+                    for (final PyExceptPart exceptPart : tryStatement.getExceptParts()) {\n+                      final Ref<Boolean> assignedOnThisFlow = new Ref<Boolean>(false);\n+                      ControlFlowUtil.process(instructions, inst.num(), new Processor<Instruction>() {\n+                        @Override\n+                        public boolean process(final Instruction instruction) {\n+                          if (assignedOnThisFlow.get() == Boolean.TRUE){\n+                            return false;\n+                          }\n+                          final PsiElement instElement = instruction.getElement();\n+                          if (instElement == null || !PsiTreeUtil.isAncestor(tryStatement, instElement, false)){\n+                            return false;\n+                          }\n+                          if (((ReadWriteInstruction)inst).getAccess().isWriteAccess() &&\n+                              name.equals(((ReadWriteInstruction)inst).getName()) &&\n+                              PsiTreeUtil.isAncestor(exceptPart, instElement, false)){\n+                            assignedOnThisFlow.set(true);\n+                            return false;\n+                          }\n+                          return true;\n+                        }\n+                      });\n+                      assignedOnEachFlow = assignedOnEachFlow && assignedOnThisFlow.get() == Boolean.TRUE;\n+                      if (!assignedOnEachFlow){\n+                        break;\n+                      }\n+                    }\n+                    if (assignedOnEachFlow) {\n+                      return ControlFlowUtil.Operation.CONTINUE;\n+                    }\n                   }\n-                  return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ingore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ingore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null) {\n                    boolean assignedOnEachFlow = true;\n                    final PyTryExceptStatement tryStatement = (PyTryExceptStatement)tryPart.getParent();\n                    for (final PyExceptPart exceptPart : tryStatement.getExceptParts()) {\n                      final Ref<Boolean> assignedOnThisFlow = new Ref<Boolean>(false);\n                      ControlFlowUtil.process(instructions, inst.num(), new Processor<Instruction>() {\n                        @Override\n                        public boolean process(final Instruction instruction) {\n                          if (assignedOnThisFlow.get() == Boolean.TRUE){\n                            return false;\n                          }\n                          final PsiElement instElement = instruction.getElement();\n                          if (instElement == null || !PsiTreeUtil.isAncestor(tryStatement, instElement, false)){\n                            return false;\n                          }\n                          if (((ReadWriteInstruction)inst).getAccess().isWriteAccess() &&\n                              name.equals(((ReadWriteInstruction)inst).getName()) &&\n                              PsiTreeUtil.isAncestor(exceptPart, instElement, false)){\n                            assignedOnThisFlow.set(true);\n                            return false;\n                          }\n                          return true;\n                        }\n                      });\n                      assignedOnEachFlow = assignedOnEachFlow && assignedOnThisFlow.get() == Boolean.TRUE;\n                      if (!assignedOnEachFlow){\n                        break;\n                      }\n                    }\n                    if (assignedOnEachFlow) {\n                      return ControlFlowUtil.Operation.CONTINUE;\n                    }\n                  }\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "bc4b933f63158cb38416c2a5a5097bf6646d08ca": {
            "type": "Ybodychange",
            "commitMessage": "PY-1996 Local variable usage inspection misses some cases for *args parameter\n",
            "commitDate": "01/10/10 4:27 AM",
            "commitName": "bc4b933f63158cb38416c2a5a5097bf6646d08ca",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "21/09/10 10:46 AM",
            "commitNameOld": "bd309deb2065762878d6fe885a8dcb20cba0910b",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 9.74,
            "commitsBetweenForRepo": 44,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,121 +1,129 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n+        // Ingore self references assignments\n+        if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n+          continue;\n+        }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n           }\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n+                  // Ingore self references assignments\n+                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n+                    return ControlFlowUtil.Operation.NEXT;\n+                  }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part and there are no except statements we should move further\n                   final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                   if (tryPart != null && ((PyTryExceptStatement)tryPart.getParent()).getExceptParts().length == 0) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        // Ingore self references assignments\n        if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  // Ingore self references assignments\n                  if (element instanceof PyTargetExpression && element.getChildren().length != 0){\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part and there are no except statements we should move further\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && ((PyTryExceptStatement)tryPart.getParent()).getExceptParts().length == 0) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "571ce7a4a2c692562ef481907adcfb2c1e18c5e5": {
            "type": "Ybodychange",
            "commitMessage": "PY-1245 \"Unused local variable\" false positive and false negative with try/finally\n",
            "commitDate": "01/09/10 1:28 AM",
            "commitName": "571ce7a4a2c692562ef481907adcfb2c1e18c5e5",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "31/08/10 10:51 AM",
            "commitNameOld": "74097baed299038ac6c5e7330ed53e6895c62edb",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 0.61,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,120 +1,121 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n           }\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n-                  // In case when assignment is inside try part we should move further\n-                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n+                  // In case when assignment is inside try part and there are no except statements we should move further\n+                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n+                  if (tryPart != null && ((PyTryExceptStatement)tryPart.getParent()).getExceptParts().length == 0) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part and there are no except statements we should move further\n                  final PyTryPart tryPart = PsiTreeUtil.getParentOfType(element, PyTryPart.class);\n                  if (tryPart != null && ((PyTryExceptStatement)tryPart.getParent()).getExceptParts().length == 0) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "609acb7b2ebd26f1e9f6de40e2b29bcb7680adf7": {
            "type": "Ybodychange",
            "commitMessage": "PY-1553 False \"local variable is not used\"\n",
            "commitDate": "30/08/10 4:35 AM",
            "commitName": "609acb7b2ebd26f1e9f6de40e2b29bcb7680adf7",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "25/08/10 7:35 AM",
            "commitNameOld": "082af605e262d15dcf663a9af9430278c0f9d9df",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 4.87,
            "commitsBetweenForRepo": 56,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,125 +1,120 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n-            boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n+              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n-                outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n-            if (outOfScope){\n-              continue;\n-            }\n           }\n-\n           ControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n               public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part we should move further\n                   if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                     return ControlFlowUtil.Operation.NEXT;\n                   }\n                   return ControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              // in case when we resolve out of the scope we still can have imported statements with write accesses inside\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n          }\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part we should move further\n                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "edc44bf967774e0adbcf20b75648a76ed6cd20f1": {
            "type": "Ybodychange",
            "commitMessage": "refactoring\n",
            "commitDate": "28/07/10 7:00 AM",
            "commitName": "edc44bf967774e0adbcf20b75648a76ed6cd20f1",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "27/07/10 10:34 AM",
            "commitNameOld": "df7f4a9096011a27f1776c595b1ff231044fb3a5",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 0.85,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,125 +1,125 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n-          PyControlFlowUtil\n-            .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n-              public PyControlFlowUtil.Operation fun(final Instruction inst) {\n+          ControlFlowUtil\n+            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n+              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n-                    return PyControlFlowUtil.Operation.CONTINUE;\n+                    return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n-                    return PyControlFlowUtil.Operation.NEXT;\n+                    return ControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n-                    return PyControlFlowUtil.Operation.CONTINUE;\n+                    return ControlFlowUtil.Operation.CONTINUE;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part we should move further\n                   if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n-                    return PyControlFlowUtil.Operation.NEXT;\n+                    return ControlFlowUtil.Operation.NEXT;\n                   }\n-                  return PyControlFlowUtil.Operation.CONTINUE;\n+                  return ControlFlowUtil.Operation.CONTINUE;\n                 }\n-                return PyControlFlowUtil.Operation.NEXT;\n+                return ControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          ControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, ControlFlowUtil.Operation>() {\n              public ControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return ControlFlowUtil.Operation.CONTINUE;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part we should move further\n                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                    return ControlFlowUtil.Operation.NEXT;\n                  }\n                  return ControlFlowUtil.Operation.CONTINUE;\n                }\n                return ControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "df7f4a9096011a27f1776c595b1ff231044fb3a5": {
            "type": "Ybodychange",
            "commitMessage": "performance: check for super/subclasses only after we've found out that function actually has unused parameters\n",
            "commitDate": "27/07/10 10:34 AM",
            "commitName": "df7f4a9096011a27f1776c595b1ff231044fb3a5",
            "commitAuthor": "Dmitry Jemerov",
            "commitDateOld": "21/07/10 9:06 AM",
            "commitNameOld": "f3acc7c422294eafe35f690831a491582ceafe76",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 6.06,
            "commitsBetweenForRepo": 19,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,131 +1,125 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n-    boolean parametersCanBeUnused = true;\n-    if (owner instanceof PyFunction) {\n-      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n-                              PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n-    }\n-\n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       final PsiElement element = instruction.getElement();\n       if (element instanceof PyFunction && owner instanceof PyFunction){\n         if (!myUsedElements.contains(element)){\n           myUnusedElements.add(element);\n         }\n       }\n       else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n-        if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n+        if (access.isWriteAccess()) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final Instruction inst) {\n                 final PsiElement element = inst.getElement();\n                 // Mark function as used\n                 if (element instanceof PyFunction){\n                   if (name.equals(((PyFunction)element).getName())){\n                     myUsedElements.add(element);\n                     myUnusedElements.remove(element);\n                     return PyControlFlowUtil.Operation.CONTINUE;\n                   }\n                 }\n                 // Mark write access as used\n                 else if (inst instanceof ReadWriteInstruction) {\n                   final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                   if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                     return PyControlFlowUtil.Operation.NEXT;\n                   }\n                   // Ignore elements out of scope\n                   if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                     return PyControlFlowUtil.Operation.CONTINUE;\n                   }\n                   myUsedElements.add(element);\n                   myUnusedElements.remove(element);\n                   // In case when assignment is inside try part we should move further\n                   if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                     return PyControlFlowUtil.Operation.NEXT;\n                   }\n                   return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n                 return PyControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess()) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return PyControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part we should move further\n                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                    return PyControlFlowUtil.Operation.NEXT;\n                  }\n                  return PyControlFlowUtil.Operation.CONTINUE;\n                }\n                return PyControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "87833e170bc8beb952c03fb6fe73cb598b88140e": {
            "type": "Ymultichange(Yfilerename,Ybodychange)",
            "commitMessage": "PY-959 Inspection to detect unused inner lambdas/functions\n",
            "commitDate": "16/07/10 3:07 AM",
            "commitName": "87833e170bc8beb952c03fb6fe73cb598b88140e",
            "commitAuthor": "Oleg Shpynov",
            "subchanges": [
                {
                    "type": "Yfilerename",
                    "commitMessage": "PY-959 Inspection to detect unused inner lambdas/functions\n",
                    "commitDate": "16/07/10 3:07 AM",
                    "commitName": "87833e170bc8beb952c03fb6fe73cb598b88140e",
                    "commitAuthor": "Oleg Shpynov",
                    "commitDateOld": "16/07/10 1:29 AM",
                    "commitNameOld": "69a19144213d02a066a85ad556950870921bbc9f",
                    "commitAuthorOld": "Oleg Shpynov",
                    "daysBetweenCommits": 0.07,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,111 +1,131 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = true;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n                               PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n-      if (instruction instanceof ReadWriteInstruction) {\n+      final PsiElement element = instruction.getElement();\n+      if (element instanceof PyFunction && owner instanceof PyFunction){\n+        if (!myUsedElements.contains(element)){\n+          myUnusedElements.add(element);\n+        }\n+      }\n+      else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n-        final PsiElement element = instruction.getElement();\n-\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n-            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n-              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n-                final PsiElement instrElement = rwInstr.getElement();\n-                // Ignore elements out of scope\n-                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n+            .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n+              public PyControlFlowUtil.Operation fun(final Instruction inst) {\n+                final PsiElement element = inst.getElement();\n+                // Mark function as used\n+                if (element instanceof PyFunction){\n+                  if (name.equals(((PyFunction)element).getName())){\n+                    myUsedElements.add(element);\n+                    myUnusedElements.remove(element);\n+                    return PyControlFlowUtil.Operation.CONTINUE;\n+                  }\n+                }\n+                // Mark write access as used\n+                else if (inst instanceof ReadWriteInstruction) {\n+                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n+                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n+                    return PyControlFlowUtil.Operation.NEXT;\n+                  }\n+                  // Ignore elements out of scope\n+                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n+                    return PyControlFlowUtil.Operation.CONTINUE;\n+                  }\n+                  myUsedElements.add(element);\n+                  myUnusedElements.remove(element);\n+                  // In case when assignment is inside try part we should move further\n+                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n+                    return PyControlFlowUtil.Operation.NEXT;\n+                  }\n                   return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n-                myUsedElements.add(instrElement);\n-                myUnusedElements.remove(instrElement);\n-                // In case when assignment is inside try part we should move further\n-                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n-                  return PyControlFlowUtil.Operation.NEXT;\n-                }\n-                return PyControlFlowUtil.Operation.CONTINUE;\n+                return PyControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = true;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n                              PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return PyControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part we should move further\n                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                    return PyControlFlowUtil.Operation.NEXT;\n                  }\n                  return PyControlFlowUtil.Operation.CONTINUE;\n                }\n                return PyControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
                    "extendedDetails": {
                        "oldPath": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
                        "newPath": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "PY-959 Inspection to detect unused inner lambdas/functions\n",
                    "commitDate": "16/07/10 3:07 AM",
                    "commitName": "87833e170bc8beb952c03fb6fe73cb598b88140e",
                    "commitAuthor": "Oleg Shpynov",
                    "commitDateOld": "16/07/10 1:29 AM",
                    "commitNameOld": "69a19144213d02a066a85ad556950870921bbc9f",
                    "commitAuthorOld": "Oleg Shpynov",
                    "daysBetweenCommits": 0.07,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,111 +1,131 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n \n     if (callsLocals(owner)) return;\n \n     // If method overrides others or is overridden, do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = true;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n                               PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n-      if (instruction instanceof ReadWriteInstruction) {\n+      final PsiElement element = instruction.getElement();\n+      if (element instanceof PyFunction && owner instanceof PyFunction){\n+        if (!myUsedElements.contains(element)){\n+          myUnusedElements.add(element);\n+        }\n+      }\n+      else if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n-        final PsiElement element = instruction.getElement();\n-\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n-            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n-              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n-                final PsiElement instrElement = rwInstr.getElement();\n-                // Ignore elements out of scope\n-                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n+            .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n+              public PyControlFlowUtil.Operation fun(final Instruction inst) {\n+                final PsiElement element = inst.getElement();\n+                // Mark function as used\n+                if (element instanceof PyFunction){\n+                  if (name.equals(((PyFunction)element).getName())){\n+                    myUsedElements.add(element);\n+                    myUnusedElements.remove(element);\n+                    return PyControlFlowUtil.Operation.CONTINUE;\n+                  }\n+                }\n+                // Mark write access as used\n+                else if (inst instanceof ReadWriteInstruction) {\n+                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n+                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n+                    return PyControlFlowUtil.Operation.NEXT;\n+                  }\n+                  // Ignore elements out of scope\n+                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n+                    return PyControlFlowUtil.Operation.CONTINUE;\n+                  }\n+                  myUsedElements.add(element);\n+                  myUnusedElements.remove(element);\n+                  // In case when assignment is inside try part we should move further\n+                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n+                    return PyControlFlowUtil.Operation.NEXT;\n+                  }\n                   return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n-                myUsedElements.add(instrElement);\n-                myUnusedElements.remove(instrElement);\n-                // In case when assignment is inside try part we should move further\n-                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n-                  return PyControlFlowUtil.Operation.NEXT;\n-                }\n-                return PyControlFlowUtil.Operation.CONTINUE;\n+                return PyControlFlowUtil.Operation.NEXT;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = true;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n                              PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      final PsiElement element = instruction.getElement();\n      if (element instanceof PyFunction && owner instanceof PyFunction){\n        if (!myUsedElements.contains(element)){\n          myUnusedElements.add(element);\n        }\n      }\n      else if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iteratePrev(number, instructions, new Function<Instruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final Instruction inst) {\n                final PsiElement element = inst.getElement();\n                // Mark function as used\n                if (element instanceof PyFunction){\n                  if (name.equals(((PyFunction)element).getName())){\n                    myUsedElements.add(element);\n                    myUnusedElements.remove(element);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                  }\n                }\n                // Mark write access as used\n                else if (inst instanceof ReadWriteInstruction) {\n                  final ReadWriteInstruction rwInstruction = (ReadWriteInstruction)inst;\n                  if (!name.equals(rwInstruction.getName()) || !rwInstruction.getAccess().isWriteAccess()) {\n                    return PyControlFlowUtil.Operation.NEXT;\n                  }\n                  // Ignore elements out of scope\n                  if (element == null || !PsiTreeUtil.isAncestor(node, element, false)) {\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                  }\n                  myUsedElements.add(element);\n                  myUnusedElements.remove(element);\n                  // In case when assignment is inside try part we should move further\n                  if (PsiTreeUtil.getParentOfType(element, PyTryPart.class) != null) {\n                    return PyControlFlowUtil.Operation.NEXT;\n                  }\n                  return PyControlFlowUtil.Operation.CONTINUE;\n                }\n                return PyControlFlowUtil.Operation.NEXT;\n              }\n            });\n        }\n      }\n    }\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalInspectionVisitor.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "4d69d8d6c743bfe1e96010b6a066d9e4db0d697c": {
            "type": "Ybodychange",
            "commitMessage": "parameter is not unused if function has either super methods or inherited methods (PY-1234)\n",
            "commitDate": "12/07/10 11:44 AM",
            "commitName": "4d69d8d6c743bfe1e96010b6a066d9e4db0d697c",
            "commitAuthor": "Dmitry Jemerov",
            "commitDateOld": "09/07/10 5:07 AM",
            "commitNameOld": "56b55d562f9c5efa28e6d6c7476e4845a16726b8",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 3.28,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,127 +1,111 @@\n   private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n-    // Check for locals() call\n-    try {\n-      owner.acceptChildren(new PyRecursiveElementVisitor(){\n-        @Override\n-        public void visitPyCallExpression(final PyCallExpression node) {\n-          if (\"locals\".equals(node.getCallee().getText())){\n-            throw new DontPerformException();\n-          }\n-        }\n \n-        @Override\n-        public void visitPyFunction(final PyFunction node) {\n-          // stop here\n-        }\n-      });\n-    }\n-    catch (DontPerformException e) {\n-      return;\n-    }\n+    if (callsLocals(owner)) return;\n \n-    // If method overrides others do not mark parameters as unused if they are\n-    boolean parametersCanBeUnused = false;\n+    // If method overrides others or is overridden, do not mark parameters as unused if they are\n+    boolean parametersCanBeUnused = true;\n     if (owner instanceof PyFunction) {\n-      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n+      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n+                              PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n \n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n-        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n+        if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore elements out of scope\n         if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 // Ignore elements out of scope\n                 if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n                   return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 // In case when assignment is inside try part we should move further\n                 if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                   return PyControlFlowUtil.Operation.NEXT;\n                 }\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n\n    if (callsLocals(owner)) return;\n\n    // If method overrides others or is overridden, do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = true;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() == null &&\n                              PyOverridingMethodsSearch.search((PyFunction) owner, true).findFirst() == null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !isParameter(element))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                // Ignore elements out of scope\n                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n                  return PyControlFlowUtil.Operation.CONTINUE;\n                }\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                // In case when assignment is inside try part we should move further\n                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                  return PyControlFlowUtil.Operation.NEXT;\n                }\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "56b55d562f9c5efa28e6d6c7476e4845a16726b8": {
            "type": "Ymultichange(Yparameterchange,Ybodychange)",
            "commitMessage": "PY-1193 \"Unused parameter\" false negative with lambdas\n",
            "commitDate": "09/07/10 5:07 AM",
            "commitName": "56b55d562f9c5efa28e6d6c7476e4845a16726b8",
            "commitAuthor": "Oleg Shpynov",
            "subchanges": [
                {
                    "type": "Yparameterchange",
                    "commitMessage": "PY-1193 \"Unused parameter\" false negative with lambdas\n",
                    "commitDate": "09/07/10 5:07 AM",
                    "commitName": "56b55d562f9c5efa28e6d6c7476e4845a16726b8",
                    "commitAuthor": "Oleg Shpynov",
                    "commitDateOld": "08/07/10 8:09 AM",
                    "commitNameOld": "b054fe76759a3853ae3eed043630d0be34193c39",
                    "commitAuthorOld": "Oleg Shpynov",
                    "daysBetweenCommits": 0.87,
                    "commitsBetweenForRepo": 11,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,109 +1,127 @@\n-  private void processScope(final ScopeOwner owner) {\n+  private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n     // Check for locals() call\n     try {\n-      owner.accept(new PyRecursiveElementVisitor(){\n+      owner.acceptChildren(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n+\n+        @Override\n+        public void visitPyFunction(final PyFunction node) {\n+          // stop here\n+        }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n+\n+        // Ignore elements out of scope\n+        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n+          continue;\n+        }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n+        // Ignore elements out of scope\n+        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n+          continue;\n+        }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n+                // Ignore elements out of scope\n+                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n+                  return PyControlFlowUtil.Operation.CONTINUE;\n+                }\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 // In case when assignment is inside try part we should move further\n                 if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                   return PyControlFlowUtil.Operation.NEXT;\n                 }\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n    // Check for locals() call\n    try {\n      owner.acceptChildren(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n\n        @Override\n        public void visitPyFunction(final PyFunction node) {\n          // stop here\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                // Ignore elements out of scope\n                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n                  return PyControlFlowUtil.Operation.CONTINUE;\n                }\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                // In case when assignment is inside try part we should move further\n                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                  return PyControlFlowUtil.Operation.NEXT;\n                }\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
                    "extendedDetails": {
                        "oldValue": "[owner-ScopeOwner(modifiers-final)]",
                        "newValue": "[owner-ScopeOwner(modifiers-final), node-PyElement(modifiers-final)]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "PY-1193 \"Unused parameter\" false negative with lambdas\n",
                    "commitDate": "09/07/10 5:07 AM",
                    "commitName": "56b55d562f9c5efa28e6d6c7476e4845a16726b8",
                    "commitAuthor": "Oleg Shpynov",
                    "commitDateOld": "08/07/10 8:09 AM",
                    "commitNameOld": "b054fe76759a3853ae3eed043630d0be34193c39",
                    "commitAuthorOld": "Oleg Shpynov",
                    "daysBetweenCommits": 0.87,
                    "commitsBetweenForRepo": 11,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,109 +1,127 @@\n-  private void processScope(final ScopeOwner owner) {\n+  private void processScope(final ScopeOwner owner, final PyElement node) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n     // Check for locals() call\n     try {\n-      owner.accept(new PyRecursiveElementVisitor(){\n+      owner.acceptChildren(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n+\n+        @Override\n+        public void visitPyFunction(final PyFunction node) {\n+          // stop here\n+        }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n+\n+        // Ignore elements out of scope\n+        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n+          continue;\n+        }\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n+        // Ignore elements out of scope\n+        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n+          continue;\n+        }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n+                // Ignore elements out of scope\n+                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n+                  return PyControlFlowUtil.Operation.CONTINUE;\n+                }\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 // In case when assignment is inside try part we should move further\n                 if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                   return PyControlFlowUtil.Operation.NEXT;\n                 }\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner, final PyElement node) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n    // Check for locals() call\n    try {\n      owner.acceptChildren(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n\n        @Override\n        public void visitPyFunction(final PyFunction node) {\n          // stop here\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore elements out of scope\n        if (element == null || !PsiTreeUtil.isAncestor(node, element, false)){\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                // Ignore elements out of scope\n                if (instrElement == null || !PsiTreeUtil.isAncestor(node, instrElement, false)){\n                  return PyControlFlowUtil.Operation.CONTINUE;\n                }\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                // In case when assignment is inside try part we should move further\n                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                  return PyControlFlowUtil.Operation.NEXT;\n                }\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "b054fe76759a3853ae3eed043630d0be34193c39": {
            "type": "Ybodychange",
            "commitMessage": "PY-1192 \"Unused local variable\" false positive with try/finally\n",
            "commitDate": "08/07/10 8:09 AM",
            "commitName": "b054fe76759a3853ae3eed043630d0be34193c39",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "24/06/10 7:49 AM",
            "commitNameOld": "20dcf1f9b360866fea4accd3f47af652711a8adf",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 14.01,
            "commitsBetweenForRepo": 108,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,105 +1,109 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n     // Check for locals() call\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n+                // In case when assignment is inside try part we should move further\n+                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n+                  return PyControlFlowUtil.Operation.NEXT;\n+                }\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n    // Check for locals() call\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                // In case when assignment is inside try part we should move further\n                if (PsiTreeUtil.getParentOfType(instrElement, PyTryPart.class) != null){\n                  return PyControlFlowUtil.Operation.NEXT;\n                }\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "767247bd51810381c1a857768484e3701b7cb3ac": {
            "type": "Ybodychange",
            "commitMessage": "IAE\n",
            "commitDate": "24/06/10 7:49 AM",
            "commitName": "767247bd51810381c1a857768484e3701b7cb3ac",
            "commitAuthor": "Dmitry Jemerov",
            "commitDateOld": "25/05/10 1:51 AM",
            "commitNameOld": "cd7071d9b8f3d3be88893394cf931e1f1405cba4",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 30.25,
            "commitsBetweenForRepo": 80,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,105 +1,105 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n     // Check for locals() call\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n-              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n+              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n    // Check for locals() call\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (resolveElement != null && !PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "64478767b4bb01a9b7bd887be493a817b09c9ecb": {
            "type": "Ybodychange",
            "commitMessage": "Do not run inspections in console\n",
            "commitDate": "30/04/10 8:16 AM",
            "commitName": "64478767b4bb01a9b7bd887be493a817b09c9ecb",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "30/04/10 7:23 AM",
            "commitNameOld": "1c23e9b8e39917b94342c31e46eb0e3051ac579b",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.04,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,105 +1,105 @@\n   private void processScope(final ScopeOwner owner) {\n-    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n+    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n       return;\n     }\n     // Check for locals() call\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n         if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment || PydevConsoleRunner.isInPydevConsole(owner)){\n      return;\n    }\n    // Check for locals() call\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "1c23e9b8e39917b94342c31e46eb0e3051ac579b": {
            "type": "Ybodychange",
            "commitMessage": "cleanup\n",
            "commitDate": "30/04/10 7:23 AM",
            "commitName": "1c23e9b8e39917b94342c31e46eb0e3051ac579b",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "30/04/10 6:23 AM",
            "commitNameOld": "480b87542c989ddec5387f78a05b61b6b12128c4",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.04,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,113 +1,105 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n       return;\n     }\n-    final Set<String> globals = new HashSet<String>();\n-\n-    // Check for locals() call and collect globals information\n+    // Check for locals() call\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n-\n-        @Override\n-        public void visitPyGlobalStatement(final PyGlobalStatement node) {\n-          for (PyReferenceExpression expression : node.getGlobals()) {\n-            globals.add(expression.getName());\n-          }\n-        }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n+    final Scope scope = owner.getScope();\n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         // Ignore empty, wildcards or global names\n-        if (name == null || \"_\".equals(name) || globals.contains(name)) {\n+        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n      return;\n    }\n    // Check for locals() call\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final Scope scope = owner.getScope();\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || scope.isGlobal(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "480b87542c989ddec5387f78a05b61b6b12128c4": {
            "type": "Ybodychange",
            "commitMessage": "PY-849 Global variable recognized as local variable\n",
            "commitDate": "30/04/10 6:23 AM",
            "commitName": "480b87542c989ddec5387f78a05b61b6b12128c4",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "30/04/10 5:51 AM",
            "commitNameOld": "5b198ecf93cccb3f3aaeacd213744f1e3d9ae73a",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.02,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,104 +1,113 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n       return;\n     }\n-    // Do not perform inspection if locals() call is found\n+    final Set<String> globals = new HashSet<String>();\n+\n+    // Check for locals() call and collect globals information\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n+\n+        @Override\n+        public void visitPyGlobalStatement(final PyGlobalStatement node) {\n+          for (PyReferenceExpression expression : node.getGlobals()) {\n+            globals.add(expression.getName());\n+          }\n+        }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n-        // Ignore empty or wildcards names\n-        if (name == null || \"_\".equals(name)) {\n+        // Ignore empty, wildcards or global names\n+        if (name == null || \"_\".equals(name) || globals.contains(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n      return;\n    }\n    final Set<String> globals = new HashSet<String>();\n\n    // Check for locals() call and collect globals information\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n\n        @Override\n        public void visitPyGlobalStatement(final PyGlobalStatement node) {\n          for (PyReferenceExpression expression : node.getGlobals()) {\n            globals.add(expression.getName());\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty, wildcards or global names\n        if (name == null || \"_\".equals(name) || globals.contains(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "5b198ecf93cccb3f3aaeacd213744f1e3d9ae73a": {
            "type": "Ybodychange",
            "commitMessage": "PY-850 Unused variable for _\n",
            "commitDate": "30/04/10 5:51 AM",
            "commitName": "5b198ecf93cccb3f3aaeacd213744f1e3d9ae73a",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "28/04/10 9:53 AM",
            "commitNameOld": "6dcc627bbc236abc583eb35edd7b93766b5672bd",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 1.83,
            "commitsBetweenForRepo": 22,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,103 +1,104 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n       return;\n     }\n     // Do not perform inspection if locals() call is found\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n-        if (name == null) {\n+        // Ignore empty or wildcards names\n+        if (name == null || \"_\".equals(name)) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n      return;\n    }\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        // Ignore empty or wildcards names\n        if (name == null || \"_\".equals(name)) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "6dcc627bbc236abc583eb35edd7b93766b5672bd": {
            "type": "Ybodychange",
            "commitMessage": "don't highlight unused values in qualified expressions\n",
            "commitDate": "28/04/10 9:53 AM",
            "commitName": "6dcc627bbc236abc583eb35edd7b93766b5672bd",
            "commitAuthor": "Dmitry Jemerov",
            "commitDateOld": "21/04/10 8:05 AM",
            "commitNameOld": "838d6880bf2497c808de86d719f9389dbae3ab22",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 7.08,
            "commitsBetweenForRepo": 49,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,100 +1,103 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n       return;\n     }\n     // Do not perform inspection if locals() call is found\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n+        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n+          continue;\n+        }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           if (!myUsedElements.contains(element)){\n             myUnusedElements.add(element);\n           }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUsedElements.add(element);\n                 myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n      return;\n    }\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        if (element instanceof PyQualifiedExpression && ((PyQualifiedExpression)element).getQualifier() != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "91e5e2f4bd63fcbf2c13b4be505323ab6e8db7de": {
            "type": "Ybodychange",
            "commitMessage": "PY-861 \"Unused variable\" false positive in case of multiple nested functions\n",
            "commitDate": "21/04/10 7:46 AM",
            "commitName": "91e5e2f4bd63fcbf2c13b4be505323ab6e8db7de",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "21/04/10 5:44 AM",
            "commitNameOld": "bbd1616c6ff6e866b764d62f3eef99c3865e134b",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.08,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,95 +1,100 @@\n   private void processScope(final ScopeOwner owner) {\n     if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n       return;\n     }\n     // Do not perform inspection if locals() call is found\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n-          myUnusedElements.add(element);\n+          if (!myUsedElements.contains(element)){\n+            myUnusedElements.add(element);\n+          }\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n+                myUsedElements.add(element);\n+                myUsedElements.add(resolveElement);\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n+                myUsedElements.add(instrElement);\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n      return;\n    }\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          if (!myUsedElements.contains(element)){\n            myUnusedElements.add(element);\n          }\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUsedElements.add(element);\n                myUsedElements.add(resolveElement);\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUsedElements.add(instrElement);\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "06a18955c9660779123d302793977f26e8499d0b": {
            "type": "Ybodychange",
            "commitMessage": "Do not perform Unused lv inspection in case of expression code fragment\n",
            "commitDate": "02/04/10 6:35 AM",
            "commitName": "06a18955c9660779123d302793977f26e8499d0b",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "01/04/10 9:54 AM",
            "commitNameOld": "84ad12449355d1c110b8b2ac6e1ac64885ed54f0",
            "commitAuthorOld": "Dmitry Jemerov",
            "daysBetweenCommits": 0.86,
            "commitsBetweenForRepo": 12,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,94 +1,95 @@\n   private void processScope(final ScopeOwner owner) {\n-    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n-\n+    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n+      return;\n+    }\n     // Do not perform inspection if locals() call is found\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           myUnusedElements.add(element);\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    if (owner.getContainingFile() instanceof PyExpressionCodeFragment){\n      return;\n    }\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "568e09499678477678a5b2e2bc9b29fcc0c2c742": {
            "type": "Ybodychange",
            "commitMessage": "split PyReferenceExpressionImpl and PyReferenceImpl\n",
            "commitDate": "23/03/10 10:57 AM",
            "commitName": "568e09499678477678a5b2e2bc9b29fcc0c2c742",
            "commitAuthor": "Dmitry Jemerov",
            "commitDateOld": "04/03/10 6:26 AM",
            "commitNameOld": "d9b439c1abc02ec1c1dcbe48ece898f4e73ab1b9",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 19.15,
            "commitsBetweenForRepo": 139,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,94 +1,94 @@\n   private void processScope(final ScopeOwner owner) {\n     // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n     // Do not perform inspection if locals() call is found\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           myUnusedElements.add(element);\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n-            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n+            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).getReference().multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "39"
        },
        "d9b439c1abc02ec1c1dcbe48ece898f4e73ab1b9": {
            "type": "Ybodychange",
            "commitMessage": "PY-634\nUnused inspection false positive\n",
            "commitDate": "04/03/10 6:26 AM",
            "commitName": "d9b439c1abc02ec1c1dcbe48ece898f4e73ab1b9",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "03/03/10 2:22 AM",
            "commitNameOld": "f3c9b3e9d2d0429670de3cdcda4d3ca1a68ff579",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 1.17,
            "commitsBetweenForRepo": 20,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,93 +1,94 @@\n   private void processScope(final ScopeOwner owner) {\n     // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n     // Do not perform inspection if locals() call is found\n     try {\n       owner.accept(new PyRecursiveElementVisitor(){\n         @Override\n         public void visitPyCallExpression(final PyCallExpression node) {\n           if (\"locals\".equals(node.getCallee().getText())){\n             throw new DontPerformException();\n           }\n         }\n       });\n     }\n     catch (DontPerformException e) {\n       return;\n     }\n \n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           myUnusedElements.add(element);\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n+                myUnusedElements.remove(element);\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUnusedElements.remove(element);\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "f3c9b3e9d2d0429670de3cdcda4d3ca1a68ff579": {
            "type": "Ybodychange",
            "commitMessage": "PY-618\nVariables used only in a format string are marked as unused\n",
            "commitDate": "03/03/10 2:22 AM",
            "commitName": "f3c9b3e9d2d0429670de3cdcda4d3ca1a68ff579",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "26/02/10 8:15 AM",
            "commitNameOld": "291eae7da116e533aad877a942fe53ebdf728fd1",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 4.75,
            "commitsBetweenForRepo": 35,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,78 +1,93 @@\n   private void processScope(final ScopeOwner owner) {\n     // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n+    // Do not perform inspection if locals() call is found\n+    try {\n+      owner.accept(new PyRecursiveElementVisitor(){\n+        @Override\n+        public void visitPyCallExpression(final PyCallExpression node) {\n+          if (\"locals\".equals(node.getCallee().getText())){\n+            throw new DontPerformException();\n+          }\n+        }\n+      });\n+    }\n+    catch (DontPerformException e) {\n+      return;\n+    }\n+\n     // If method overrides others do not mark parameters as unused if they are\n     boolean parametersCanBeUnused = false;\n     if (owner instanceof PyFunction) {\n       parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n     }\n \n     final ControlFlow flow = owner.getControlFlow();\n     final Instruction[] instructions = flow.getInstructions();\n \n     // Iteration over write accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         // Ignore arguments of import statement\n         if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n           continue;\n         }\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // WriteAccess\n         if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n           myUnusedElements.add(element);\n         }\n       }\n     }\n \n     // Iteration over read accesses\n     for (int i = 0; i < instructions.length; i++) {\n       final Instruction instruction = instructions[i];\n       if (instruction instanceof ReadWriteInstruction) {\n         final String name = ((ReadWriteInstruction)instruction).getName();\n         if (name == null) {\n           continue;\n         }\n         final PsiElement element = instruction.getElement();\n         final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n         // Read or self assign access\n         if (access.isReadAccess()) {\n           int number = i;\n           if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n             final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n             number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n \n           // Check out of scope resolve elements, processes nested scopes\n           if (element instanceof PyReferenceExpression){\n             boolean outOfScope = false;\n             for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n               final PsiElement resolveElement = result.getElement();\n               if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                 outOfScope = true;\n                 myUnusedElements.remove(resolveElement);\n               }\n             }\n             if (outOfScope){\n               continue;\n             }\n           }\n \n           PyControlFlowUtil\n             .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n               public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                 final PsiElement instrElement = rwInstr.getElement();\n                 myUnusedElements.remove(instrElement);\n                 return PyControlFlowUtil.Operation.CONTINUE;\n               }\n             });\n         }\n       }\n     }\n   }\n\\ No newline at end of file\n",
            "actualSource": "  private void processScope(final ScopeOwner owner) {\n    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n    // Do not perform inspection if locals() call is found\n    try {\n      owner.accept(new PyRecursiveElementVisitor(){\n        @Override\n        public void visitPyCallExpression(final PyCallExpression node) {\n          if (\"locals\".equals(node.getCallee().getText())){\n            throw new DontPerformException();\n          }\n        }\n      });\n    }\n    catch (DontPerformException e) {\n      return;\n    }\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "5d39123a02ee63df360ec8bf92ba1c0d553ad5e8": {
            "type": "Ymultichange(Ymovefromfile,Ybodychange)",
            "commitMessage": "PY-559\nUnused assignment false positive in case of nested scopes\n",
            "commitDate": "24/02/10 1:42 AM",
            "commitName": "5d39123a02ee63df360ec8bf92ba1c0d553ad5e8",
            "commitAuthor": "Oleg Shpynov",
            "subchanges": [
                {
                    "type": "Ymovefromfile",
                    "commitMessage": "PY-559\nUnused assignment false positive in case of nested scopes\n",
                    "commitDate": "24/02/10 1:42 AM",
                    "commitName": "5d39123a02ee63df360ec8bf92ba1c0d553ad5e8",
                    "commitAuthor": "Oleg Shpynov",
                    "commitDateOld": "21/02/10 10:18 AM",
                    "commitNameOld": "aba68d9ac772a878fc6345219ec586e390e9f3fc",
                    "commitAuthorOld": "Dmitry Jemerov",
                    "daysBetweenCommits": 2.64,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,81 +1,78 @@\n-      private void processScope(final ScopeOwner owner) {\n-        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n+  private void processScope(final ScopeOwner owner) {\n+    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n-        // If method overrides others do not mark parameters as unused if they are\n-        boolean parametersCanBeUnused = false;\n-        if (owner instanceof PyFunction) {\n-          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n+    // If method overrides others do not mark parameters as unused if they are\n+    boolean parametersCanBeUnused = false;\n+    if (owner instanceof PyFunction) {\n+      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n+    }\n+\n+    final ControlFlow flow = owner.getControlFlow();\n+    final Instruction[] instructions = flow.getInstructions();\n+\n+    // Iteration over write accesses\n+    for (int i = 0; i < instructions.length; i++) {\n+      final Instruction instruction = instructions[i];\n+      if (instruction instanceof ReadWriteInstruction) {\n+        final String name = ((ReadWriteInstruction)instruction).getName();\n+        if (name == null) {\n+          continue;\n         }\n+        final PsiElement element = instruction.getElement();\n+        // Ignore arguments of import statement\n+        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n+          continue;\n+        }\n+        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n+        // WriteAccess\n+        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n+          myUnusedElements.add(element);\n+        }\n+      }\n+    }\n \n-        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n-\n-        final ControlFlow flow = owner.getControlFlow();\n-        final Instruction[] instructions = flow.getInstructions();\n-\n-        // Iteration over write accesses\n-        for (int i = 0; i < instructions.length; i++) {\n-          final Instruction instruction = instructions[i];\n-          if (instruction instanceof ReadWriteInstruction) {\n-            final String name = ((ReadWriteInstruction)instruction).getName();\n-            if (name == null){\n-              continue;\n-            }\n-            final PsiElement element = instruction.getElement();\n-            // Ignore arguments of import statement\n-            if (PyImportStatementNavigator.getImportStatementByElement(element) != null){\n-              continue;\n-            }\n-            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-            // WriteAccess\n-            if (access.isWriteAccess() &&\n-                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n-              addToUnused(unusedMap, name, element);\n-            }\n+    // Iteration over read accesses\n+    for (int i = 0; i < instructions.length; i++) {\n+      final Instruction instruction = instructions[i];\n+      if (instruction instanceof ReadWriteInstruction) {\n+        final String name = ((ReadWriteInstruction)instruction).getName();\n+        if (name == null) {\n+          continue;\n+        }\n+        final PsiElement element = instruction.getElement();\n+        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n+        // Read or self assign access\n+        if (access.isReadAccess()) {\n+          int number = i;\n+          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n+            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n+            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n-        }\n \n-        // Iteration over read accesses\n-        for (int i = 0; i < instructions.length; i++) {\n-          final Instruction instruction = instructions[i];\n-          if (instruction instanceof ReadWriteInstruction) {\n-            final String name = ((ReadWriteInstruction)instruction).getName();\n-            if (name == null){\n-              continue;\n-            }\n-            final PsiElement element = instruction.getElement();\n-            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-            // Read or self assign access\n-            if (access.isReadAccess()) {\n-              int number = i;\n-              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n-                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n-                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n+          // Check out of scope resolve elements, processes nested scopes\n+          if (element instanceof PyReferenceExpression){\n+            boolean outOfScope = false;\n+            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n+              final PsiElement resolveElement = result.getElement();\n+              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n+                outOfScope = true;\n+                myUnusedElements.remove(resolveElement);\n               }\n-\n-              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n-                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n-                  final PsiElement instrElement = rwInstr.getElement();\n-                    removeFromUnused(unusedMap, name, instrElement);\n-                    return PyControlFlowUtil.Operation.CONTINUE;\n-                }\n-              });\n             }\n-          }\n-        }\n-        // Register problems\n-        for (List<PsiElement> list : unusedMap.values()) {\n-          for (PsiElement element : list) {\n-            final String name = element.getText();\n-            // Ignore unused self parameters as obligatory\n-            if (PyPsiUtils.isMethodContext(element) && \"self\".equals(name)){\n+            if (outOfScope){\n               continue;\n             }\n-            if (element instanceof PyNamedParameter) {\n-              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n-            }\n-            else {\n-              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n-            }\n           }\n+\n+          PyControlFlowUtil\n+            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n+              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n+                final PsiElement instrElement = rwInstr.getElement();\n+                myUnusedElements.remove(instrElement);\n+                return PyControlFlowUtil.Operation.CONTINUE;\n+              }\n+            });\n         }\n-      }\n\\ No newline at end of file\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner) {\n    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
                    "extendedDetails": {
                        "oldPath": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspection.java",
                        "newPath": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
                        "oldMethodName": "processScope",
                        "newMethodName": "processScope"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "PY-559\nUnused assignment false positive in case of nested scopes\n",
                    "commitDate": "24/02/10 1:42 AM",
                    "commitName": "5d39123a02ee63df360ec8bf92ba1c0d553ad5e8",
                    "commitAuthor": "Oleg Shpynov",
                    "commitDateOld": "21/02/10 10:18 AM",
                    "commitNameOld": "aba68d9ac772a878fc6345219ec586e390e9f3fc",
                    "commitAuthorOld": "Dmitry Jemerov",
                    "daysBetweenCommits": 2.64,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,81 +1,78 @@\n-      private void processScope(final ScopeOwner owner) {\n-        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n+  private void processScope(final ScopeOwner owner) {\n+    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n-        // If method overrides others do not mark parameters as unused if they are\n-        boolean parametersCanBeUnused = false;\n-        if (owner instanceof PyFunction) {\n-          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n+    // If method overrides others do not mark parameters as unused if they are\n+    boolean parametersCanBeUnused = false;\n+    if (owner instanceof PyFunction) {\n+      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n+    }\n+\n+    final ControlFlow flow = owner.getControlFlow();\n+    final Instruction[] instructions = flow.getInstructions();\n+\n+    // Iteration over write accesses\n+    for (int i = 0; i < instructions.length; i++) {\n+      final Instruction instruction = instructions[i];\n+      if (instruction instanceof ReadWriteInstruction) {\n+        final String name = ((ReadWriteInstruction)instruction).getName();\n+        if (name == null) {\n+          continue;\n         }\n+        final PsiElement element = instruction.getElement();\n+        // Ignore arguments of import statement\n+        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n+          continue;\n+        }\n+        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n+        // WriteAccess\n+        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n+          myUnusedElements.add(element);\n+        }\n+      }\n+    }\n \n-        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n-\n-        final ControlFlow flow = owner.getControlFlow();\n-        final Instruction[] instructions = flow.getInstructions();\n-\n-        // Iteration over write accesses\n-        for (int i = 0; i < instructions.length; i++) {\n-          final Instruction instruction = instructions[i];\n-          if (instruction instanceof ReadWriteInstruction) {\n-            final String name = ((ReadWriteInstruction)instruction).getName();\n-            if (name == null){\n-              continue;\n-            }\n-            final PsiElement element = instruction.getElement();\n-            // Ignore arguments of import statement\n-            if (PyImportStatementNavigator.getImportStatementByElement(element) != null){\n-              continue;\n-            }\n-            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-            // WriteAccess\n-            if (access.isWriteAccess() &&\n-                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n-              addToUnused(unusedMap, name, element);\n-            }\n+    // Iteration over read accesses\n+    for (int i = 0; i < instructions.length; i++) {\n+      final Instruction instruction = instructions[i];\n+      if (instruction instanceof ReadWriteInstruction) {\n+        final String name = ((ReadWriteInstruction)instruction).getName();\n+        if (name == null) {\n+          continue;\n+        }\n+        final PsiElement element = instruction.getElement();\n+        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n+        // Read or self assign access\n+        if (access.isReadAccess()) {\n+          int number = i;\n+          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n+            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n+            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n           }\n-        }\n \n-        // Iteration over read accesses\n-        for (int i = 0; i < instructions.length; i++) {\n-          final Instruction instruction = instructions[i];\n-          if (instruction instanceof ReadWriteInstruction) {\n-            final String name = ((ReadWriteInstruction)instruction).getName();\n-            if (name == null){\n-              continue;\n-            }\n-            final PsiElement element = instruction.getElement();\n-            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n-            // Read or self assign access\n-            if (access.isReadAccess()) {\n-              int number = i;\n-              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n-                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n-                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n+          // Check out of scope resolve elements, processes nested scopes\n+          if (element instanceof PyReferenceExpression){\n+            boolean outOfScope = false;\n+            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n+              final PsiElement resolveElement = result.getElement();\n+              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n+                outOfScope = true;\n+                myUnusedElements.remove(resolveElement);\n               }\n-\n-              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n-                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n-                  final PsiElement instrElement = rwInstr.getElement();\n-                    removeFromUnused(unusedMap, name, instrElement);\n-                    return PyControlFlowUtil.Operation.CONTINUE;\n-                }\n-              });\n             }\n-          }\n-        }\n-        // Register problems\n-        for (List<PsiElement> list : unusedMap.values()) {\n-          for (PsiElement element : list) {\n-            final String name = element.getText();\n-            // Ignore unused self parameters as obligatory\n-            if (PyPsiUtils.isMethodContext(element) && \"self\".equals(name)){\n+            if (outOfScope){\n               continue;\n             }\n-            if (element instanceof PyNamedParameter) {\n-              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n-            }\n-            else {\n-              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n-            }\n           }\n+\n+          PyControlFlowUtil\n+            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n+              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n+                final PsiElement instrElement = rwInstr.getElement();\n+                myUnusedElements.remove(instrElement);\n+                return PyControlFlowUtil.Operation.CONTINUE;\n+              }\n+            });\n         }\n-      }\n\\ No newline at end of file\n+      }\n+    }\n+  }\n\\ No newline at end of file\n",
                    "actualSource": "  private void processScope(final ScopeOwner owner) {\n    // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n    // If method overrides others do not mark parameters as unused if they are\n    boolean parametersCanBeUnused = false;\n    if (owner instanceof PyFunction) {\n      parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n    }\n\n    final ControlFlow flow = owner.getControlFlow();\n    final Instruction[] instructions = flow.getInstructions();\n\n    // Iteration over write accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        // Ignore arguments of import statement\n        if (PyImportStatementNavigator.getImportStatementByElement(element) != null) {\n          continue;\n        }\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // WriteAccess\n        if (access.isWriteAccess() && (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n          myUnusedElements.add(element);\n        }\n      }\n    }\n\n    // Iteration over read accesses\n    for (int i = 0; i < instructions.length; i++) {\n      final Instruction instruction = instructions[i];\n      if (instruction instanceof ReadWriteInstruction) {\n        final String name = ((ReadWriteInstruction)instruction).getName();\n        if (name == null) {\n          continue;\n        }\n        final PsiElement element = instruction.getElement();\n        final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n        // Read or self assign access\n        if (access.isReadAccess()) {\n          int number = i;\n          if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n            final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n            number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n          }\n\n          // Check out of scope resolve elements, processes nested scopes\n          if (element instanceof PyReferenceExpression){\n            boolean outOfScope = false;\n            for (ResolveResult result : ((PyReferenceExpression)element).multiResolve(false)) {\n              final PsiElement resolveElement = result.getElement();\n              if (!PsiTreeUtil.isAncestor(owner, resolveElement, false)){\n                outOfScope = true;\n                myUnusedElements.remove(resolveElement);\n              }\n            }\n            if (outOfScope){\n              continue;\n            }\n          }\n\n          PyControlFlowUtil\n            .iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n              public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                final PsiElement instrElement = rwInstr.getElement();\n                myUnusedElements.remove(instrElement);\n                return PyControlFlowUtil.Operation.CONTINUE;\n              }\n            });\n        }\n      }\n    }\n  }",
                    "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspectionVisitor.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "ce7b27e7b1af2802f8fb879f5417ceccd2b5e011": {
            "type": "Ybodychange",
            "commitMessage": "PY-582\nUnused Assignment inspection must not highlight import statements\n",
            "commitDate": "19/02/10 6:38 AM",
            "commitName": "ce7b27e7b1af2802f8fb879f5417ceccd2b5e011",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "16/02/10 5:36 AM",
            "commitNameOld": "9e16448b3edd1b563822b6cfafe539ada686c4a9",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 3.04,
            "commitsBetweenForRepo": 18,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,77 +1,81 @@\n       private void processScope(final ScopeOwner owner) {\n         // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n         // If method overrides others do not mark parameters as unused if they are\n         boolean parametersCanBeUnused = false;\n         if (owner instanceof PyFunction) {\n           parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n         }\n \n         final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n \n         final ControlFlow flow = owner.getControlFlow();\n         final Instruction[] instructions = flow.getInstructions();\n \n         // Iteration over write accesses\n         for (int i = 0; i < instructions.length; i++) {\n           final Instruction instruction = instructions[i];\n           if (instruction instanceof ReadWriteInstruction) {\n             final String name = ((ReadWriteInstruction)instruction).getName();\n             if (name == null){\n               continue;\n             }\n             final PsiElement element = instruction.getElement();\n+            // Ignore arguments of import statement\n+            if (PyImportStatementNavigator.getImportStatementByElement(element) != null){\n+              continue;\n+            }\n             final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n             // WriteAccess\n             if (access.isWriteAccess() &&\n                 (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n               addToUnused(unusedMap, name, element);\n             }\n           }\n         }\n \n         // Iteration over read accesses\n         for (int i = 0; i < instructions.length; i++) {\n           final Instruction instruction = instructions[i];\n           if (instruction instanceof ReadWriteInstruction) {\n             final String name = ((ReadWriteInstruction)instruction).getName();\n             if (name == null){\n               continue;\n             }\n             final PsiElement element = instruction.getElement();\n             final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n             // Read or self assign access\n             if (access.isReadAccess()) {\n               int number = i;\n               if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                 final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                 number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n               }\n \n               PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                 public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                   final PsiElement instrElement = rwInstr.getElement();\n                     removeFromUnused(unusedMap, name, instrElement);\n                     return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n               });\n             }\n           }\n         }\n         // Register problems\n         for (List<PsiElement> list : unusedMap.values()) {\n           for (PsiElement element : list) {\n             final String name = element.getText();\n             // Ignore unused self parameters as obligatory\n             if (PyPsiUtils.isMethodContext(element) && \"self\".equals(name)){\n               continue;\n             }\n             if (element instanceof PyNamedParameter) {\n               registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n             }\n             else {\n               registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n             }\n           }\n         }\n       }\n\\ No newline at end of file\n",
            "actualSource": "      private void processScope(final ScopeOwner owner) {\n        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n        // If method overrides others do not mark parameters as unused if they are\n        boolean parametersCanBeUnused = false;\n        if (owner instanceof PyFunction) {\n          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n        }\n\n        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n\n        final ControlFlow flow = owner.getControlFlow();\n        final Instruction[] instructions = flow.getInstructions();\n\n        // Iteration over write accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            if (name == null){\n              continue;\n            }\n            final PsiElement element = instruction.getElement();\n            // Ignore arguments of import statement\n            if (PyImportStatementNavigator.getImportStatementByElement(element) != null){\n              continue;\n            }\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // WriteAccess\n            if (access.isWriteAccess() &&\n                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n              addToUnused(unusedMap, name, element);\n            }\n          }\n        }\n\n        // Iteration over read accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            if (name == null){\n              continue;\n            }\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // Read or self assign access\n            if (access.isReadAccess()) {\n              int number = i;\n              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n              }\n\n              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                  final PsiElement instrElement = rwInstr.getElement();\n                    removeFromUnused(unusedMap, name, instrElement);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                }\n              });\n            }\n          }\n        }\n        // Register problems\n        for (List<PsiElement> list : unusedMap.values()) {\n          for (PsiElement element : list) {\n            final String name = element.getText();\n            // Ignore unused self parameters as obligatory\n            if (PyPsiUtils.isMethodContext(element) && \"self\".equals(name)){\n              continue;\n            }\n            if (element instanceof PyNamedParameter) {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n            }\n            else {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n            }\n          }\n        }\n      }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspection.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "9e16448b3edd1b563822b6cfafe539ada686c4a9": {
            "type": "Ybodychange",
            "commitMessage": "PY-552\n'self' parameter should not be highlighted as unused\n",
            "commitDate": "16/02/10 5:36 AM",
            "commitName": "9e16448b3edd1b563822b6cfafe539ada686c4a9",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "12/02/10 3:06 AM",
            "commitNameOld": "5dc3b9e06f55b77c184475066e9f370e834a88d0",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 4.1,
            "commitsBetweenForRepo": 10,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,73 +1,77 @@\n       private void processScope(final ScopeOwner owner) {\n         // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n         // If method overrides others do not mark parameters as unused if they are\n         boolean parametersCanBeUnused = false;\n         if (owner instanceof PyFunction) {\n           parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n         }\n \n         final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n \n         final ControlFlow flow = owner.getControlFlow();\n         final Instruction[] instructions = flow.getInstructions();\n \n         // Iteration over write accesses\n         for (int i = 0; i < instructions.length; i++) {\n           final Instruction instruction = instructions[i];\n           if (instruction instanceof ReadWriteInstruction) {\n             final String name = ((ReadWriteInstruction)instruction).getName();\n             if (name == null){\n               continue;\n             }\n             final PsiElement element = instruction.getElement();\n             final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n             // WriteAccess\n             if (access.isWriteAccess() &&\n                 (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n               addToUnused(unusedMap, name, element);\n             }\n           }\n         }\n \n         // Iteration over read accesses\n         for (int i = 0; i < instructions.length; i++) {\n           final Instruction instruction = instructions[i];\n           if (instruction instanceof ReadWriteInstruction) {\n             final String name = ((ReadWriteInstruction)instruction).getName();\n             if (name == null){\n               continue;\n             }\n             final PsiElement element = instruction.getElement();\n             final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n             // Read or self assign access\n             if (access.isReadAccess()) {\n               int number = i;\n               if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                 final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                 number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n               }\n \n               PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                 public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                   final PsiElement instrElement = rwInstr.getElement();\n                     removeFromUnused(unusedMap, name, instrElement);\n                     return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n               });\n             }\n           }\n         }\n         // Register problems\n         for (List<PsiElement> list : unusedMap.values()) {\n           for (PsiElement element : list) {\n             final String name = element.getText();\n+            // Ignore unused self parameters as obligatory\n+            if (PyPsiUtils.isMethodContext(element) && \"self\".equals(name)){\n+              continue;\n+            }\n             if (element instanceof PyNamedParameter) {\n               registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n             }\n             else {\n               registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n             }\n           }\n         }\n       }\n\\ No newline at end of file\n",
            "actualSource": "      private void processScope(final ScopeOwner owner) {\n        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n        // If method overrides others do not mark parameters as unused if they are\n        boolean parametersCanBeUnused = false;\n        if (owner instanceof PyFunction) {\n          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n        }\n\n        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n\n        final ControlFlow flow = owner.getControlFlow();\n        final Instruction[] instructions = flow.getInstructions();\n\n        // Iteration over write accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            if (name == null){\n              continue;\n            }\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // WriteAccess\n            if (access.isWriteAccess() &&\n                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n              addToUnused(unusedMap, name, element);\n            }\n          }\n        }\n\n        // Iteration over read accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            if (name == null){\n              continue;\n            }\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // Read or self assign access\n            if (access.isReadAccess()) {\n              int number = i;\n              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n              }\n\n              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                  final PsiElement instrElement = rwInstr.getElement();\n                    removeFromUnused(unusedMap, name, instrElement);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                }\n              });\n            }\n          }\n        }\n        // Register problems\n        for (List<PsiElement> list : unusedMap.values()) {\n          for (PsiElement element : list) {\n            final String name = element.getText();\n            // Ignore unused self parameters as obligatory\n            if (PyPsiUtils.isMethodContext(element) && \"self\".equals(name)){\n              continue;\n            }\n            if (element instanceof PyNamedParameter) {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n            }\n            else {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n            }\n          }\n        }\n      }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspection.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "5dc3b9e06f55b77c184475066e9f370e834a88d0": {
            "type": "Ybodychange",
            "commitMessage": "NotNull assertion fix\n",
            "commitDate": "12/02/10 3:06 AM",
            "commitName": "5dc3b9e06f55b77c184475066e9f370e834a88d0",
            "commitAuthor": "Oleg Shpynov",
            "commitDateOld": "11/02/10 4:48 AM",
            "commitNameOld": "e7d84d56ea26dabe5fe01f5bab0b6b2cc0ce2989",
            "commitAuthorOld": "Oleg Shpynov",
            "daysBetweenCommits": 0.93,
            "commitsBetweenForRepo": 7,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,73 @@\n       private void processScope(final ScopeOwner owner) {\n         // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n \n         // If method overrides others do not mark parameters as unused if they are\n         boolean parametersCanBeUnused = false;\n         if (owner instanceof PyFunction) {\n           parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n         }\n \n         final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n \n         final ControlFlow flow = owner.getControlFlow();\n-        final Scope scope = owner.getScope();\n         final Instruction[] instructions = flow.getInstructions();\n \n         // Iteration over write accesses\n         for (int i = 0; i < instructions.length; i++) {\n           final Instruction instruction = instructions[i];\n           if (instruction instanceof ReadWriteInstruction) {\n             final String name = ((ReadWriteInstruction)instruction).getName();\n+            if (name == null){\n+              continue;\n+            }\n             final PsiElement element = instruction.getElement();\n             final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n             // WriteAccess\n             if (access.isWriteAccess() &&\n                 (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n               addToUnused(unusedMap, name, element);\n             }\n           }\n         }\n \n         // Iteration over read accesses\n         for (int i = 0; i < instructions.length; i++) {\n           final Instruction instruction = instructions[i];\n           if (instruction instanceof ReadWriteInstruction) {\n             final String name = ((ReadWriteInstruction)instruction).getName();\n+            if (name == null){\n+              continue;\n+            }\n             final PsiElement element = instruction.getElement();\n             final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n             // Read or self assign access\n             if (access.isReadAccess()) {\n               int number = i;\n               if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                 final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                 number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n               }\n \n               PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                 public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                   final PsiElement instrElement = rwInstr.getElement();\n                     removeFromUnused(unusedMap, name, instrElement);\n                     return PyControlFlowUtil.Operation.CONTINUE;\n                 }\n               });\n             }\n           }\n         }\n         // Register problems\n         for (List<PsiElement> list : unusedMap.values()) {\n           for (PsiElement element : list) {\n             final String name = element.getText();\n             if (element instanceof PyNamedParameter) {\n               registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n             }\n             else {\n               registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n             }\n           }\n         }\n       }\n\\ No newline at end of file\n",
            "actualSource": "      private void processScope(final ScopeOwner owner) {\n        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n        // If method overrides others do not mark parameters as unused if they are\n        boolean parametersCanBeUnused = false;\n        if (owner instanceof PyFunction) {\n          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n        }\n\n        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n\n        final ControlFlow flow = owner.getControlFlow();\n        final Instruction[] instructions = flow.getInstructions();\n\n        // Iteration over write accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            if (name == null){\n              continue;\n            }\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // WriteAccess\n            if (access.isWriteAccess() &&\n                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n              addToUnused(unusedMap, name, element);\n            }\n          }\n        }\n\n        // Iteration over read accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            if (name == null){\n              continue;\n            }\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // Read or self assign access\n            if (access.isReadAccess()) {\n              int number = i;\n              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n              }\n\n              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                  final PsiElement instrElement = rwInstr.getElement();\n                    removeFromUnused(unusedMap, name, instrElement);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                }\n              });\n            }\n          }\n        }\n        // Register problems\n        for (List<PsiElement> list : unusedMap.values()) {\n          for (PsiElement element : list) {\n            final String name = element.getText();\n            if (element instanceof PyNamedParameter) {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n            }\n            else {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n            }\n          }\n        }\n      }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspection.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "e7d84d56ea26dabe5fe01f5bab0b6b2cc0ce2989": {
            "type": "Yintroduced",
            "commitMessage": "please ignore\n",
            "commitDate": "11/02/10 4:48 AM",
            "commitName": "e7d84d56ea26dabe5fe01f5bab0b6b2cc0ce2989",
            "commitAuthor": "Oleg Shpynov",
            "diff": "@@ -0,0 +1,68 @@\n+      private void processScope(final ScopeOwner owner) {\n+        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n+\n+        // If method overrides others do not mark parameters as unused if they are\n+        boolean parametersCanBeUnused = false;\n+        if (owner instanceof PyFunction) {\n+          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n+        }\n+\n+        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n+\n+        final ControlFlow flow = owner.getControlFlow();\n+        final Scope scope = owner.getScope();\n+        final Instruction[] instructions = flow.getInstructions();\n+\n+        // Iteration over write accesses\n+        for (int i = 0; i < instructions.length; i++) {\n+          final Instruction instruction = instructions[i];\n+          if (instruction instanceof ReadWriteInstruction) {\n+            final String name = ((ReadWriteInstruction)instruction).getName();\n+            final PsiElement element = instruction.getElement();\n+            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n+            // WriteAccess\n+            if (access.isWriteAccess() &&\n+                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n+              addToUnused(unusedMap, name, element);\n+            }\n+          }\n+        }\n+\n+        // Iteration over read accesses\n+        for (int i = 0; i < instructions.length; i++) {\n+          final Instruction instruction = instructions[i];\n+          if (instruction instanceof ReadWriteInstruction) {\n+            final String name = ((ReadWriteInstruction)instruction).getName();\n+            final PsiElement element = instruction.getElement();\n+            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n+            // Read or self assign access\n+            if (access.isReadAccess()) {\n+              int number = i;\n+              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n+                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n+                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n+              }\n+\n+              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n+                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n+                  final PsiElement instrElement = rwInstr.getElement();\n+                    removeFromUnused(unusedMap, name, instrElement);\n+                    return PyControlFlowUtil.Operation.CONTINUE;\n+                }\n+              });\n+            }\n+          }\n+        }\n+        // Register problems\n+        for (List<PsiElement> list : unusedMap.values()) {\n+          for (PsiElement element : list) {\n+            final String name = element.getText();\n+            if (element instanceof PyNamedParameter) {\n+              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n+            }\n+            else {\n+              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n+            }\n+          }\n+        }\n+      }\n\\ No newline at end of file\n",
            "actualSource": "      private void processScope(final ScopeOwner owner) {\n        // TODO[oleg] Do not show warning in python code expression mode (evaluate in debug or watches)\n\n        // If method overrides others do not mark parameters as unused if they are\n        boolean parametersCanBeUnused = false;\n        if (owner instanceof PyFunction) {\n          parametersCanBeUnused = PySuperMethodsSearch.search(((PyFunction)owner)).findFirst() != null;\n        }\n\n        final HashMap<String, List<PsiElement>> unusedMap = new HashMap<String, List<PsiElement>>();\n\n        final ControlFlow flow = owner.getControlFlow();\n        final Scope scope = owner.getScope();\n        final Instruction[] instructions = flow.getInstructions();\n\n        // Iteration over write accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // WriteAccess\n            if (access.isWriteAccess() &&\n                (parametersCanBeUnused || !(element != null && element.getParent() instanceof PyNamedParameter))) {\n              addToUnused(unusedMap, name, element);\n            }\n          }\n        }\n\n        // Iteration over read accesses\n        for (int i = 0; i < instructions.length; i++) {\n          final Instruction instruction = instructions[i];\n          if (instruction instanceof ReadWriteInstruction) {\n            final String name = ((ReadWriteInstruction)instruction).getName();\n            final PsiElement element = instruction.getElement();\n            final ReadWriteInstruction.ACCESS access = ((ReadWriteInstruction)instruction).getAccess();\n            // Read or self assign access\n            if (access.isReadAccess()) {\n              int number = i;\n              if (access == ReadWriteInstruction.ACCESS.READWRITE) {\n                final PyAugAssignmentStatement augAssignmentStatement = PyAugAssignmentStatementNavigator.getStatementByTarget(element);\n                number = ControlFlowUtil.findInstructionNumberByElement(instructions, augAssignmentStatement);\n              }\n\n              PyControlFlowUtil.iterateWriteAccessFor(name, number, instructions, new Function<ReadWriteInstruction, PyControlFlowUtil.Operation>() {\n                public PyControlFlowUtil.Operation fun(final ReadWriteInstruction rwInstr) {\n                  final PsiElement instrElement = rwInstr.getElement();\n                    removeFromUnused(unusedMap, name, instrElement);\n                    return PyControlFlowUtil.Operation.CONTINUE;\n                }\n              });\n            }\n          }\n        }\n        // Register problems\n        for (List<PsiElement> list : unusedMap.values()) {\n          for (PsiElement element : list) {\n            final String name = element.getText();\n            if (element instanceof PyNamedParameter) {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.parameter.isnot.used\", name));\n            }\n            else {\n              registerWarning(element, PyBundle.message(\"INSP.unused.locals.local.variable.isnot.used\", name));\n            }\n          }\n        }\n      }",
            "path": "python/src/com/jetbrains/python/inspections/PyUnusedLocalVariableInspection.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "26793.json"
}