{
    "origin": "codeshovel",
    "repositoryName": "argouml",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/argouml/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "TransitionNotationUml.java",
    "functionName": "parseTransition",
    "functionId": "parseTransition___trans-Object__s-String",
    "sourceFilePath": "src/argouml-app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
    "functionStartLine": 124,
    "functionEndLine": 162,
    "numCommitsSeen": 298,
    "timeTaken": 12731,
    "changeHistory": [
        "df5ee4f7408c487bba53c340a9156ee6bd23dce6",
        "5ae659fcab22b8c248b3d089c39ac5f1e011861b",
        "56e6f745d5f53dfc71f668a0a78fe44624e1842a",
        "b098714ac13d5ccd052e98c32cce00e609442c2a",
        "2ddc06fc6af74e78f2bf2e63bfcd9a7122b433ac",
        "bc370f3eacf056714215537f54650c50114ff5b1",
        "fc2967aac59ed26d78323f4c27232dd1489fec77",
        "88726d321b2ef7e02695f5a887b1e8c4fbefb9fa",
        "362a7c39bbb6c8990d50fe8121f444d03a20942b",
        "6116c5944ed0c2388600c46619fbd82321081755",
        "1cf53f99717ae24f050f38d4e0eabbfd33ef38e8",
        "21546cc8946c6a86a94098c25d9d5fbf9b82698e",
        "4bb3b53cd9428bc0bdfec609c273867d3192d33f",
        "5bc0511b92af047aacf04c9c92a1ff6987ff3838",
        "66c46530ff4bedf0c57d40f59e43e509d7faf71b",
        "3cf3cf89b00ca66a682294aa97f19be0e26ddc17",
        "8cec53660cffeb36087c77ea34d47b17381188e2",
        "21a89ecdb5dedf02760621620e714c2447739202",
        "10c7c61ec067e094a29159187b19755d3daded21",
        "547f664cf54b2ff7a8d9cfa09d5fb6d2ef39e4d8",
        "ab51ea546e9bd19002ab573ad20edfa3e1a22cf1",
        "995df27655f04b06beb62c428c5a9e9796ac5c99",
        "1005b0bcebf2b43be8c7436f8e328cd7e3db77a3",
        "f0f03eebc4cfb6db7c7fc93d1dbf390d0e37ddcd",
        "276a0444269a3d1688df8aa45552cdcff1513be8",
        "994b0ce2014b076e74258d6c2e7ba3d7260260d2",
        "31b05426b08ce4ab797813fe32cee4095fbe1198",
        "10f720ae95053d75e83e5eac408e731094ec2257",
        "810f0276a2096afe79bdecf668efbca7d62e28ca",
        "6cbe80e2ddba3cecca7e049448257da9ca7ff6d1",
        "600eddaf9cea865390e4b08e9a0deceea554bde4",
        "e61a20cc90688442d303fcc842612cf4a5e3bc25",
        "638125db80440d37fc7b6a52626f814a191bb377",
        "b51bf4a859d77fa6df98bfec6d01538b49c5057a",
        "d8f7e6b7474b62d80734254cd46e81bd0892c4d1",
        "93c7bfe3a07158c55214325c0333b66aeb041b30",
        "0142dbe4b0accbee64c1c47d8bb703298b202b4d",
        "613571a564b734f5ed2e503fa74c1d760f99b1dc",
        "8fc5ed199e4e02b6e494849721fad07426ea29cf",
        "4f54dcde8c0a03ac8d3291c02ac2565f2083e61b",
        "4d0b0eba87adbbd2972649e03af67052c3b09f23",
        "9cddfc9e7cdb1a149f984fc54b8423ca61042790",
        "d680f0e0373bded5a26ec9b1ee0d40c34ed6c514",
        "2e232a18caf9ae9fa0059d85b9ee8fefe6a47293"
    ],
    "changeHistoryShort": {
        "2e232a18caf9ae9fa0059d85b9ee8fefe6a47293": "Ybodychange",
        "d680f0e0373bded5a26ec9b1ee0d40c34ed6c514": "Ybodychange",
        "9cddfc9e7cdb1a149f984fc54b8423ca61042790": "Ybodychange",
        "4d0b0eba87adbbd2972649e03af67052c3b09f23": "Yfilerename",
        "4f54dcde8c0a03ac8d3291c02ac2565f2083e61b": "Yfilerename",
        "8fc5ed199e4e02b6e494849721fad07426ea29cf": "Yfilerename",
        "613571a564b734f5ed2e503fa74c1d760f99b1dc": "Ybodychange",
        "0142dbe4b0accbee64c1c47d8bb703298b202b4d": "Ymultichange(Ymovefromfile,Ymodifierchange)",
        "93c7bfe3a07158c55214325c0333b66aeb041b30": "Ybodychange",
        "d8f7e6b7474b62d80734254cd46e81bd0892c4d1": "Ymultichange(Yexceptionschange,Ybodychange)",
        "b51bf4a859d77fa6df98bfec6d01538b49c5057a": "Ybodychange",
        "638125db80440d37fc7b6a52626f814a191bb377": "Ybodychange",
        "e61a20cc90688442d303fcc842612cf4a5e3bc25": "Ybodychange",
        "600eddaf9cea865390e4b08e9a0deceea554bde4": "Ybodychange",
        "6cbe80e2ddba3cecca7e049448257da9ca7ff6d1": "Ybodychange",
        "810f0276a2096afe79bdecf668efbca7d62e28ca": "Ybodychange",
        "10f720ae95053d75e83e5eac408e731094ec2257": "Ybodychange",
        "31b05426b08ce4ab797813fe32cee4095fbe1198": "Ybodychange",
        "994b0ce2014b076e74258d6c2e7ba3d7260260d2": "Ybodychange",
        "276a0444269a3d1688df8aa45552cdcff1513be8": "Ybodychange",
        "f0f03eebc4cfb6db7c7fc93d1dbf390d0e37ddcd": "Ybodychange",
        "1005b0bcebf2b43be8c7436f8e328cd7e3db77a3": "Ybodychange",
        "995df27655f04b06beb62c428c5a9e9796ac5c99": "Ybodychange",
        "ab51ea546e9bd19002ab573ad20edfa3e1a22cf1": "Ybodychange",
        "547f664cf54b2ff7a8d9cfa09d5fb6d2ef39e4d8": "Ybodychange",
        "10c7c61ec067e094a29159187b19755d3daded21": "Ybodychange",
        "21a89ecdb5dedf02760621620e714c2447739202": "Ybodychange",
        "8cec53660cffeb36087c77ea34d47b17381188e2": "Ybodychange",
        "3cf3cf89b00ca66a682294aa97f19be0e26ddc17": "Ybodychange",
        "66c46530ff4bedf0c57d40f59e43e509d7faf71b": "Ybodychange",
        "5bc0511b92af047aacf04c9c92a1ff6987ff3838": "Ybodychange",
        "4bb3b53cd9428bc0bdfec609c273867d3192d33f": "Ybodychange",
        "21546cc8946c6a86a94098c25d9d5fbf9b82698e": "Ybodychange",
        "1cf53f99717ae24f050f38d4e0eabbfd33ef38e8": "Ybodychange",
        "6116c5944ed0c2388600c46619fbd82321081755": "Ybodychange",
        "362a7c39bbb6c8990d50fe8121f444d03a20942b": "Ybodychange",
        "88726d321b2ef7e02695f5a887b1e8c4fbefb9fa": "Ybodychange",
        "fc2967aac59ed26d78323f4c27232dd1489fec77": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
        "bc370f3eacf056714215537f54650c50114ff5b1": "Ybodychange",
        "2ddc06fc6af74e78f2bf2e63bfcd9a7122b433ac": "Ybodychange",
        "b098714ac13d5ccd052e98c32cce00e609442c2a": "Ybodychange",
        "56e6f745d5f53dfc71f668a0a78fe44624e1842a": "Ybodychange",
        "5ae659fcab22b8c248b3d089c39ac5f1e011861b": "Ymultichange(Yparameterchange,Ybodychange)",
        "df5ee4f7408c487bba53c340a9156ee6bd23dce6": "Yintroduced"
    },
    "changeHistoryDetails": {
        "2e232a18caf9ae9fa0059d85b9ee8fefe6a47293": {
            "type": "Ybodychange",
            "commitMessage": "Cover all cases AND issue 5983.\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@18445 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "11/06/10 11:14 PM",
            "commitName": "2e232a18caf9ae9fa0059d85b9ee8fefe6a47293",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "11/06/10 2:28 PM",
            "commitNameOld": "d680f0e0373bded5a26ec9b1ee0d40c34ed6c514",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.37,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,39 +1,39 @@\n     protected Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n \n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n         if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n             String msg = \"parsing.error.transition.no-matching-square-brackets\";\n             throw new ParseException(Translator.localize(msg), 0);\n         }\n-        if ((c >= 0) && (c < b)) {\n+        if ((c >= 0) && (c < b) && (c > a) && (a > 0)) {\n             String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n             throw new ParseException(Translator.localize(msg), 0);\n         }\n \n         String[] s1 = s.trim().split(\"/\", 2);\n         String eg = s1[0].trim();\n         String[] s2 = eg.split(\"\\\\[\", 2);\n         \n-        if (s1.length > 1)  {\n-            if (s1[1].trim().length() > 0) {\n-                parseEffect(trans, s1[1].trim()); \n-            }\n-        }\n         if (s2[0].trim().length() > 0) {\n             parseTrigger(trans, s2[0].trim());\n         }\n         if (s2.length > 1)  {\n             if (s2[1].trim().endsWith(\"]\")) {\n                 String g = s2[1].trim();\n                 g = g.substring(0, g.length() - 1).trim();\n                 if (g.length() > 0) {\n                     parseGuard(trans, g);\n                 }\n             }\n         }\n+        if (s1.length > 1)  {\n+            if (s1[1].trim().length() > 0) {\n+                parseEffect(trans, s1[1].trim()); \n+            }\n+        }\n         return trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), 0);\n        }\n        if ((c >= 0) && (c < b) && (c > a) && (a > 0)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), 0);\n        }\n\n        String[] s1 = s.trim().split(\"/\", 2);\n        String eg = s1[0].trim();\n        String[] s2 = eg.split(\"\\\\[\", 2);\n        \n        if (s2[0].trim().length() > 0) {\n            parseTrigger(trans, s2[0].trim());\n        }\n        if (s2.length > 1)  {\n            if (s2[1].trim().endsWith(\"]\")) {\n                String g = s2[1].trim();\n                g = g.substring(0, g.length() - 1).trim();\n                if (g.length() > 0) {\n                    parseGuard(trans, g);\n                }\n            }\n        }\n        if (s1.length > 1)  {\n            if (s1[1].trim().length() > 0) {\n                parseEffect(trans, s1[1].trim()); \n            }\n        }\n        return trans;\n    }",
            "path": "src/argouml-app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
            "extendedDetails": {}
        },
        "d680f0e0373bded5a26ec9b1ee0d40c34ed6c514": {
            "type": "Ybodychange",
            "commitMessage": "Correction on fix for issue 5983: Problem with directly typed in event[guard]/action when action has [].\nNow the unit tests work, except one - to be further investigated.\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@18444 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "11/06/10 2:28 PM",
            "commitName": "d680f0e0373bded5a26ec9b1ee0d40c34ed6c514",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "11/06/10 12:16 PM",
            "commitNameOld": "9cddfc9e7cdb1a149f984fc54b8423ca61042790",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.09,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,35 +1,39 @@\n     protected Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n \n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n         if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n             String msg = \"parsing.error.transition.no-matching-square-brackets\";\n             throw new ParseException(Translator.localize(msg), 0);\n         }\n         if ((c >= 0) && (c < b)) {\n             String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n             throw new ParseException(Translator.localize(msg), 0);\n         }\n \n         String[] s1 = s.trim().split(\"/\", 2);\n         String eg = s1[0].trim();\n         String[] s2 = eg.split(\"\\\\[\", 2);\n         \n-        if (s1[1].trim().length() > 0) {\n-            parseEffect(trans, s1[1].trim()); \n+        if (s1.length > 1)  {\n+            if (s1[1].trim().length() > 0) {\n+                parseEffect(trans, s1[1].trim()); \n+            }\n         }\n         if (s2[0].trim().length() > 0) {\n             parseTrigger(trans, s2[0].trim());\n         }\n-        if (s2[1].trim().endsWith(\"]\")) {\n-            String g = s2[1].trim();\n-            g = g.substring(0, g.length() - 1).trim();\n-            if (g.length() > 0) {\n-                parseGuard(trans, g);\n+        if (s2.length > 1)  {\n+            if (s2[1].trim().endsWith(\"]\")) {\n+                String g = s2[1].trim();\n+                g = g.substring(0, g.length() - 1).trim();\n+                if (g.length() > 0) {\n+                    parseGuard(trans, g);\n+                }\n             }\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), 0);\n        }\n        if ((c >= 0) && (c < b)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), 0);\n        }\n\n        String[] s1 = s.trim().split(\"/\", 2);\n        String eg = s1[0].trim();\n        String[] s2 = eg.split(\"\\\\[\", 2);\n        \n        if (s1.length > 1)  {\n            if (s1[1].trim().length() > 0) {\n                parseEffect(trans, s1[1].trim()); \n            }\n        }\n        if (s2[0].trim().length() > 0) {\n            parseTrigger(trans, s2[0].trim());\n        }\n        if (s2.length > 1)  {\n            if (s2[1].trim().endsWith(\"]\")) {\n                String g = s2[1].trim();\n                g = g.substring(0, g.length() - 1).trim();\n                if (g.length() > 0) {\n                    parseGuard(trans, g);\n                }\n            }\n        }\n        return trans;\n    }",
            "path": "src/argouml-app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
            "extendedDetails": {}
        },
        "9cddfc9e7cdb1a149f984fc54b8423ca61042790": {
            "type": "Ybodychange",
            "commitMessage": "Fix issue 5983: Problem with directly typed in event[guard]/action when action has [].\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@18443 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "11/06/10 12:16 PM",
            "commitName": "9cddfc9e7cdb1a149f984fc54b8423ca61042790",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "12/01/10 10:55 AM",
            "commitNameOld": "fa8230e7225c128c35e51044981d66c9e5abd009",
            "commitAuthorOld": "Linus Tolke",
            "daysBetweenCommits": 150.01,
            "commitsBetweenForRepo": 505,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,52 +1,35 @@\n     protected Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n \n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n         if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n             String msg = \"parsing.error.transition.no-matching-square-brackets\";\n-            throw new ParseException(Translator.localize(msg),\n-                    0);\n+            throw new ParseException(Translator.localize(msg), 0);\n         }\n         if ((c >= 0) && (c < b)) {\n             String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n-            throw new ParseException(Translator.localize(msg),\n-                    0);\n+            throw new ParseException(Translator.localize(msg), 0);\n         }\n \n-        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n-        String eventSignature = null;\n-        String guardCondition = null;\n-        String actionExpression = null;\n-        while (tokenizer.hasMoreTokens()) {\n-            String nextToken = tokenizer.nextToken().trim();\n-            if (nextToken.endsWith(\"]\")) {\n-                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n-            } else {\n-                if (s.startsWith(nextToken)) {\n-                    eventSignature = nextToken;\n-                } else {\n-                    if (s.endsWith(nextToken)) {\n-                        actionExpression = nextToken;\n-                    }\n-                }\n+        String[] s1 = s.trim().split(\"/\", 2);\n+        String eg = s1[0].trim();\n+        String[] s2 = eg.split(\"\\\\[\", 2);\n+        \n+        if (s1[1].trim().length() > 0) {\n+            parseEffect(trans, s1[1].trim()); \n+        }\n+        if (s2[0].trim().length() > 0) {\n+            parseTrigger(trans, s2[0].trim());\n+        }\n+        if (s2[1].trim().endsWith(\"]\")) {\n+            String g = s2[1].trim();\n+            g = g.substring(0, g.length() - 1).trim();\n+            if (g.length() > 0) {\n+                parseGuard(trans, g);\n             }\n         }\n-\n-        if (eventSignature != null) {\n-            // parseEventSignature(trans, eventSignature);\n-            parseTrigger(trans, eventSignature);\n-        }\n-\n-        if (guardCondition != null) {\n-            parseGuard(trans,\n-                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n-        }\n-\n-        if (actionExpression != null) {\n-            parseEffect(trans, actionExpression.trim());\n-        }\n         return trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), 0);\n        }\n        if ((c >= 0) && (c < b)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), 0);\n        }\n\n        String[] s1 = s.trim().split(\"/\", 2);\n        String eg = s1[0].trim();\n        String[] s2 = eg.split(\"\\\\[\", 2);\n        \n        if (s1[1].trim().length() > 0) {\n            parseEffect(trans, s1[1].trim()); \n        }\n        if (s2[0].trim().length() > 0) {\n            parseTrigger(trans, s2[0].trim());\n        }\n        if (s2[1].trim().endsWith(\"]\")) {\n            String g = s2[1].trim();\n            g = g.substring(0, g.length() - 1).trim();\n            if (g.length() > 0) {\n                parseGuard(trans, g);\n            }\n        }\n        return trans;\n    }",
            "path": "src/argouml-app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
            "extendedDetails": {}
        },
        "4d0b0eba87adbbd2972649e03af67052c3b09f23": {
            "type": "Yfilerename",
            "commitMessage": "Issue 4625: Renamed directories to new structure.\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@14404 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "19/04/08 12:48 PM",
            "commitName": "4d0b0eba87adbbd2972649e03af67052c3b09f23",
            "commitAuthor": "Dave Thompson",
            "commitDateOld": "19/04/08 10:26 AM",
            "commitNameOld": "0f77652ed8cc3b911bf830092ee5d35778e87eaa",
            "commitAuthorOld": "Bob Tarling",
            "daysBetweenCommits": 0.1,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n        if ((c >= 0) && (c < b)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n\n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n\n        if (guardCondition != null) {\n            parseGuard(trans,\n                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n\n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
            "path": "src/argouml-app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
            "extendedDetails": {
                "oldPath": "src/app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
                "newPath": "src/argouml-app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java"
            }
        },
        "4f54dcde8c0a03ac8d3291c02ac2565f2083e61b": {
            "type": "Yfilerename",
            "commitMessage": "Restructuring the source code moving src_new, tests, and lib\nto src/app.\nBeginning of restructuring the src_new/build.xml into src/build.xml and\nsrc/<dir>/build.xml.\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@14094 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "09/02/08 6:30 AM",
            "commitName": "4f54dcde8c0a03ac8d3291c02ac2565f2083e61b",
            "commitAuthor": "Linus Tolke",
            "commitDateOld": "09/02/08 12:27 AM",
            "commitNameOld": "0f8460ae13458cdb91c04132f50b4ef4876bbe64",
            "commitAuthorOld": "Linus Tolke",
            "daysBetweenCommits": 0.25,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n        if ((c >= 0) && (c < b)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n\n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n\n        if (guardCondition != null) {\n            parseGuard(trans,\n                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n\n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
            "path": "src/app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java",
            "extendedDetails": {
                "oldPath": "src_new/org/argouml/notation/providers/uml/TransitionNotationUml.java",
                "newPath": "src/app/src/org/argouml/notation/providers/uml/TransitionNotationUml.java"
            }
        },
        "8fc5ed199e4e02b6e494849721fad07426ea29cf": {
            "type": "Yfilerename",
            "commitMessage": "Moved all parts of the Notation subsystem under one single directory, according the cookbook: \n\"Subparts of the subsystem can reside in subdirectories of this directory\".\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@12432 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "23/04/07 11:19 AM",
            "commitName": "8fc5ed199e4e02b6e494849721fad07426ea29cf",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "22/04/07 12:01 PM",
            "commitNameOld": "e758d32a4cb794e9703ce45c3b6acc405cd33737",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.97,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n        if ((c >= 0) && (c < b)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n\n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n\n        if (guardCondition != null) {\n            parseGuard(trans,\n                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n\n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
            "path": "src_new/org/argouml/notation/providers/uml/TransitionNotationUml.java",
            "extendedDetails": {
                "oldPath": "src_new/org/argouml/uml/notation/uml/TransitionNotationUml.java",
                "newPath": "src_new/org/argouml/notation/providers/uml/TransitionNotationUml.java"
            }
        },
        "613571a564b734f5ed2e503fa74c1d760f99b1dc": {
            "type": "Ybodychange",
            "commitMessage": "Issue 1285: Fixed by patches supplied by Andrea.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@10674 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "04/06/06 12:49 PM",
            "commitName": "613571a564b734f5ed2e503fa74c1d760f99b1dc",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "26/03/06 2:49 AM",
            "commitNameOld": "35c10a625a74224eb288e583d22e8cae1a6a6ea0",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 70.38,
            "commitsBetweenForRepo": 424,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,48 +1,52 @@\n     protected Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n \n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n         if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n-            throw new ParseException(\"No matching brackets [] found.\", 0);\n+            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n+            throw new ParseException(Translator.localize(msg), \n+                    0);\n         }\n         if ((c >= 0) && (c < b)) {\n-            throw new ParseException(\"Found a ']' after a '/'\", 0);\n+            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n+            throw new ParseException(Translator.localize(msg), \n+                    0);\n         }\n \n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n \n         if (eventSignature != null) {\n             // parseEventSignature(trans, eventSignature);\n             parseTrigger(trans, eventSignature);\n         }\n \n         if (guardCondition != null) {\n             parseGuard(trans,\n                     guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n \n         if (actionExpression != null) {\n             parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            String msg = \"parsing.error.transition.no-matching-square-brackets\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n        if ((c >= 0) && (c < b)) {\n            String msg = \"parsing.error.transition.found-bracket-instead-slash\";\n            throw new ParseException(Translator.localize(msg), \n                    0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n\n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n\n        if (guardCondition != null) {\n            parseGuard(trans,\n                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n\n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
            "path": "src_new/org/argouml/uml/notation/uml/TransitionNotationUml.java",
            "extendedDetails": {}
        },
        "0142dbe4b0accbee64c1c47d8bb703298b202b4d": {
            "type": "Ymultichange(Ymovefromfile,Ymodifierchange)",
            "commitMessage": "Further demolishment of the ParserDisplay for issue 1207.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@9854 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "22/02/06 8:14 AM",
            "commitName": "0142dbe4b0accbee64c1c47d8bb703298b202b4d",
            "commitAuthor": "Michiel van der Wulp",
            "subchanges": [
                {
                    "type": "Ymovefromfile",
                    "commitMessage": "Further demolishment of the ParserDisplay for issue 1207.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@9854 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "22/02/06 8:14 AM",
                    "commitName": "0142dbe4b0accbee64c1c47d8bb703298b202b4d",
                    "commitAuthor": "Michiel van der Wulp",
                    "commitDateOld": "21/02/06 5:28 PM",
                    "commitNameOld": "b6eb1379bf9a1a080d79d114bfc9cf43595d9b58",
                    "commitAuthorOld": "Bob Tarling",
                    "daysBetweenCommits": 0.62,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,48 +1,48 @@\n-    public Object parseTransition(Object trans, String s)\n+    protected Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n \n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n         if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n             throw new ParseException(\"No matching brackets [] found.\", 0);\n         }\n         if ((c >= 0) && (c < b)) {\n             throw new ParseException(\"Found a ']' after a '/'\", 0);\n         }\n \n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n \n         if (eventSignature != null) {\n             // parseEventSignature(trans, eventSignature);\n             parseTrigger(trans, eventSignature);\n         }\n \n         if (guardCondition != null) {\n-            parseGuard(trans,\n-                guardCondition.substring(guardCondition.indexOf('[') + 1));\n+            parseGuard(trans, \n+                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n \n         if (actionExpression != null) {\n             parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            throw new ParseException(\"No matching brackets [] found.\", 0);\n        }\n        if ((c >= 0) && (c < b)) {\n            throw new ParseException(\"Found a ']' after a '/'\", 0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n\n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n\n        if (guardCondition != null) {\n            parseGuard(trans, \n                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n\n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
                    "path": "src_new/org/argouml/uml/notation/uml/TransitionNotationUml.java",
                    "extendedDetails": {
                        "oldPath": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                        "newPath": "src_new/org/argouml/uml/notation/uml/TransitionNotationUml.java",
                        "oldMethodName": "parseTransition",
                        "newMethodName": "parseTransition"
                    }
                },
                {
                    "type": "Ymodifierchange",
                    "commitMessage": "Further demolishment of the ParserDisplay for issue 1207.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@9854 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "22/02/06 8:14 AM",
                    "commitName": "0142dbe4b0accbee64c1c47d8bb703298b202b4d",
                    "commitAuthor": "Michiel van der Wulp",
                    "commitDateOld": "21/02/06 5:28 PM",
                    "commitNameOld": "b6eb1379bf9a1a080d79d114bfc9cf43595d9b58",
                    "commitAuthorOld": "Bob Tarling",
                    "daysBetweenCommits": 0.62,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,48 +1,48 @@\n-    public Object parseTransition(Object trans, String s)\n+    protected Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n \n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n         if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n             throw new ParseException(\"No matching brackets [] found.\", 0);\n         }\n         if ((c >= 0) && (c < b)) {\n             throw new ParseException(\"Found a ']' after a '/'\", 0);\n         }\n \n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n \n         if (eventSignature != null) {\n             // parseEventSignature(trans, eventSignature);\n             parseTrigger(trans, eventSignature);\n         }\n \n         if (guardCondition != null) {\n-            parseGuard(trans,\n-                guardCondition.substring(guardCondition.indexOf('[') + 1));\n+            parseGuard(trans, \n+                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n \n         if (actionExpression != null) {\n             parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) {\n            throw new ParseException(\"No matching brackets [] found.\", 0);\n        }\n        if ((c >= 0) && (c < b)) {\n            throw new ParseException(\"Found a ']' after a '/'\", 0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n\n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n\n        if (guardCondition != null) {\n            parseGuard(trans, \n                    guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n\n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
                    "path": "src_new/org/argouml/uml/notation/uml/TransitionNotationUml.java",
                    "extendedDetails": {
                        "oldValue": "[public]",
                        "newValue": "[protected]"
                    }
                }
            ]
        },
        "93c7bfe3a07158c55214325c0333b66aeb041b30": {
            "type": "Ybodychange",
            "commitMessage": "Some cleanups in the use of the Model interfaces.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@7481 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "08/01/05 12:46 PM",
            "commitName": "93c7bfe3a07158c55214325c0333b66aeb041b30",
            "commitAuthor": "Linus Tolke",
            "commitDateOld": "03/01/05 1:30 AM",
            "commitNameOld": "654755aa8b86d4d89753de0cf9dc6e34e8c60db2",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 5.47,
            "commitsBetweenForRepo": 46,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,46 +1,48 @@\n-    public Object parseTransition(Object trans, String s) \n+    public Object parseTransition(Object trans, String s)\n         throws ParseException {\n         s = s.trim();\n-        \n+\n         int a = s.indexOf(\"[\");\n         int b = s.indexOf(\"]\");\n         int c = s.indexOf(\"/\");\n-        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) \n+        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) { \n             throw new ParseException(\"No matching brackets [] found.\", 0);\n-        if ((c >= 0) && (c < b))\n+        }\n+        if ((c >= 0) && (c < b)) {\n             throw new ParseException(\"Found a ']' after a '/'\", 0);\n-        \n+        }\n+\n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n            \n         if (eventSignature != null) {\n             // parseEventSignature(trans, eventSignature);\n             parseTrigger(trans, eventSignature);\n         }\n       \n         if (guardCondition != null) {\n             parseGuard(trans, \n                 guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n        \n         if (actionExpression != null) {\n             parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s)\n        throws ParseException {\n        s = s.trim();\n\n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) { \n            throw new ParseException(\"No matching brackets [] found.\", 0);\n        }\n        if ((c >= 0) && (c < b)) {\n            throw new ParseException(\"Found a ']' after a '/'\", 0);\n        }\n\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n           \n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n      \n        if (guardCondition != null) {\n            parseGuard(trans, \n                guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n       \n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "30"
        },
        "d8f7e6b7474b62d80734254cd46e81bd0892c4d1": {
            "type": "Ymultichange(Yexceptionschange,Ybodychange)",
            "commitMessage": "Solved most of issue 2860: Repeated signals for the same internal transition.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@7007 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "07/11/04 12:31 PM",
            "commitName": "d8f7e6b7474b62d80734254cd46e81bd0892c4d1",
            "commitAuthor": "Michiel van der Wulp",
            "subchanges": [
                {
                    "type": "Yexceptionschange",
                    "commitMessage": "Solved most of issue 2860: Repeated signals for the same internal transition.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@7007 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "07/11/04 12:31 PM",
                    "commitName": "d8f7e6b7474b62d80734254cd46e81bd0892c4d1",
                    "commitAuthor": "Michiel van der Wulp",
                    "commitDateOld": "05/11/04 10:42 AM",
                    "commitNameOld": "b4dc58264c716593fdb4346d3b27882a713dc7f6",
                    "commitAuthorOld": "Michiel van der Wulp",
                    "daysBetweenCommits": 2.08,
                    "commitsBetweenForRepo": 2,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,40 +1,46 @@\n-    public Object parseTransition(Object trans, String s) {\n+    public Object parseTransition(Object trans, String s) \n+        throws ParseException {\n         s = s.trim();\n+        \n+        int a = s.indexOf(\"[\");\n+        int b = s.indexOf(\"]\");\n+        int c = s.indexOf(\"/\");\n+        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) \n+            throw new ParseException(\"No matching brackets [] found.\", 0);\n+        if ((c >= 0) && (c < b))\n+            throw new ParseException(\"Found a ']' after a '/'\", 0);\n+        \n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n            \n         if (eventSignature != null) {\n-            try {\n-                // parseEventSignature(trans, eventSignature);\n-                parseTrigger(trans, eventSignature);\n-            } catch (ParseException e) {\n-                LOG.warn(e);\n-            }\n+            // parseEventSignature(trans, eventSignature);\n+            parseTrigger(trans, eventSignature);\n         }\n       \n         if (guardCondition != null) {\n             parseGuard(trans, \n                 guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n        \n         if (actionExpression != null) {\n             parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public Object parseTransition(Object trans, String s) \n        throws ParseException {\n        s = s.trim();\n        \n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) \n            throw new ParseException(\"No matching brackets [] found.\", 0);\n        if ((c >= 0) && (c < b))\n            throw new ParseException(\"Found a ']' after a '/'\", 0);\n        \n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n           \n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n      \n        if (guardCondition != null) {\n            parseGuard(trans, \n                guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n       \n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {
                        "oldValue": "[]",
                        "newValue": "[ParseException]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Solved most of issue 2860: Repeated signals for the same internal transition.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@7007 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "07/11/04 12:31 PM",
                    "commitName": "d8f7e6b7474b62d80734254cd46e81bd0892c4d1",
                    "commitAuthor": "Michiel van der Wulp",
                    "commitDateOld": "05/11/04 10:42 AM",
                    "commitNameOld": "b4dc58264c716593fdb4346d3b27882a713dc7f6",
                    "commitAuthorOld": "Michiel van der Wulp",
                    "daysBetweenCommits": 2.08,
                    "commitsBetweenForRepo": 2,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,40 +1,46 @@\n-    public Object parseTransition(Object trans, String s) {\n+    public Object parseTransition(Object trans, String s) \n+        throws ParseException {\n         s = s.trim();\n+        \n+        int a = s.indexOf(\"[\");\n+        int b = s.indexOf(\"]\");\n+        int c = s.indexOf(\"/\");\n+        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) \n+            throw new ParseException(\"No matching brackets [] found.\", 0);\n+        if ((c >= 0) && (c < b))\n+            throw new ParseException(\"Found a ']' after a '/'\", 0);\n+        \n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n            \n         if (eventSignature != null) {\n-            try {\n-                // parseEventSignature(trans, eventSignature);\n-                parseTrigger(trans, eventSignature);\n-            } catch (ParseException e) {\n-                LOG.warn(e);\n-            }\n+            // parseEventSignature(trans, eventSignature);\n+            parseTrigger(trans, eventSignature);\n         }\n       \n         if (guardCondition != null) {\n             parseGuard(trans, \n                 guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n        \n         if (actionExpression != null) {\n             parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public Object parseTransition(Object trans, String s) \n        throws ParseException {\n        s = s.trim();\n        \n        int a = s.indexOf(\"[\");\n        int b = s.indexOf(\"]\");\n        int c = s.indexOf(\"/\");\n        if (((a < 0) && (b >= 0)) || ((b < 0) && (a >= 0)) || (b < a)) \n            throw new ParseException(\"No matching brackets [] found.\", 0);\n        if ((c >= 0) && (c < b))\n            throw new ParseException(\"Found a ']' after a '/'\", 0);\n        \n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n           \n        if (eventSignature != null) {\n            // parseEventSignature(trans, eventSignature);\n            parseTrigger(trans, eventSignature);\n        }\n      \n        if (guardCondition != null) {\n            parseGuard(trans, \n                guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n       \n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "10"
        },
        "b51bf4a859d77fa6df98bfec6d01538b49c5057a": {
            "type": "Ybodychange",
            "commitMessage": "Solved issue 2742: Editing transition text on diagram destroys previously entered data.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@7004 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "05/11/04 8:39 AM",
            "commitName": "b51bf4a859d77fa6df98bfec6d01538b49c5057a",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "01/11/04 11:56 AM",
            "commitNameOld": "a05e2ac14452a3baea9f1399c898fbc01c7a0760",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 3.86,
            "commitsBetweenForRepo": 26,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,40 +1,40 @@\n     public Object parseTransition(Object trans, String s) {\n         s = s.trim();\n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n-            String nextToken = tokenizer.nextToken();\n+            String nextToken = tokenizer.nextToken().trim();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n                 }\n             }\n         }\n            \n         if (eventSignature != null) {\n             try {\n-                parseEventSignature(trans, eventSignature);\n+                // parseEventSignature(trans, eventSignature);\n+                parseTrigger(trans, eventSignature);\n             } catch (ParseException e) {\n                 LOG.warn(e);\n             }\n         }\n       \n         if (guardCondition != null) {\n             parseGuard(trans, \n                 guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n        \n         if (actionExpression != null) {\n-            Object action = parseAction(actionExpression.trim());\n-            ModelFacade.setEffect(trans, action);\n+            parseEffect(trans, actionExpression.trim());\n         }\n         return trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n        s = s.trim();\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken().trim();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n           \n        if (eventSignature != null) {\n            try {\n                // parseEventSignature(trans, eventSignature);\n                parseTrigger(trans, eventSignature);\n            } catch (ParseException e) {\n                LOG.warn(e);\n            }\n        }\n      \n        if (guardCondition != null) {\n            parseGuard(trans, \n                guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n       \n        if (actionExpression != null) {\n            parseEffect(trans, actionExpression.trim());\n        }\n        return trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "638125db80440d37fc7b6a52626f814a191bb377": {
            "type": "Ybodychange",
            "commitMessage": "Solved issue 2742 for guards.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6834 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "10/10/04 1:09 PM",
            "commitName": "638125db80440d37fc7b6a52626f814a191bb377",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "01/10/04 7:01 AM",
            "commitNameOld": "687fc7457fdd7e94e5f8507ac56128cebdc9fde6",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 9.26,
            "commitsBetweenForRepo": 48,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,333 +1,40 @@\n     public Object parseTransition(Object trans, String s) {\n         s = s.trim();\n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n-                }\n-                else\n+                } else {\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n+                }\n             }\n         }\n            \n         if (eventSignature != null) {\n             try {\n                 parseEventSignature(trans, eventSignature);\n             } catch (ParseException e) {\n                 LOG.warn(e);\n             }\n         }\n       \n         if (guardCondition != null) {\n-            Object guard = parseGuard(guardCondition.substring(guardCondition\n-                    .indexOf('[') + 1));\n-            ModelFacade.setGuard(trans, guard);\n+            parseGuard(trans, \n+                guardCondition.substring(guardCondition.indexOf('[') + 1));\n         }\n        \n         if (actionExpression != null) {\n             Object action = parseAction(actionExpression.trim());\n             ModelFacade.setEffect(trans, action);\n         }\n         return trans;\n-\n-        \n-        // //DO NOT DELETE!\n-        // //MVW: I still need this to help me create \n-        // //the functionality that is now missing!\n-        //\n-        //\t// strip any trailing semi-colons\n-        //\ts = s.trim();\n-        //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n-        //\t    s = s.substring(0, s.length() - 1).trim();\n-        //\n-        //        // strip off the name, and the \":\"\n-        //\tString name = \"\";\n-        //\tString trigger = \"\";\n-        //\tString guard = \"\";\n-        //\tString actions = \"\";\n-        //\tif (s.indexOf(\":\", 0) > -1) {\n-        //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n-        //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n-        //\t    // the name may not contain a \"/\", \n-        //          // for when the action contains a \":\"\n-        //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n-        //\t        name = s1.trim();\n-        //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n-        //\t    }\n-        //        }\n-        //\n-        //        // get the guard from between the []\n-        //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n-        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, \n-        //              s.indexOf(\"]\")).trim();\n-        //\t    s = s.substring(0, s.indexOf(\"[\")) \n-        //                  + s.substring(s.indexOf(\"]\") + 1);\n-        //\t    s = s.trim();\n-        //\t}\n-        //\n-        //        // everything behind the \"/\" is the action\n-        //\tif (s.indexOf(\"/\", 0) > -1) {\n-        //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n-        //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n-        //\t}\n-        //\n-        //        // and the remainder is the trigger name\n-        //\ttrigger = s;\n-        //\n-        //\t// let's look for a TimeEvent, ChangeEvent, \n-        //      // CallEvent or SignalEvent\n-        //\tboolean timeEvent = false;\n-        //\tboolean changeEvent = false;\n-        //\tboolean callEvent = false;\n-        //\tboolean signalEvent = false;\n-        //\tString operationName = \"\";\n-        //\tif ((s.toLowerCase().startsWith(\"after\"))\n-        //\t    && (s.indexOf(\"(\", 0) > -1)\n-        //\t    && (s.indexOf(\")\", 0) > -1))\n-        //\t{ //s shall contain the TimeExpression\n-        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n-        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n-        //\t    timeEvent = true;\n-        //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n-        //\t\t   && (s.indexOf(\"(\", 0) > -1)\n-        //\t\t   && (s.indexOf(\")\", 0) > -1))\n-        //\t{ // s shall contain the ChangeExpression\n-        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n-        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n-        //\t    changeEvent = true;\n-        //\t} else if ((s.indexOf(\"(\", 0) > -1)\n-        //            && (s.indexOf(\")\", 0) > -1))\n-        //        { // s shall contain the operation\n-        //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n-        //\t    callEvent = true;\n-        //        } else { // s shall contain the signal\n-        //            signalEvent = true;\n-        //        }\n-        //\n-        //\tLOG.debug(\"name=|\" + name + \"|\");\n-        //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n-        //\tLOG.debug(\"guard=|\" + guard + \"|\");\n-        //\tLOG.debug(\"actions=|\" + actions + \"|\");\n-        //\n-        //        // use the name we found to (re)name the transition\n-        //\tModelFacade.setName(trans, name);\n-        //\n-        //// /* The following handles the Event that is the trigger of\n-        //// this transition.\n-        //// We can distinct between 4 cases:\n-        //// 1. A trigger is given. None exists yet.\n-        //// 2. The name of the trigger was present, but is (the same or)\n-        // altered.\n-        //// 3. A trigger is not given. None exists yet.\n-        //// 4. The name of the trigger was present, but is removed.\n-        //// The reaction in these cases should be:\n-        //// 1. Create a new trigger, name it, and hook it to the transition.\n-        //// 2. Rename the trigger.\n-        //// 3. Nop.\n-        //// 4. Unhook and erase the existing trigger.\n-        ////\n-        //// TODO:\n-        //// In fact it could be made even more complicated for case 1:\n-        //// If the transition did not have a trigger before,\n-        //// a trigger-name is given, and a trigger already\n-        //// existed with that name,\n-        //// then we have to use the existing trigger object!\n-        //// */\n-        //        Object evt = ModelFacade.getTrigger(trans);\n-        //        boolean created_evt = false;\n-        //\tif (trigger.length() > 0) {\n-        //            // case 1 and 2\n-        //            if (evt == null) {\n-        //                // case 1\n-        //                if (timeEvent) { // after(...)\n-        //                    evt = UmlFactory.getFactory().getStateMachines()\n-        //                                                .buildTimeEvent(s);\n-        //                }\n-        //                if (changeEvent) { // when(...)\n-        //                    evt = UmlFactory.getFactory().getStateMachines()\n-        //                                                .buildChangeEvent(s);\n-        //                }\n-        //                if (callEvent) { // operation(paramlist)\n-        //                    evt = UmlFactory.getFactory().getStateMachines()\n-        //\t\t\t            .buildCallEvent(trans, trigger);\n-        //                }\n-        //                if (signalEvent) { // signalname\n-        //                    evt = UmlFactory.getFactory().getStateMachines()\n-        //                                   .buildSignalEvent(trigger);\n-        //                }\n-        //                created_evt = true;\n-        //            } else {\n-        //                // case 2\n-        //                if (!ModelFacade.getName(evt).equals(trigger)) {\n-        //                    ModelFacade.setName(evt, trigger);\n-        //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n-        //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory()\n-        //                            .getStateMachines().buildTimeEvent(s);\n-        //                        created_evt = true;\n-        //                    }\n-        //                    if (changeEvent && !ModelFacade\n-        //                        .isAChangeEvent(evt)) {\n-        //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory()\n-        //                            .getStateMachines().buildChangeEvent(s);\n-        //                        created_evt = true;\n-        //                    }\n-        //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n-        //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory()\n-        //                            .getStateMachines()\n-        //                            .buildCallEvent(trans, trigger);\n-        //                        created_evt = true;\n-        //                    }\n-        //                    if (signalEvent && !ModelFacade\n-        //                        .isASignalEvent(evt)) {\n-        //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory()\n-        //                            .getStateMachines()\n-        //                            .buildSignalEvent(trigger);\n-        //                        created_evt = true;\n-        //                    }\n-        //                }\n-        //            }\n-        //            if (created_evt && (evt != null)) {\n-        //                StateMachinesHelper.getHelper()\n-        //                    .setEventAsTrigger(trans, evt);\n-        //                \n-        //                /* The next part is explained by the following\n-        //                 * quote from the UML spec:\n-        //                 * \"The event declaration has scope within\n-        //                 * the package it appears in and may be used in\n-        //                 * state diagrams for classes that have visibility\n-        //                 * inside the package. An event is not local to\n-        //                 * a single class.\"\n-        //                 */\n-        //                Object enclosing = StateMachinesHelper.getHelper()\n-        //                                            .getStateMachine(trans);\n-        //                while ((!ModelFacade.isAPackage(enclosing))\n-        //\t\t       && (enclosing != null)) {\n-        //                    enclosing = ModelFacade.getNamespace(enclosing);\n-        //\t\t}\n-        //                if (enclosing != null) {\n-        //\t\t    ModelFacade.setNamespace(evt, enclosing);\n-        //\t\t}\n-        //            }\n-        //\t} else {\n-        //            // case 3 and 4\n-        //            if (evt == null) {\n-        //                ;// case 3\n-        //\t    } else {\n-        //                // case 4\n-        //                UmlFactory.getFactory().delete(evt); // erase it\n-        //            }\n-        //        }\n-        //\n-        //\t/* handle the Guard\n-        //\tWe can distinct between 4 cases:\n-        //        1. A guard is given. None exists yet.\n-        //        2. The expression of the guard was present, but is altered.\n-        //        3. A guard is not given. None exists yet.\n-        //        4. The expression of the guard was present, but is removed.\n-        //        The reaction in these cases should be:\n-        //        1. Create a new guard, set its name, language & expression,\n-        //\t   and hook it to the transition.\n-        //        2. Change the guard's expression. Leave the name & language\n-        // untouched.\n-        //        3. Nop.\n-        //        4. Unhook and erase the existing guard.\n-        //        */\n-        //\tObject g = ModelFacade.getGuard(trans);\n-        //\tif (guard.length() > 0) {\n-        //\t    if (g == null) {\n-        //                // case 1\n-        //\t        /*TODO: In the next line, I should use buildGuard(),\n-        //\t         * but it doesn't show the guard on the diagram...\n-        //\t         * Why? (MVW)*/\n-        //\t\tg = UmlFactory.getFactory().getStateMachines()\n-        //                  .createGuard();\n-        //\t\tif (g != null) {\n-        //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n-        //\t\t    \t.getDataTypes().createBooleanExpression(\n-        //                                                   \"Java\", guard));\n-        //\t\t    ModelFacade.setName(g, \"anon\");\n-        //\t\t    ModelFacade.setTransition(g, trans);\n-        //\t\t    ModelFacade.setGuard(trans, g);\n-        //\t\t}\n-        //\t    } else {\n-        //                // case 2\n-        //\t\t\n-        //\t\t/* TODO: This does not work! Why not? (MVW)\n-        //\t        Object expr = ModelFacade.getExpression(g);\n-        //\t\tModelFacade.setBody(expr,guard);\n-        //\t\tModelFacade.setExpression(g,expr); */\n-        //\t        \n-        //\t        //hence a less elegant workaround that works:\n-        //\t        String language = ModelFacade.getLanguage(\n-        //                  ModelFacade.getExpression(g));\n-        //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n-        //                    .getDataTypes().createBooleanExpression(\n-        //                                              language, guard));\n-        //                /* TODO: In this case, the properties panel \n-        //                  is not updated\n-        //\t\t    with the changed expression! */\n-        //\t    }\n-        //\t} else {\n-        //\t    if (g == null) {\n-        //                ;// case 3\n-        //\t    } else {\n-        //                // case 4\n-        //\t\tUmlFactory.getFactory().delete(g); // erase it\n-        //\t    }\n-        //\t}\n-        //\n-        //        /* handle the Effect (Action)\n-        //        We can distinct between 4 cases:\n-        //        1. An effect is given. None exists yet.\n-        //        2. The expression of the effect was present, but is altered.\n-        //        3. An effct is not given. None exists yet.\n-        //        4. The expression of the effect was present, but is removed.\n-        //        The reaction in these cases should be:\n-        //        1. Create a new CallAction, set its name, language & \n-        //        expression, and hook it to the transition.\n-        //        2. Change the effect's expression. Leave the actiontype, name \n-        //\t  & language untouched.\n-        //        3. Nop.\n-        //        4. Unhook and erase the existing effect.\n-        //        */\n-        //\tObject effect = ModelFacade.getEffect(trans);\n-        //\tif (actions.length() > 0) {\n-        //\t    if (effect == null) { // case 1\n-        //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n-        //\t\t    .createCallAction();\n-        //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n-        //\t\t    .getDataTypes().createActionExpression(\n-        //                                                   \"Java\", actions));\n-        //\t        ModelFacade.setName(effect, \"anon\");\n-        //\t        ModelFacade.setEffect(trans, effect);\n-        //\t    } else { // case 2\n-        //                String language = ModelFacade.getLanguage(ModelFacade\n-        //\t\t    .getScript(effect));\n-        //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n-        //\t\t    .getDataTypes().createActionExpression(\n-        //                                            language, actions));\n-        //\t    }\n-        //\t} else { // case 3 & 4\n-        //\t    if (effect == null) {\n-        //                ;// case 3\n-        //            } else {\n-        //                // case 4\n-        //                UmlFactory.getFactory().delete(effect); // erase it\n-        //            }\n-        //\t}\n-        //\n-        //\treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n        s = s.trim();\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                } else {\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n                }\n            }\n        }\n           \n        if (eventSignature != null) {\n            try {\n                parseEventSignature(trans, eventSignature);\n            } catch (ParseException e) {\n                LOG.warn(e);\n            }\n        }\n      \n        if (guardCondition != null) {\n            parseGuard(trans, \n                guardCondition.substring(guardCondition.indexOf('[') + 1));\n        }\n       \n        if (actionExpression != null) {\n            Object action = parseAction(actionExpression.trim());\n            ModelFacade.setEffect(trans, action);\n        }\n        return trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "e61a20cc90688442d303fcc842612cf4a5e3bc25": {
            "type": "Ybodychange",
            "commitMessage": "Style issues. Privatised stuff.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6764 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "26/09/04 1:45 PM",
            "commitName": "e61a20cc90688442d303fcc842612cf4a5e3bc25",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "24/08/04 10:37 AM",
            "commitNameOld": "04e85a0ca14e7a29b97f8bb8f9994ee56b13e76c",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 33.13,
            "commitsBetweenForRepo": 191,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,319 +1,333 @@\n     public Object parseTransition(Object trans, String s) {\n         s = s.trim();\n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 }\n                 else\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n             }\n         }\n            \n         if (eventSignature != null) {\n             try {\n                 parseEventSignature(trans, eventSignature);\n             } catch (ParseException e) {\n                 LOG.warn(e);\n             }\n         }\n       \n         if (guardCondition != null) {\n             Object guard = parseGuard(guardCondition.substring(guardCondition\n                     .indexOf('[') + 1));\n             ModelFacade.setGuard(trans, guard);\n         }\n        \n         if (actionExpression != null) {\n             Object action = parseAction(actionExpression.trim());\n             ModelFacade.setEffect(trans, action);\n         }\n         return trans;\n \n         \n         // //DO NOT DELETE!\n         // //MVW: I still need this to help me create \n         // //the functionality that is now missing!\n         //\n         //\t// strip any trailing semi-colons\n         //\ts = s.trim();\n         //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n         //\t    s = s.substring(0, s.length() - 1).trim();\n         //\n         //        // strip off the name, and the \":\"\n         //\tString name = \"\";\n         //\tString trigger = \"\";\n         //\tString guard = \"\";\n         //\tString actions = \"\";\n         //\tif (s.indexOf(\":\", 0) > -1) {\n         //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n         //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n-        //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n+        //\t    // the name may not contain a \"/\", \n+        //          // for when the action contains a \":\"\n         //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n         //\t        name = s1.trim();\n         //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n         //\t    }\n         //        }\n         //\n         //        // get the guard from between the []\n         //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n-        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n-        //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n-        //\t\t\t\t\t\t\t     + 1);\n+        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, \n+        //              s.indexOf(\"]\")).trim();\n+        //\t    s = s.substring(0, s.indexOf(\"[\")) \n+        //                  + s.substring(s.indexOf(\"]\") + 1);\n         //\t    s = s.trim();\n         //\t}\n         //\n         //        // everything behind the \"/\" is the action\n         //\tif (s.indexOf(\"/\", 0) > -1) {\n         //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n         //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n         //\t}\n         //\n         //        // and the remainder is the trigger name\n         //\ttrigger = s;\n         //\n-        //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n+        //\t// let's look for a TimeEvent, ChangeEvent, \n+        //      // CallEvent or SignalEvent\n         //\tboolean timeEvent = false;\n         //\tboolean changeEvent = false;\n         //\tboolean callEvent = false;\n         //\tboolean signalEvent = false;\n         //\tString operationName = \"\";\n         //\tif ((s.toLowerCase().startsWith(\"after\"))\n         //\t    && (s.indexOf(\"(\", 0) > -1)\n         //\t    && (s.indexOf(\")\", 0) > -1))\n         //\t{ //s shall contain the TimeExpression\n         //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n         //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n         //\t    timeEvent = true;\n         //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n         //\t\t   && (s.indexOf(\"(\", 0) > -1)\n         //\t\t   && (s.indexOf(\")\", 0) > -1))\n         //\t{ // s shall contain the ChangeExpression\n         //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n         //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n         //\t    changeEvent = true;\n         //\t} else if ((s.indexOf(\"(\", 0) > -1)\n         //            && (s.indexOf(\")\", 0) > -1))\n         //        { // s shall contain the operation\n         //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n         //\t    callEvent = true;\n         //        } else { // s shall contain the signal\n         //            signalEvent = true;\n         //        }\n         //\n         //\tLOG.debug(\"name=|\" + name + \"|\");\n         //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n         //\tLOG.debug(\"guard=|\" + guard + \"|\");\n         //\tLOG.debug(\"actions=|\" + actions + \"|\");\n         //\n         //        // use the name we found to (re)name the transition\n         //\tModelFacade.setName(trans, name);\n         //\n         //// /* The following handles the Event that is the trigger of\n         //// this transition.\n         //// We can distinct between 4 cases:\n         //// 1. A trigger is given. None exists yet.\n         //// 2. The name of the trigger was present, but is (the same or)\n         // altered.\n         //// 3. A trigger is not given. None exists yet.\n         //// 4. The name of the trigger was present, but is removed.\n         //// The reaction in these cases should be:\n         //// 1. Create a new trigger, name it, and hook it to the transition.\n         //// 2. Rename the trigger.\n         //// 3. Nop.\n         //// 4. Unhook and erase the existing trigger.\n         ////\n         //// TODO:\n         //// In fact it could be made even more complicated for case 1:\n         //// If the transition did not have a trigger before,\n         //// a trigger-name is given, and a trigger already\n         //// existed with that name,\n         //// then we have to use the existing trigger object!\n         //// */\n         //        Object evt = ModelFacade.getTrigger(trans);\n         //        boolean created_evt = false;\n         //\tif (trigger.length() > 0) {\n         //            // case 1 and 2\n         //            if (evt == null) {\n         //                // case 1\n         //                if (timeEvent) { // after(...)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildTimeEvent(s);\n         //                }\n         //                if (changeEvent) { // when(...)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildChangeEvent(s);\n         //                }\n         //                if (callEvent) { // operation(paramlist)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n-        //\t\t\t                        .buildCallEvent(trans, trigger);\n+        //\t\t\t            .buildCallEvent(trans, trigger);\n         //                }\n         //                if (signalEvent) { // signalname\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n-        //                                                .buildSignalEvent(trigger);\n+        //                                   .buildSignalEvent(trigger);\n         //                }\n         //                created_evt = true;\n         //            } else {\n         //                // case 2\n         //                if (!ModelFacade.getName(evt).equals(trigger)) {\n         //                    ModelFacade.setName(evt, trigger);\n         //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory().getStateMachines()\n-        //                            .buildTimeEvent(s);\n+        //                        evt = UmlFactory.getFactory()\n+        //                            .getStateMachines().buildTimeEvent(s);\n         //                        created_evt = true;\n         //                    }\n-        //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n+        //                    if (changeEvent && !ModelFacade\n+        //                        .isAChangeEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory().getStateMachines()\n-        //                            .buildChangeEvent(s);\n+        //                        evt = UmlFactory.getFactory()\n+        //                            .getStateMachines().buildChangeEvent(s);\n         //                        created_evt = true;\n         //                    }\n         //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory().getStateMachines()\n+        //                        evt = UmlFactory.getFactory()\n+        //                            .getStateMachines()\n         //                            .buildCallEvent(trans, trigger);\n         //                        created_evt = true;\n         //                    }\n-        //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n+        //                    if (signalEvent && !ModelFacade\n+        //                        .isASignalEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n-        //                        evt = UmlFactory.getFactory().getStateMachines()\n+        //                        evt = UmlFactory.getFactory()\n+        //                            .getStateMachines()\n         //                            .buildSignalEvent(trigger);\n         //                        created_evt = true;\n         //                    }\n         //                }\n         //            }\n         //            if (created_evt && (evt != null)) {\n-        //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n+        //                StateMachinesHelper.getHelper()\n+        //                    .setEventAsTrigger(trans, evt);\n         //                \n         //                /* The next part is explained by the following\n         //                 * quote from the UML spec:\n         //                 * \"The event declaration has scope within\n         //                 * the package it appears in and may be used in\n         //                 * state diagrams for classes that have visibility\n         //                 * inside the package. An event is not local to\n         //                 * a single class.\"\n         //                 */\n         //                Object enclosing = StateMachinesHelper.getHelper()\n-        //                                                .getStateMachine(trans);\n+        //                                            .getStateMachine(trans);\n         //                while ((!ModelFacade.isAPackage(enclosing))\n         //\t\t       && (enclosing != null)) {\n         //                    enclosing = ModelFacade.getNamespace(enclosing);\n         //\t\t}\n         //                if (enclosing != null) {\n         //\t\t    ModelFacade.setNamespace(evt, enclosing);\n         //\t\t}\n         //            }\n         //\t} else {\n         //            // case 3 and 4\n         //            if (evt == null) {\n         //                ;// case 3\n         //\t    } else {\n         //                // case 4\n         //                UmlFactory.getFactory().delete(evt); // erase it\n         //            }\n         //        }\n         //\n         //\t/* handle the Guard\n         //\tWe can distinct between 4 cases:\n         //        1. A guard is given. None exists yet.\n         //        2. The expression of the guard was present, but is altered.\n         //        3. A guard is not given. None exists yet.\n         //        4. The expression of the guard was present, but is removed.\n         //        The reaction in these cases should be:\n         //        1. Create a new guard, set its name, language & expression,\n         //\t   and hook it to the transition.\n         //        2. Change the guard's expression. Leave the name & language\n         // untouched.\n         //        3. Nop.\n         //        4. Unhook and erase the existing guard.\n         //        */\n         //\tObject g = ModelFacade.getGuard(trans);\n         //\tif (guard.length() > 0) {\n         //\t    if (g == null) {\n         //                // case 1\n         //\t        /*TODO: In the next line, I should use buildGuard(),\n         //\t         * but it doesn't show the guard on the diagram...\n         //\t         * Why? (MVW)*/\n-        //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n+        //\t\tg = UmlFactory.getFactory().getStateMachines()\n+        //                  .createGuard();\n         //\t\tif (g != null) {\n         //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n-        //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n+        //\t\t    \t.getDataTypes().createBooleanExpression(\n+        //                                                   \"Java\", guard));\n         //\t\t    ModelFacade.setName(g, \"anon\");\n         //\t\t    ModelFacade.setTransition(g, trans);\n         //\t\t    ModelFacade.setGuard(trans, g);\n         //\t\t}\n         //\t    } else {\n         //                // case 2\n         //\t\t\n         //\t\t/* TODO: This does not work! Why not? (MVW)\n         //\t        Object expr = ModelFacade.getExpression(g);\n         //\t\tModelFacade.setBody(expr,guard);\n         //\t\tModelFacade.setExpression(g,expr); */\n         //\t        \n         //\t        //hence a less elegant workaround that works:\n-        //\t        String language =\n-        //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n+        //\t        String language = ModelFacade.getLanguage(\n+        //                  ModelFacade.getExpression(g));\n         //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n-        //                    .getDataTypes().createBooleanExpression(language, guard));\n-        //                /* TODO: In this case, the properties panel is not updated\n+        //                    .getDataTypes().createBooleanExpression(\n+        //                                              language, guard));\n+        //                /* TODO: In this case, the properties panel \n+        //                  is not updated\n         //\t\t    with the changed expression! */\n         //\t    }\n         //\t} else {\n         //\t    if (g == null) {\n         //                ;// case 3\n         //\t    } else {\n         //                // case 4\n         //\t\tUmlFactory.getFactory().delete(g); // erase it\n         //\t    }\n         //\t}\n         //\n         //        /* handle the Effect (Action)\n         //        We can distinct between 4 cases:\n         //        1. An effect is given. None exists yet.\n         //        2. The expression of the effect was present, but is altered.\n         //        3. An effct is not given. None exists yet.\n         //        4. The expression of the effect was present, but is removed.\n         //        The reaction in these cases should be:\n-        //        1. Create a new CallAction, set its name, language & expression,\n-        //        and hook it to the transition.\n-        //        2. Change the effect's expression. Leave the actiontype, name &\n-        //\tlanguage untouched.\n+        //        1. Create a new CallAction, set its name, language & \n+        //        expression, and hook it to the transition.\n+        //        2. Change the effect's expression. Leave the actiontype, name \n+        //\t  & language untouched.\n         //        3. Nop.\n         //        4. Unhook and erase the existing effect.\n         //        */\n         //\tObject effect = ModelFacade.getEffect(trans);\n         //\tif (actions.length() > 0) {\n         //\t    if (effect == null) { // case 1\n         //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n         //\t\t    .createCallAction();\n         //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n-        //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n+        //\t\t    .getDataTypes().createActionExpression(\n+        //                                                   \"Java\", actions));\n         //\t        ModelFacade.setName(effect, \"anon\");\n         //\t        ModelFacade.setEffect(trans, effect);\n         //\t    } else { // case 2\n         //                String language = ModelFacade.getLanguage(ModelFacade\n         //\t\t    .getScript(effect));\n         //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n-        //\t\t    .getDataTypes().createActionExpression(language, actions));\n+        //\t\t    .getDataTypes().createActionExpression(\n+        //                                            language, actions));\n         //\t    }\n         //\t} else { // case 3 & 4\n         //\t    if (effect == null) {\n         //                ;// case 3\n         //            } else {\n         //                // case 4\n         //                UmlFactory.getFactory().delete(effect); // erase it\n         //            }\n         //\t}\n         //\n         //\treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n        s = s.trim();\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                }\n                else\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n            }\n        }\n           \n        if (eventSignature != null) {\n            try {\n                parseEventSignature(trans, eventSignature);\n            } catch (ParseException e) {\n                LOG.warn(e);\n            }\n        }\n      \n        if (guardCondition != null) {\n            Object guard = parseGuard(guardCondition.substring(guardCondition\n                    .indexOf('[') + 1));\n            ModelFacade.setGuard(trans, guard);\n        }\n       \n        if (actionExpression != null) {\n            Object action = parseAction(actionExpression.trim());\n            ModelFacade.setEffect(trans, action);\n        }\n        return trans;\n\n        \n        // //DO NOT DELETE!\n        // //MVW: I still need this to help me create \n        // //the functionality that is now missing!\n        //\n        //\t// strip any trailing semi-colons\n        //\ts = s.trim();\n        //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n        //\t    s = s.substring(0, s.length() - 1).trim();\n        //\n        //        // strip off the name, and the \":\"\n        //\tString name = \"\";\n        //\tString trigger = \"\";\n        //\tString guard = \"\";\n        //\tString actions = \"\";\n        //\tif (s.indexOf(\":\", 0) > -1) {\n        //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n        //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n        //\t    // the name may not contain a \"/\", \n        //          // for when the action contains a \":\"\n        //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n        //\t        name = s1.trim();\n        //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n        //\t    }\n        //        }\n        //\n        //        // get the guard from between the []\n        //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, \n        //              s.indexOf(\"]\")).trim();\n        //\t    s = s.substring(0, s.indexOf(\"[\")) \n        //                  + s.substring(s.indexOf(\"]\") + 1);\n        //\t    s = s.trim();\n        //\t}\n        //\n        //        // everything behind the \"/\" is the action\n        //\tif (s.indexOf(\"/\", 0) > -1) {\n        //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n        //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n        //\t}\n        //\n        //        // and the remainder is the trigger name\n        //\ttrigger = s;\n        //\n        //\t// let's look for a TimeEvent, ChangeEvent, \n        //      // CallEvent or SignalEvent\n        //\tboolean timeEvent = false;\n        //\tboolean changeEvent = false;\n        //\tboolean callEvent = false;\n        //\tboolean signalEvent = false;\n        //\tString operationName = \"\";\n        //\tif ((s.toLowerCase().startsWith(\"after\"))\n        //\t    && (s.indexOf(\"(\", 0) > -1)\n        //\t    && (s.indexOf(\")\", 0) > -1))\n        //\t{ //s shall contain the TimeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    timeEvent = true;\n        //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n        //\t\t   && (s.indexOf(\"(\", 0) > -1)\n        //\t\t   && (s.indexOf(\")\", 0) > -1))\n        //\t{ // s shall contain the ChangeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    changeEvent = true;\n        //\t} else if ((s.indexOf(\"(\", 0) > -1)\n        //            && (s.indexOf(\")\", 0) > -1))\n        //        { // s shall contain the operation\n        //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n        //\t    callEvent = true;\n        //        } else { // s shall contain the signal\n        //            signalEvent = true;\n        //        }\n        //\n        //\tLOG.debug(\"name=|\" + name + \"|\");\n        //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n        //\tLOG.debug(\"guard=|\" + guard + \"|\");\n        //\tLOG.debug(\"actions=|\" + actions + \"|\");\n        //\n        //        // use the name we found to (re)name the transition\n        //\tModelFacade.setName(trans, name);\n        //\n        //// /* The following handles the Event that is the trigger of\n        //// this transition.\n        //// We can distinct between 4 cases:\n        //// 1. A trigger is given. None exists yet.\n        //// 2. The name of the trigger was present, but is (the same or)\n        // altered.\n        //// 3. A trigger is not given. None exists yet.\n        //// 4. The name of the trigger was present, but is removed.\n        //// The reaction in these cases should be:\n        //// 1. Create a new trigger, name it, and hook it to the transition.\n        //// 2. Rename the trigger.\n        //// 3. Nop.\n        //// 4. Unhook and erase the existing trigger.\n        ////\n        //// TODO:\n        //// In fact it could be made even more complicated for case 1:\n        //// If the transition did not have a trigger before,\n        //// a trigger-name is given, and a trigger already\n        //// existed with that name,\n        //// then we have to use the existing trigger object!\n        //// */\n        //        Object evt = ModelFacade.getTrigger(trans);\n        //        boolean created_evt = false;\n        //\tif (trigger.length() > 0) {\n        //            // case 1 and 2\n        //            if (evt == null) {\n        //                // case 1\n        //                if (timeEvent) { // after(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildTimeEvent(s);\n        //                }\n        //                if (changeEvent) { // when(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildChangeEvent(s);\n        //                }\n        //                if (callEvent) { // operation(paramlist)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //\t\t\t            .buildCallEvent(trans, trigger);\n        //                }\n        //                if (signalEvent) { // signalname\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                   .buildSignalEvent(trigger);\n        //                }\n        //                created_evt = true;\n        //            } else {\n        //                // case 2\n        //                if (!ModelFacade.getName(evt).equals(trigger)) {\n        //                    ModelFacade.setName(evt, trigger);\n        //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory()\n        //                            .getStateMachines().buildTimeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (changeEvent && !ModelFacade\n        //                        .isAChangeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory()\n        //                            .getStateMachines().buildChangeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory()\n        //                            .getStateMachines()\n        //                            .buildCallEvent(trans, trigger);\n        //                        created_evt = true;\n        //                    }\n        //                    if (signalEvent && !ModelFacade\n        //                        .isASignalEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory()\n        //                            .getStateMachines()\n        //                            .buildSignalEvent(trigger);\n        //                        created_evt = true;\n        //                    }\n        //                }\n        //            }\n        //            if (created_evt && (evt != null)) {\n        //                StateMachinesHelper.getHelper()\n        //                    .setEventAsTrigger(trans, evt);\n        //                \n        //                /* The next part is explained by the following\n        //                 * quote from the UML spec:\n        //                 * \"The event declaration has scope within\n        //                 * the package it appears in and may be used in\n        //                 * state diagrams for classes that have visibility\n        //                 * inside the package. An event is not local to\n        //                 * a single class.\"\n        //                 */\n        //                Object enclosing = StateMachinesHelper.getHelper()\n        //                                            .getStateMachine(trans);\n        //                while ((!ModelFacade.isAPackage(enclosing))\n        //\t\t       && (enclosing != null)) {\n        //                    enclosing = ModelFacade.getNamespace(enclosing);\n        //\t\t}\n        //                if (enclosing != null) {\n        //\t\t    ModelFacade.setNamespace(evt, enclosing);\n        //\t\t}\n        //            }\n        //\t} else {\n        //            // case 3 and 4\n        //            if (evt == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(evt); // erase it\n        //            }\n        //        }\n        //\n        //\t/* handle the Guard\n        //\tWe can distinct between 4 cases:\n        //        1. A guard is given. None exists yet.\n        //        2. The expression of the guard was present, but is altered.\n        //        3. A guard is not given. None exists yet.\n        //        4. The expression of the guard was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new guard, set its name, language & expression,\n        //\t   and hook it to the transition.\n        //        2. Change the guard's expression. Leave the name & language\n        // untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing guard.\n        //        */\n        //\tObject g = ModelFacade.getGuard(trans);\n        //\tif (guard.length() > 0) {\n        //\t    if (g == null) {\n        //                // case 1\n        //\t        /*TODO: In the next line, I should use buildGuard(),\n        //\t         * but it doesn't show the guard on the diagram...\n        //\t         * Why? (MVW)*/\n        //\t\tg = UmlFactory.getFactory().getStateMachines()\n        //                  .createGuard();\n        //\t\tif (g != null) {\n        //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //\t\t    \t.getDataTypes().createBooleanExpression(\n        //                                                   \"Java\", guard));\n        //\t\t    ModelFacade.setName(g, \"anon\");\n        //\t\t    ModelFacade.setTransition(g, trans);\n        //\t\t    ModelFacade.setGuard(trans, g);\n        //\t\t}\n        //\t    } else {\n        //                // case 2\n        //\t\t\n        //\t\t/* TODO: This does not work! Why not? (MVW)\n        //\t        Object expr = ModelFacade.getExpression(g);\n        //\t\tModelFacade.setBody(expr,guard);\n        //\t\tModelFacade.setExpression(g,expr); */\n        //\t        \n        //\t        //hence a less elegant workaround that works:\n        //\t        String language = ModelFacade.getLanguage(\n        //                  ModelFacade.getExpression(g));\n        //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //                    .getDataTypes().createBooleanExpression(\n        //                                              language, guard));\n        //                /* TODO: In this case, the properties panel \n        //                  is not updated\n        //\t\t    with the changed expression! */\n        //\t    }\n        //\t} else {\n        //\t    if (g == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //\t\tUmlFactory.getFactory().delete(g); // erase it\n        //\t    }\n        //\t}\n        //\n        //        /* handle the Effect (Action)\n        //        We can distinct between 4 cases:\n        //        1. An effect is given. None exists yet.\n        //        2. The expression of the effect was present, but is altered.\n        //        3. An effct is not given. None exists yet.\n        //        4. The expression of the effect was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new CallAction, set its name, language & \n        //        expression, and hook it to the transition.\n        //        2. Change the effect's expression. Leave the actiontype, name \n        //\t  & language untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing effect.\n        //        */\n        //\tObject effect = ModelFacade.getEffect(trans);\n        //\tif (actions.length() > 0) {\n        //\t    if (effect == null) { // case 1\n        //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n        //\t\t    .createCallAction();\n        //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(\n        //                                                   \"Java\", actions));\n        //\t        ModelFacade.setName(effect, \"anon\");\n        //\t        ModelFacade.setEffect(trans, effect);\n        //\t    } else { // case 2\n        //                String language = ModelFacade.getLanguage(ModelFacade\n        //\t\t    .getScript(effect));\n        //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(\n        //                                            language, actions));\n        //\t    }\n        //\t} else { // case 3 & 4\n        //\t    if (effect == null) {\n        //                ;// case 3\n        //            } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(effect); // erase it\n        //            }\n        //\t}\n        //\n        //\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "600eddaf9cea865390e4b08e9a0deceea554bde4": {
            "type": "Ybodychange",
            "commitMessage": "And more style issues.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6270 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "23/07/04 12:19 AM",
            "commitName": "600eddaf9cea865390e4b08e9a0deceea554bde4",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "22/07/04 11:59 PM",
            "commitNameOld": "6cbe80e2ddba3cecca7e049448257da9ca7ff6d1",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,314 +1,319 @@\n     public Object parseTransition(Object trans, String s) {\n         s = s.trim();\n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken();\n             if (nextToken.endsWith(\"]\")) {\n                 guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 }\n                 else\n                     if (s.endsWith(nextToken)) {\n                         actionExpression = nextToken;\n                     }\n             }\n         }\n            \n         if (eventSignature != null) {\n             try {\n                 parseEventSignature(trans, eventSignature);\n             } catch (ParseException e) {\n                 LOG.warn(e);\n             }\n         }\n       \n         if (guardCondition != null) {\n             Object guard = parseGuard(guardCondition.substring(guardCondition\n                     .indexOf('[') + 1));\n             ModelFacade.setGuard(trans, guard);\n         }\n        \n         if (actionExpression != null) {\n             Object action = parseAction(actionExpression.trim());\n             ModelFacade.setEffect(trans, action);\n         }\n         return trans;\n \n+        \n+        // //DO NOT DELETE!\n+        // //MVW: I still need this to help me create \n+        // //the functionality that is now missing!\n+        //\n         //\t// strip any trailing semi-colons\n         //\ts = s.trim();\n         //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n         //\t    s = s.substring(0, s.length() - 1).trim();\n         //\n         //        // strip off the name, and the \":\"\n         //\tString name = \"\";\n         //\tString trigger = \"\";\n         //\tString guard = \"\";\n         //\tString actions = \"\";\n         //\tif (s.indexOf(\":\", 0) > -1) {\n         //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n         //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n         //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n         //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n         //\t        name = s1.trim();\n         //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n         //\t    }\n         //        }\n         //\n         //        // get the guard from between the []\n         //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n         //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n         //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n         //\t\t\t\t\t\t\t     + 1);\n         //\t    s = s.trim();\n         //\t}\n         //\n         //        // everything behind the \"/\" is the action\n         //\tif (s.indexOf(\"/\", 0) > -1) {\n         //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n         //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n         //\t}\n         //\n         //        // and the remainder is the trigger name\n         //\ttrigger = s;\n         //\n         //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n         //\tboolean timeEvent = false;\n         //\tboolean changeEvent = false;\n         //\tboolean callEvent = false;\n         //\tboolean signalEvent = false;\n         //\tString operationName = \"\";\n         //\tif ((s.toLowerCase().startsWith(\"after\"))\n         //\t    && (s.indexOf(\"(\", 0) > -1)\n         //\t    && (s.indexOf(\")\", 0) > -1))\n         //\t{ //s shall contain the TimeExpression\n         //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n         //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n         //\t    timeEvent = true;\n         //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n         //\t\t   && (s.indexOf(\"(\", 0) > -1)\n         //\t\t   && (s.indexOf(\")\", 0) > -1))\n         //\t{ // s shall contain the ChangeExpression\n         //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n         //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n         //\t    changeEvent = true;\n         //\t} else if ((s.indexOf(\"(\", 0) > -1)\n         //            && (s.indexOf(\")\", 0) > -1))\n         //        { // s shall contain the operation\n         //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n         //\t    callEvent = true;\n         //        } else { // s shall contain the signal\n         //            signalEvent = true;\n         //        }\n         //\n         //\tLOG.debug(\"name=|\" + name + \"|\");\n         //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n         //\tLOG.debug(\"guard=|\" + guard + \"|\");\n         //\tLOG.debug(\"actions=|\" + actions + \"|\");\n         //\n         //        // use the name we found to (re)name the transition\n         //\tModelFacade.setName(trans, name);\n         //\n         //// /* The following handles the Event that is the trigger of\n         //// this transition.\n         //// We can distinct between 4 cases:\n         //// 1. A trigger is given. None exists yet.\n         //// 2. The name of the trigger was present, but is (the same or)\n         // altered.\n         //// 3. A trigger is not given. None exists yet.\n         //// 4. The name of the trigger was present, but is removed.\n         //// The reaction in these cases should be:\n         //// 1. Create a new trigger, name it, and hook it to the transition.\n         //// 2. Rename the trigger.\n         //// 3. Nop.\n         //// 4. Unhook and erase the existing trigger.\n         ////\n         //// TODO:\n         //// In fact it could be made even more complicated for case 1:\n         //// If the transition did not have a trigger before,\n         //// a trigger-name is given, and a trigger already\n         //// existed with that name,\n         //// then we have to use the existing trigger object!\n         //// */\n         //        Object evt = ModelFacade.getTrigger(trans);\n         //        boolean created_evt = false;\n         //\tif (trigger.length() > 0) {\n         //            // case 1 and 2\n         //            if (evt == null) {\n         //                // case 1\n         //                if (timeEvent) { // after(...)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildTimeEvent(s);\n         //                }\n         //                if (changeEvent) { // when(...)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildChangeEvent(s);\n         //                }\n         //                if (callEvent) { // operation(paramlist)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //\t\t\t                        .buildCallEvent(trans, trigger);\n         //                }\n         //                if (signalEvent) { // signalname\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildSignalEvent(trigger);\n         //                }\n         //                created_evt = true;\n         //            } else {\n         //                // case 2\n         //                if (!ModelFacade.getName(evt).equals(trigger)) {\n         //                    ModelFacade.setName(evt, trigger);\n         //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildTimeEvent(s);\n         //                        created_evt = true;\n         //                    }\n         //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildChangeEvent(s);\n         //                        created_evt = true;\n         //                    }\n         //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildCallEvent(trans, trigger);\n         //                        created_evt = true;\n         //                    }\n         //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildSignalEvent(trigger);\n         //                        created_evt = true;\n         //                    }\n         //                }\n         //            }\n         //            if (created_evt && (evt != null)) {\n         //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n         //                \n         //                /* The next part is explained by the following\n         //                 * quote from the UML spec:\n         //                 * \"The event declaration has scope within\n         //                 * the package it appears in and may be used in\n         //                 * state diagrams for classes that have visibility\n         //                 * inside the package. An event is not local to\n         //                 * a single class.\"\n         //                 */\n         //                Object enclosing = StateMachinesHelper.getHelper()\n         //                                                .getStateMachine(trans);\n         //                while ((!ModelFacade.isAPackage(enclosing))\n         //\t\t       && (enclosing != null)) {\n         //                    enclosing = ModelFacade.getNamespace(enclosing);\n         //\t\t}\n         //                if (enclosing != null) {\n         //\t\t    ModelFacade.setNamespace(evt, enclosing);\n         //\t\t}\n         //            }\n         //\t} else {\n         //            // case 3 and 4\n         //            if (evt == null) {\n         //                ;// case 3\n         //\t    } else {\n         //                // case 4\n         //                UmlFactory.getFactory().delete(evt); // erase it\n         //            }\n         //        }\n         //\n         //\t/* handle the Guard\n         //\tWe can distinct between 4 cases:\n         //        1. A guard is given. None exists yet.\n         //        2. The expression of the guard was present, but is altered.\n         //        3. A guard is not given. None exists yet.\n         //        4. The expression of the guard was present, but is removed.\n         //        The reaction in these cases should be:\n         //        1. Create a new guard, set its name, language & expression,\n         //\t   and hook it to the transition.\n         //        2. Change the guard's expression. Leave the name & language\n         // untouched.\n         //        3. Nop.\n         //        4. Unhook and erase the existing guard.\n         //        */\n         //\tObject g = ModelFacade.getGuard(trans);\n         //\tif (guard.length() > 0) {\n         //\t    if (g == null) {\n         //                // case 1\n         //\t        /*TODO: In the next line, I should use buildGuard(),\n         //\t         * but it doesn't show the guard on the diagram...\n         //\t         * Why? (MVW)*/\n         //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n         //\t\tif (g != null) {\n         //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n         //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n         //\t\t    ModelFacade.setName(g, \"anon\");\n         //\t\t    ModelFacade.setTransition(g, trans);\n         //\t\t    ModelFacade.setGuard(trans, g);\n         //\t\t}\n         //\t    } else {\n         //                // case 2\n         //\t\t\n         //\t\t/* TODO: This does not work! Why not? (MVW)\n         //\t        Object expr = ModelFacade.getExpression(g);\n         //\t\tModelFacade.setBody(expr,guard);\n         //\t\tModelFacade.setExpression(g,expr); */\n         //\t        \n         //\t        //hence a less elegant workaround that works:\n         //\t        String language =\n         //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n         //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n         //                    .getDataTypes().createBooleanExpression(language, guard));\n         //                /* TODO: In this case, the properties panel is not updated\n         //\t\t    with the changed expression! */\n         //\t    }\n         //\t} else {\n         //\t    if (g == null) {\n         //                ;// case 3\n         //\t    } else {\n         //                // case 4\n         //\t\tUmlFactory.getFactory().delete(g); // erase it\n         //\t    }\n         //\t}\n         //\n         //        /* handle the Effect (Action)\n         //        We can distinct between 4 cases:\n         //        1. An effect is given. None exists yet.\n         //        2. The expression of the effect was present, but is altered.\n         //        3. An effct is not given. None exists yet.\n         //        4. The expression of the effect was present, but is removed.\n         //        The reaction in these cases should be:\n         //        1. Create a new CallAction, set its name, language & expression,\n         //        and hook it to the transition.\n         //        2. Change the effect's expression. Leave the actiontype, name &\n         //\tlanguage untouched.\n         //        3. Nop.\n         //        4. Unhook and erase the existing effect.\n         //        */\n         //\tObject effect = ModelFacade.getEffect(trans);\n         //\tif (actions.length() > 0) {\n         //\t    if (effect == null) { // case 1\n         //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n         //\t\t    .createCallAction();\n         //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n         //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n         //\t        ModelFacade.setName(effect, \"anon\");\n         //\t        ModelFacade.setEffect(trans, effect);\n         //\t    } else { // case 2\n         //                String language = ModelFacade.getLanguage(ModelFacade\n         //\t\t    .getScript(effect));\n         //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n         //\t\t    .getDataTypes().createActionExpression(language, actions));\n         //\t    }\n         //\t} else { // case 3 & 4\n         //\t    if (effect == null) {\n         //                ;// case 3\n         //            } else {\n         //                // case 4\n         //                UmlFactory.getFactory().delete(effect); // erase it\n         //            }\n         //\t}\n         //\n         //\treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n        s = s.trim();\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                }\n                else\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n            }\n        }\n           \n        if (eventSignature != null) {\n            try {\n                parseEventSignature(trans, eventSignature);\n            } catch (ParseException e) {\n                LOG.warn(e);\n            }\n        }\n      \n        if (guardCondition != null) {\n            Object guard = parseGuard(guardCondition.substring(guardCondition\n                    .indexOf('[') + 1));\n            ModelFacade.setGuard(trans, guard);\n        }\n       \n        if (actionExpression != null) {\n            Object action = parseAction(actionExpression.trim());\n            ModelFacade.setEffect(trans, action);\n        }\n        return trans;\n\n        \n        // //DO NOT DELETE!\n        // //MVW: I still need this to help me create \n        // //the functionality that is now missing!\n        //\n        //\t// strip any trailing semi-colons\n        //\ts = s.trim();\n        //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n        //\t    s = s.substring(0, s.length() - 1).trim();\n        //\n        //        // strip off the name, and the \":\"\n        //\tString name = \"\";\n        //\tString trigger = \"\";\n        //\tString guard = \"\";\n        //\tString actions = \"\";\n        //\tif (s.indexOf(\":\", 0) > -1) {\n        //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n        //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n        //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n        //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n        //\t        name = s1.trim();\n        //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n        //\t    }\n        //        }\n        //\n        //        // get the guard from between the []\n        //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n        //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n        //\t\t\t\t\t\t\t     + 1);\n        //\t    s = s.trim();\n        //\t}\n        //\n        //        // everything behind the \"/\" is the action\n        //\tif (s.indexOf(\"/\", 0) > -1) {\n        //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n        //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n        //\t}\n        //\n        //        // and the remainder is the trigger name\n        //\ttrigger = s;\n        //\n        //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n        //\tboolean timeEvent = false;\n        //\tboolean changeEvent = false;\n        //\tboolean callEvent = false;\n        //\tboolean signalEvent = false;\n        //\tString operationName = \"\";\n        //\tif ((s.toLowerCase().startsWith(\"after\"))\n        //\t    && (s.indexOf(\"(\", 0) > -1)\n        //\t    && (s.indexOf(\")\", 0) > -1))\n        //\t{ //s shall contain the TimeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    timeEvent = true;\n        //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n        //\t\t   && (s.indexOf(\"(\", 0) > -1)\n        //\t\t   && (s.indexOf(\")\", 0) > -1))\n        //\t{ // s shall contain the ChangeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    changeEvent = true;\n        //\t} else if ((s.indexOf(\"(\", 0) > -1)\n        //            && (s.indexOf(\")\", 0) > -1))\n        //        { // s shall contain the operation\n        //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n        //\t    callEvent = true;\n        //        } else { // s shall contain the signal\n        //            signalEvent = true;\n        //        }\n        //\n        //\tLOG.debug(\"name=|\" + name + \"|\");\n        //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n        //\tLOG.debug(\"guard=|\" + guard + \"|\");\n        //\tLOG.debug(\"actions=|\" + actions + \"|\");\n        //\n        //        // use the name we found to (re)name the transition\n        //\tModelFacade.setName(trans, name);\n        //\n        //// /* The following handles the Event that is the trigger of\n        //// this transition.\n        //// We can distinct between 4 cases:\n        //// 1. A trigger is given. None exists yet.\n        //// 2. The name of the trigger was present, but is (the same or)\n        // altered.\n        //// 3. A trigger is not given. None exists yet.\n        //// 4. The name of the trigger was present, but is removed.\n        //// The reaction in these cases should be:\n        //// 1. Create a new trigger, name it, and hook it to the transition.\n        //// 2. Rename the trigger.\n        //// 3. Nop.\n        //// 4. Unhook and erase the existing trigger.\n        ////\n        //// TODO:\n        //// In fact it could be made even more complicated for case 1:\n        //// If the transition did not have a trigger before,\n        //// a trigger-name is given, and a trigger already\n        //// existed with that name,\n        //// then we have to use the existing trigger object!\n        //// */\n        //        Object evt = ModelFacade.getTrigger(trans);\n        //        boolean created_evt = false;\n        //\tif (trigger.length() > 0) {\n        //            // case 1 and 2\n        //            if (evt == null) {\n        //                // case 1\n        //                if (timeEvent) { // after(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildTimeEvent(s);\n        //                }\n        //                if (changeEvent) { // when(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildChangeEvent(s);\n        //                }\n        //                if (callEvent) { // operation(paramlist)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //\t\t\t                        .buildCallEvent(trans, trigger);\n        //                }\n        //                if (signalEvent) { // signalname\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildSignalEvent(trigger);\n        //                }\n        //                created_evt = true;\n        //            } else {\n        //                // case 2\n        //                if (!ModelFacade.getName(evt).equals(trigger)) {\n        //                    ModelFacade.setName(evt, trigger);\n        //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildTimeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildChangeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildCallEvent(trans, trigger);\n        //                        created_evt = true;\n        //                    }\n        //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildSignalEvent(trigger);\n        //                        created_evt = true;\n        //                    }\n        //                }\n        //            }\n        //            if (created_evt && (evt != null)) {\n        //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n        //                \n        //                /* The next part is explained by the following\n        //                 * quote from the UML spec:\n        //                 * \"The event declaration has scope within\n        //                 * the package it appears in and may be used in\n        //                 * state diagrams for classes that have visibility\n        //                 * inside the package. An event is not local to\n        //                 * a single class.\"\n        //                 */\n        //                Object enclosing = StateMachinesHelper.getHelper()\n        //                                                .getStateMachine(trans);\n        //                while ((!ModelFacade.isAPackage(enclosing))\n        //\t\t       && (enclosing != null)) {\n        //                    enclosing = ModelFacade.getNamespace(enclosing);\n        //\t\t}\n        //                if (enclosing != null) {\n        //\t\t    ModelFacade.setNamespace(evt, enclosing);\n        //\t\t}\n        //            }\n        //\t} else {\n        //            // case 3 and 4\n        //            if (evt == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(evt); // erase it\n        //            }\n        //        }\n        //\n        //\t/* handle the Guard\n        //\tWe can distinct between 4 cases:\n        //        1. A guard is given. None exists yet.\n        //        2. The expression of the guard was present, but is altered.\n        //        3. A guard is not given. None exists yet.\n        //        4. The expression of the guard was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new guard, set its name, language & expression,\n        //\t   and hook it to the transition.\n        //        2. Change the guard's expression. Leave the name & language\n        // untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing guard.\n        //        */\n        //\tObject g = ModelFacade.getGuard(trans);\n        //\tif (guard.length() > 0) {\n        //\t    if (g == null) {\n        //                // case 1\n        //\t        /*TODO: In the next line, I should use buildGuard(),\n        //\t         * but it doesn't show the guard on the diagram...\n        //\t         * Why? (MVW)*/\n        //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n        //\t\tif (g != null) {\n        //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n        //\t\t    ModelFacade.setName(g, \"anon\");\n        //\t\t    ModelFacade.setTransition(g, trans);\n        //\t\t    ModelFacade.setGuard(trans, g);\n        //\t\t}\n        //\t    } else {\n        //                // case 2\n        //\t\t\n        //\t\t/* TODO: This does not work! Why not? (MVW)\n        //\t        Object expr = ModelFacade.getExpression(g);\n        //\t\tModelFacade.setBody(expr,guard);\n        //\t\tModelFacade.setExpression(g,expr); */\n        //\t        \n        //\t        //hence a less elegant workaround that works:\n        //\t        String language =\n        //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n        //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //                    .getDataTypes().createBooleanExpression(language, guard));\n        //                /* TODO: In this case, the properties panel is not updated\n        //\t\t    with the changed expression! */\n        //\t    }\n        //\t} else {\n        //\t    if (g == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //\t\tUmlFactory.getFactory().delete(g); // erase it\n        //\t    }\n        //\t}\n        //\n        //        /* handle the Effect (Action)\n        //        We can distinct between 4 cases:\n        //        1. An effect is given. None exists yet.\n        //        2. The expression of the effect was present, but is altered.\n        //        3. An effct is not given. None exists yet.\n        //        4. The expression of the effect was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new CallAction, set its name, language & expression,\n        //        and hook it to the transition.\n        //        2. Change the effect's expression. Leave the actiontype, name &\n        //\tlanguage untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing effect.\n        //        */\n        //\tObject effect = ModelFacade.getEffect(trans);\n        //\tif (actions.length() > 0) {\n        //\t    if (effect == null) { // case 1\n        //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n        //\t\t    .createCallAction();\n        //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n        //\t        ModelFacade.setName(effect, \"anon\");\n        //\t        ModelFacade.setEffect(trans, effect);\n        //\t    } else { // case 2\n        //                String language = ModelFacade.getLanguage(ModelFacade\n        //\t\t    .getScript(effect));\n        //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(language, actions));\n        //\t    }\n        //\t} else { // case 3 & 4\n        //\t    if (effect == null) {\n        //                ;// case 3\n        //            } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(effect); // erase it\n        //            }\n        //\t}\n        //\n        //\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "6cbe80e2ddba3cecca7e049448257da9ca7ff6d1": {
            "type": "Ybodychange",
            "commitMessage": "Style issues.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6269 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "22/07/04 11:59 PM",
            "commitName": "6cbe80e2ddba3cecca7e049448257da9ca7ff6d1",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "17/07/04 6:10 AM",
            "commitNameOld": "810f0276a2096afe79bdecf668efbca7d62e28ca",
            "commitAuthorOld": "Jaap Branderhorst",
            "daysBetweenCommits": 5.74,
            "commitsBetweenForRepo": 88,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,314 +1,314 @@\n     public Object parseTransition(Object trans, String s) {\n         s = s.trim();\n         StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n         String eventSignature = null;\n         String guardCondition = null;\n         String actionExpression = null;\n         while (tokenizer.hasMoreTokens()) {\n             String nextToken = tokenizer.nextToken();\n             if (nextToken.endsWith(\"]\")) {\n-                guardCondition = nextToken.substring(0, nextToken.length() -1);\n+                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n             } else {\n                 if (s.startsWith(nextToken)) {\n                     eventSignature = nextToken;\n                 }\n                 else\n-                if (s.endsWith(nextToken)) {\n-                    actionExpression = nextToken;\n-                }\n+                    if (s.endsWith(nextToken)) {\n+                        actionExpression = nextToken;\n+                    }\n             }\n         }\n            \n         if (eventSignature != null) {\n             try {\n                 parseEventSignature(trans, eventSignature);\n             } catch (ParseException e) {\n-                _cat.warn(e);\n+                LOG.warn(e);\n             }\n         }\n       \n         if (guardCondition != null) {\n             Object guard = parseGuard(guardCondition.substring(guardCondition\n                     .indexOf('[') + 1));\n             ModelFacade.setGuard(trans, guard);\n         }\n        \n         if (actionExpression != null) {\n             Object action = parseAction(actionExpression.trim());\n             ModelFacade.setEffect(trans, action);\n         }\n         return trans;\n \n         //\t// strip any trailing semi-colons\n         //\ts = s.trim();\n         //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n         //\t    s = s.substring(0, s.length() - 1).trim();\n         //\n         //        // strip off the name, and the \":\"\n         //\tString name = \"\";\n         //\tString trigger = \"\";\n         //\tString guard = \"\";\n         //\tString actions = \"\";\n         //\tif (s.indexOf(\":\", 0) > -1) {\n         //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n         //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n         //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n         //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n         //\t        name = s1.trim();\n         //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n         //\t    }\n         //        }\n         //\n         //        // get the guard from between the []\n         //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n         //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n         //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n         //\t\t\t\t\t\t\t     + 1);\n         //\t    s = s.trim();\n         //\t}\n         //\n         //        // everything behind the \"/\" is the action\n         //\tif (s.indexOf(\"/\", 0) > -1) {\n         //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n         //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n         //\t}\n         //\n         //        // and the remainder is the trigger name\n         //\ttrigger = s;\n         //\n         //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n         //\tboolean timeEvent = false;\n         //\tboolean changeEvent = false;\n         //\tboolean callEvent = false;\n         //\tboolean signalEvent = false;\n         //\tString operationName = \"\";\n         //\tif ((s.toLowerCase().startsWith(\"after\"))\n         //\t    && (s.indexOf(\"(\", 0) > -1)\n         //\t    && (s.indexOf(\")\", 0) > -1))\n         //\t{ //s shall contain the TimeExpression\n         //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n         //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n         //\t    timeEvent = true;\n         //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n         //\t\t   && (s.indexOf(\"(\", 0) > -1)\n         //\t\t   && (s.indexOf(\")\", 0) > -1))\n         //\t{ // s shall contain the ChangeExpression\n         //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n         //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n         //\t    changeEvent = true;\n         //\t} else if ((s.indexOf(\"(\", 0) > -1)\n         //            && (s.indexOf(\")\", 0) > -1))\n         //        { // s shall contain the operation\n         //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n         //\t    callEvent = true;\n         //        } else { // s shall contain the signal\n         //            signalEvent = true;\n         //        }\n         //\n         //\tLOG.debug(\"name=|\" + name + \"|\");\n         //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n         //\tLOG.debug(\"guard=|\" + guard + \"|\");\n         //\tLOG.debug(\"actions=|\" + actions + \"|\");\n         //\n         //        // use the name we found to (re)name the transition\n         //\tModelFacade.setName(trans, name);\n         //\n         //// /* The following handles the Event that is the trigger of\n         //// this transition.\n         //// We can distinct between 4 cases:\n         //// 1. A trigger is given. None exists yet.\n         //// 2. The name of the trigger was present, but is (the same or)\n         // altered.\n         //// 3. A trigger is not given. None exists yet.\n         //// 4. The name of the trigger was present, but is removed.\n         //// The reaction in these cases should be:\n         //// 1. Create a new trigger, name it, and hook it to the transition.\n         //// 2. Rename the trigger.\n         //// 3. Nop.\n         //// 4. Unhook and erase the existing trigger.\n         ////\n         //// TODO:\n         //// In fact it could be made even more complicated for case 1:\n         //// If the transition did not have a trigger before,\n         //// a trigger-name is given, and a trigger already\n         //// existed with that name,\n         //// then we have to use the existing trigger object!\n         //// */\n         //        Object evt = ModelFacade.getTrigger(trans);\n         //        boolean created_evt = false;\n         //\tif (trigger.length() > 0) {\n         //            // case 1 and 2\n         //            if (evt == null) {\n         //                // case 1\n         //                if (timeEvent) { // after(...)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildTimeEvent(s);\n         //                }\n         //                if (changeEvent) { // when(...)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildChangeEvent(s);\n         //                }\n         //                if (callEvent) { // operation(paramlist)\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //\t\t\t                        .buildCallEvent(trans, trigger);\n         //                }\n         //                if (signalEvent) { // signalname\n         //                    evt = UmlFactory.getFactory().getStateMachines()\n         //                                                .buildSignalEvent(trigger);\n         //                }\n         //                created_evt = true;\n         //            } else {\n         //                // case 2\n         //                if (!ModelFacade.getName(evt).equals(trigger)) {\n         //                    ModelFacade.setName(evt, trigger);\n         //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildTimeEvent(s);\n         //                        created_evt = true;\n         //                    }\n         //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildChangeEvent(s);\n         //                        created_evt = true;\n         //                    }\n         //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildCallEvent(trans, trigger);\n         //                        created_evt = true;\n         //                    }\n         //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n         //                        UmlFactory.getFactory().delete(evt);\n         //                        evt = UmlFactory.getFactory().getStateMachines()\n         //                            .buildSignalEvent(trigger);\n         //                        created_evt = true;\n         //                    }\n         //                }\n         //            }\n         //            if (created_evt && (evt != null)) {\n         //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n         //                \n         //                /* The next part is explained by the following\n         //                 * quote from the UML spec:\n         //                 * \"The event declaration has scope within\n         //                 * the package it appears in and may be used in\n         //                 * state diagrams for classes that have visibility\n         //                 * inside the package. An event is not local to\n         //                 * a single class.\"\n         //                 */\n         //                Object enclosing = StateMachinesHelper.getHelper()\n         //                                                .getStateMachine(trans);\n         //                while ((!ModelFacade.isAPackage(enclosing))\n         //\t\t       && (enclosing != null)) {\n         //                    enclosing = ModelFacade.getNamespace(enclosing);\n         //\t\t}\n         //                if (enclosing != null) {\n         //\t\t    ModelFacade.setNamespace(evt, enclosing);\n         //\t\t}\n         //            }\n         //\t} else {\n         //            // case 3 and 4\n         //            if (evt == null) {\n         //                ;// case 3\n         //\t    } else {\n         //                // case 4\n         //                UmlFactory.getFactory().delete(evt); // erase it\n         //            }\n         //        }\n         //\n         //\t/* handle the Guard\n         //\tWe can distinct between 4 cases:\n         //        1. A guard is given. None exists yet.\n         //        2. The expression of the guard was present, but is altered.\n         //        3. A guard is not given. None exists yet.\n         //        4. The expression of the guard was present, but is removed.\n         //        The reaction in these cases should be:\n         //        1. Create a new guard, set its name, language & expression,\n         //\t   and hook it to the transition.\n         //        2. Change the guard's expression. Leave the name & language\n         // untouched.\n         //        3. Nop.\n         //        4. Unhook and erase the existing guard.\n         //        */\n         //\tObject g = ModelFacade.getGuard(trans);\n         //\tif (guard.length() > 0) {\n         //\t    if (g == null) {\n         //                // case 1\n         //\t        /*TODO: In the next line, I should use buildGuard(),\n         //\t         * but it doesn't show the guard on the diagram...\n         //\t         * Why? (MVW)*/\n         //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n         //\t\tif (g != null) {\n         //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n         //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n         //\t\t    ModelFacade.setName(g, \"anon\");\n         //\t\t    ModelFacade.setTransition(g, trans);\n         //\t\t    ModelFacade.setGuard(trans, g);\n         //\t\t}\n         //\t    } else {\n         //                // case 2\n         //\t\t\n         //\t\t/* TODO: This does not work! Why not? (MVW)\n         //\t        Object expr = ModelFacade.getExpression(g);\n         //\t\tModelFacade.setBody(expr,guard);\n         //\t\tModelFacade.setExpression(g,expr); */\n         //\t        \n         //\t        //hence a less elegant workaround that works:\n         //\t        String language =\n         //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n         //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n         //                    .getDataTypes().createBooleanExpression(language, guard));\n         //                /* TODO: In this case, the properties panel is not updated\n         //\t\t    with the changed expression! */\n         //\t    }\n         //\t} else {\n         //\t    if (g == null) {\n         //                ;// case 3\n         //\t    } else {\n         //                // case 4\n         //\t\tUmlFactory.getFactory().delete(g); // erase it\n         //\t    }\n         //\t}\n         //\n         //        /* handle the Effect (Action)\n         //        We can distinct between 4 cases:\n         //        1. An effect is given. None exists yet.\n         //        2. The expression of the effect was present, but is altered.\n         //        3. An effct is not given. None exists yet.\n         //        4. The expression of the effect was present, but is removed.\n         //        The reaction in these cases should be:\n         //        1. Create a new CallAction, set its name, language & expression,\n         //        and hook it to the transition.\n         //        2. Change the effect's expression. Leave the actiontype, name &\n         //\tlanguage untouched.\n         //        3. Nop.\n         //        4. Unhook and erase the existing effect.\n         //        */\n         //\tObject effect = ModelFacade.getEffect(trans);\n         //\tif (actions.length() > 0) {\n         //\t    if (effect == null) { // case 1\n         //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n         //\t\t    .createCallAction();\n         //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n         //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n         //\t        ModelFacade.setName(effect, \"anon\");\n         //\t        ModelFacade.setEffect(trans, effect);\n         //\t    } else { // case 2\n         //                String language = ModelFacade.getLanguage(ModelFacade\n         //\t\t    .getScript(effect));\n         //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n         //\t\t    .getDataTypes().createActionExpression(language, actions));\n         //\t    }\n         //\t} else { // case 3 & 4\n         //\t    if (effect == null) {\n         //                ;// case 3\n         //            } else {\n         //                // case 4\n         //                UmlFactory.getFactory().delete(effect); // erase it\n         //            }\n         //\t}\n         //\n         //\treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n        s = s.trim();\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() - 1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                }\n                else\n                    if (s.endsWith(nextToken)) {\n                        actionExpression = nextToken;\n                    }\n            }\n        }\n           \n        if (eventSignature != null) {\n            try {\n                parseEventSignature(trans, eventSignature);\n            } catch (ParseException e) {\n                LOG.warn(e);\n            }\n        }\n      \n        if (guardCondition != null) {\n            Object guard = parseGuard(guardCondition.substring(guardCondition\n                    .indexOf('[') + 1));\n            ModelFacade.setGuard(trans, guard);\n        }\n       \n        if (actionExpression != null) {\n            Object action = parseAction(actionExpression.trim());\n            ModelFacade.setEffect(trans, action);\n        }\n        return trans;\n\n        //\t// strip any trailing semi-colons\n        //\ts = s.trim();\n        //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n        //\t    s = s.substring(0, s.length() - 1).trim();\n        //\n        //        // strip off the name, and the \":\"\n        //\tString name = \"\";\n        //\tString trigger = \"\";\n        //\tString guard = \"\";\n        //\tString actions = \"\";\n        //\tif (s.indexOf(\":\", 0) > -1) {\n        //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n        //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n        //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n        //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n        //\t        name = s1.trim();\n        //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n        //\t    }\n        //        }\n        //\n        //        // get the guard from between the []\n        //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n        //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n        //\t\t\t\t\t\t\t     + 1);\n        //\t    s = s.trim();\n        //\t}\n        //\n        //        // everything behind the \"/\" is the action\n        //\tif (s.indexOf(\"/\", 0) > -1) {\n        //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n        //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n        //\t}\n        //\n        //        // and the remainder is the trigger name\n        //\ttrigger = s;\n        //\n        //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n        //\tboolean timeEvent = false;\n        //\tboolean changeEvent = false;\n        //\tboolean callEvent = false;\n        //\tboolean signalEvent = false;\n        //\tString operationName = \"\";\n        //\tif ((s.toLowerCase().startsWith(\"after\"))\n        //\t    && (s.indexOf(\"(\", 0) > -1)\n        //\t    && (s.indexOf(\")\", 0) > -1))\n        //\t{ //s shall contain the TimeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    timeEvent = true;\n        //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n        //\t\t   && (s.indexOf(\"(\", 0) > -1)\n        //\t\t   && (s.indexOf(\")\", 0) > -1))\n        //\t{ // s shall contain the ChangeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    changeEvent = true;\n        //\t} else if ((s.indexOf(\"(\", 0) > -1)\n        //            && (s.indexOf(\")\", 0) > -1))\n        //        { // s shall contain the operation\n        //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n        //\t    callEvent = true;\n        //        } else { // s shall contain the signal\n        //            signalEvent = true;\n        //        }\n        //\n        //\tLOG.debug(\"name=|\" + name + \"|\");\n        //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n        //\tLOG.debug(\"guard=|\" + guard + \"|\");\n        //\tLOG.debug(\"actions=|\" + actions + \"|\");\n        //\n        //        // use the name we found to (re)name the transition\n        //\tModelFacade.setName(trans, name);\n        //\n        //// /* The following handles the Event that is the trigger of\n        //// this transition.\n        //// We can distinct between 4 cases:\n        //// 1. A trigger is given. None exists yet.\n        //// 2. The name of the trigger was present, but is (the same or)\n        // altered.\n        //// 3. A trigger is not given. None exists yet.\n        //// 4. The name of the trigger was present, but is removed.\n        //// The reaction in these cases should be:\n        //// 1. Create a new trigger, name it, and hook it to the transition.\n        //// 2. Rename the trigger.\n        //// 3. Nop.\n        //// 4. Unhook and erase the existing trigger.\n        ////\n        //// TODO:\n        //// In fact it could be made even more complicated for case 1:\n        //// If the transition did not have a trigger before,\n        //// a trigger-name is given, and a trigger already\n        //// existed with that name,\n        //// then we have to use the existing trigger object!\n        //// */\n        //        Object evt = ModelFacade.getTrigger(trans);\n        //        boolean created_evt = false;\n        //\tif (trigger.length() > 0) {\n        //            // case 1 and 2\n        //            if (evt == null) {\n        //                // case 1\n        //                if (timeEvent) { // after(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildTimeEvent(s);\n        //                }\n        //                if (changeEvent) { // when(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildChangeEvent(s);\n        //                }\n        //                if (callEvent) { // operation(paramlist)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //\t\t\t                        .buildCallEvent(trans, trigger);\n        //                }\n        //                if (signalEvent) { // signalname\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildSignalEvent(trigger);\n        //                }\n        //                created_evt = true;\n        //            } else {\n        //                // case 2\n        //                if (!ModelFacade.getName(evt).equals(trigger)) {\n        //                    ModelFacade.setName(evt, trigger);\n        //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildTimeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildChangeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildCallEvent(trans, trigger);\n        //                        created_evt = true;\n        //                    }\n        //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildSignalEvent(trigger);\n        //                        created_evt = true;\n        //                    }\n        //                }\n        //            }\n        //            if (created_evt && (evt != null)) {\n        //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n        //                \n        //                /* The next part is explained by the following\n        //                 * quote from the UML spec:\n        //                 * \"The event declaration has scope within\n        //                 * the package it appears in and may be used in\n        //                 * state diagrams for classes that have visibility\n        //                 * inside the package. An event is not local to\n        //                 * a single class.\"\n        //                 */\n        //                Object enclosing = StateMachinesHelper.getHelper()\n        //                                                .getStateMachine(trans);\n        //                while ((!ModelFacade.isAPackage(enclosing))\n        //\t\t       && (enclosing != null)) {\n        //                    enclosing = ModelFacade.getNamespace(enclosing);\n        //\t\t}\n        //                if (enclosing != null) {\n        //\t\t    ModelFacade.setNamespace(evt, enclosing);\n        //\t\t}\n        //            }\n        //\t} else {\n        //            // case 3 and 4\n        //            if (evt == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(evt); // erase it\n        //            }\n        //        }\n        //\n        //\t/* handle the Guard\n        //\tWe can distinct between 4 cases:\n        //        1. A guard is given. None exists yet.\n        //        2. The expression of the guard was present, but is altered.\n        //        3. A guard is not given. None exists yet.\n        //        4. The expression of the guard was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new guard, set its name, language & expression,\n        //\t   and hook it to the transition.\n        //        2. Change the guard's expression. Leave the name & language\n        // untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing guard.\n        //        */\n        //\tObject g = ModelFacade.getGuard(trans);\n        //\tif (guard.length() > 0) {\n        //\t    if (g == null) {\n        //                // case 1\n        //\t        /*TODO: In the next line, I should use buildGuard(),\n        //\t         * but it doesn't show the guard on the diagram...\n        //\t         * Why? (MVW)*/\n        //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n        //\t\tif (g != null) {\n        //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n        //\t\t    ModelFacade.setName(g, \"anon\");\n        //\t\t    ModelFacade.setTransition(g, trans);\n        //\t\t    ModelFacade.setGuard(trans, g);\n        //\t\t}\n        //\t    } else {\n        //                // case 2\n        //\t\t\n        //\t\t/* TODO: This does not work! Why not? (MVW)\n        //\t        Object expr = ModelFacade.getExpression(g);\n        //\t\tModelFacade.setBody(expr,guard);\n        //\t\tModelFacade.setExpression(g,expr); */\n        //\t        \n        //\t        //hence a less elegant workaround that works:\n        //\t        String language =\n        //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n        //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //                    .getDataTypes().createBooleanExpression(language, guard));\n        //                /* TODO: In this case, the properties panel is not updated\n        //\t\t    with the changed expression! */\n        //\t    }\n        //\t} else {\n        //\t    if (g == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //\t\tUmlFactory.getFactory().delete(g); // erase it\n        //\t    }\n        //\t}\n        //\n        //        /* handle the Effect (Action)\n        //        We can distinct between 4 cases:\n        //        1. An effect is given. None exists yet.\n        //        2. The expression of the effect was present, but is altered.\n        //        3. An effct is not given. None exists yet.\n        //        4. The expression of the effect was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new CallAction, set its name, language & expression,\n        //        and hook it to the transition.\n        //        2. Change the effect's expression. Leave the actiontype, name &\n        //\tlanguage untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing effect.\n        //        */\n        //\tObject effect = ModelFacade.getEffect(trans);\n        //\tif (actions.length() > 0) {\n        //\t    if (effect == null) { // case 1\n        //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n        //\t\t    .createCallAction();\n        //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n        //\t        ModelFacade.setName(effect, \"anon\");\n        //\t        ModelFacade.setEffect(trans, effect);\n        //\t    } else { // case 2\n        //                String language = ModelFacade.getLanguage(ModelFacade\n        //\t\t    .getScript(effect));\n        //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(language, actions));\n        //\t    }\n        //\t} else { // case 3 & 4\n        //\t    if (effect == null) {\n        //                ;// case 3\n        //            } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(effect); // erase it\n        //            }\n        //\t}\n        //\n        //\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "810f0276a2096afe79bdecf668efbca7d62e28ca": {
            "type": "Ybodychange",
            "commitMessage": "Following issues should be solved with this commit:\n686\n713\n1187\n1188\n1761\n1820\n1835\n2034\n2159\n2295\n2427\n2709\n2710\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6181 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "17/07/04 6:10 AM",
            "commitName": "810f0276a2096afe79bdecf668efbca7d62e28ca",
            "commitAuthor": "Jaap Branderhorst",
            "commitDateOld": "23/06/04 11:28 PM",
            "commitNameOld": "10f720ae95053d75e83e5eac408e731094ec2257",
            "commitAuthorOld": "Linus Tolke",
            "daysBetweenCommits": 23.28,
            "commitsBetweenForRepo": 84,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,272 +1,314 @@\n     public Object parseTransition(Object trans, String s) {\n-\t// strip any trailing semi-colons\n-\ts = s.trim();\n-\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n-\t    s = s.substring(0, s.length() - 1).trim();\n-\n-        // strip off the name, and the \":\"\n-\tString name = \"\";\n-\tString trigger = \"\";\n-\tString guard = \"\";\n-\tString actions = \"\";\n-\tif (s.indexOf(\":\", 0) > -1) {\n-\t    String s1 = s.substring(0, s.indexOf(\":\"));\n-\t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n-\t    /* the name may not contain a \"/\", for when the action contains a \":\" */\n-\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) { \n-\t        name = s1.trim();\n-\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n-\t    }  \n-        }\n-\n-        // get the guard from between the []\n-\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n-\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n-\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n-\t\t\t\t\t\t\t     + 1);\n-\t    s = s.trim();\n-\t}\n-\n-        // everything behind the \"/\" is the action\n-\tif (s.indexOf(\"/\", 0) > -1) {\n-\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n-\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n-\t}\n-\n-        // and the remainder is the trigger name\n-\ttrigger = s;\n-\n-\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n-\tboolean timeEvent = false;\n-\tboolean changeEvent = false;\n-\tboolean callEvent = false;\n-\tboolean signalEvent = false;\n-\tString operationName = \"\";\n-\tif ((s.toLowerCase().startsWith(\"after\")) \n-\t    && (s.indexOf(\"(\", 0) > -1)\n-\t    && (s.indexOf(\")\", 0) > -1)) \n-\t{   //s shall contain the TimeExpression\n-\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n-\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n-\t    timeEvent = true;\n-\t} else if ((s.toLowerCase().startsWith(\"when\")) \n-\t\t   && (s.indexOf(\"(\", 0) > -1)\n-\t\t   && (s.indexOf(\")\", 0) > -1))\n-\t{   // s shall contain the ChangeExpression\n-\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n-\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n-\t    changeEvent = true;\n-\t} else if ((s.indexOf(\"(\", 0) > -1)\n-            && (s.indexOf(\")\", 0) > -1))\n-        {   // s shall contain the operation \n-\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n-\t    callEvent = true;\n-        } else { // s shall contain the signal \n-            signalEvent = true;\n-        }\n-\n-\tLOG.debug(\"name=|\" + name + \"|\");\n-\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n-\tLOG.debug(\"guard=|\" + guard + \"|\");\n-\tLOG.debug(\"actions=|\" + actions + \"|\");\n-\n-        // use the name we found to (re)name the transition\n-\tModelFacade.setName(trans, name);\n-\n-        /* The following handles the Event that is the trigger of\n-        this transition. \n-        We can distinct between 4 cases:\n-        1. A trigger is given. None exists yet.\n-        2. The name of the trigger was present, but is (the same or) altered.\n-        3. A trigger is not given. None exists yet.\n-        4. The name of the trigger was present, but is removed.\n-        The reaction in these cases should be:\n-        1. Create a new trigger, name it, and hook it to the transition.\n-        2. Rename the trigger.\n-        3. Nop.\n-        4. Unhook and erase the existing trigger.\n-        \n-        TODO:\n-        In fact it could be made even more complicated for case 1:\n-        If the transition did not have a trigger before, \n-        a trigger-name is given, and a trigger already\n-        existed with that name,\n-        then we have to use the existing trigger object!\n-        */\n-        Object evt = ModelFacade.getTrigger(trans);\n-        boolean created_evt = false;\n-\tif (trigger.length() > 0) {\n-            // case 1 and 2\n-            if (evt == null) {\n-                // case 1\n-                if (timeEvent) { // after(...)\n-                    evt = UmlFactory.getFactory().getStateMachines()\n-                                                .buildTimeEvent(s);\n-                }\n-                if (changeEvent) {  // when(...)\n-                    evt = UmlFactory.getFactory().getStateMachines()\n-                                                .buildChangeEvent(s);\n-                }\n-                if (callEvent) {  // operation(paramlist)\n-                    evt = UmlFactory.getFactory().getStateMachines()\n-\t\t\t                        .buildCallEvent(trans, trigger);\n-                }\n-                if (signalEvent) {  // signalname\n-                    evt = UmlFactory.getFactory().getStateMachines()\n-                                                .buildSignalEvent(trigger);\n-                }\n-                created_evt = true;\n+        s = s.trim();\n+        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n+        String eventSignature = null;\n+        String guardCondition = null;\n+        String actionExpression = null;\n+        while (tokenizer.hasMoreTokens()) {\n+            String nextToken = tokenizer.nextToken();\n+            if (nextToken.endsWith(\"]\")) {\n+                guardCondition = nextToken.substring(0, nextToken.length() -1);\n             } else {\n-                // case 2\n-                if (!ModelFacade.getName(evt).equals(trigger)) {\n-                    ModelFacade.setName(evt, trigger);\n-                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n-                        UmlFactory.getFactory().delete(evt);\n-                        evt = UmlFactory.getFactory().getStateMachines()\n-                            .buildTimeEvent(s);\n-                        created_evt = true;\n-                    }\n-                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n-                        UmlFactory.getFactory().delete(evt);\n-                        evt = UmlFactory.getFactory().getStateMachines()\n-                            .buildChangeEvent(s);\n-                        created_evt = true;\n-                    }\n-                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n-                        UmlFactory.getFactory().delete(evt);\n-                        evt = UmlFactory.getFactory().getStateMachines()\n-                            .buildCallEvent(trans, trigger);\n-                        created_evt = true;\n-                    }\n-                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n-                        UmlFactory.getFactory().delete(evt);\n-                        evt = UmlFactory.getFactory().getStateMachines()\n-                            .buildSignalEvent(trigger);\n-                        created_evt = true;\n-                    }\n+                if (s.startsWith(nextToken)) {\n+                    eventSignature = nextToken;\n+                }\n+                else\n+                if (s.endsWith(nextToken)) {\n+                    actionExpression = nextToken;\n                 }\n             }\n-            if (created_evt && (evt != null)) {\n-                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n-                \n-                /* The next part is explained by the following \n-                 * quote from the UML spec:\n-                 * \"The event declaration has scope within \n-                 * the package it appears in and may be used in \n-                 * state diagrams for classes that have visibility \n-                 * inside the package. An event is not local to \n-                 * a single class.\"\n-                 */\n-                Object enclosing = StateMachinesHelper.getHelper()\n-                                                .getStateMachine(trans);\n-                while ((!ModelFacade.isAPackage(enclosing))\n-\t\t       && (enclosing != null)) {\n-                    enclosing = ModelFacade.getNamespace(enclosing);\n-\t\t}\n-                if (enclosing != null) {\n-\t\t    ModelFacade.setNamespace(evt, enclosing);\n-\t\t}\n-            }\n-\t} else { \n-            // case 3 and 4\n-            if (evt == null) {\n-                ;// case 3\n-\t    } else {\n-                // case 4\n-                UmlFactory.getFactory().delete(evt); // erase it\n+        }\n+           \n+        if (eventSignature != null) {\n+            try {\n+                parseEventSignature(trans, eventSignature);\n+            } catch (ParseException e) {\n+                _cat.warn(e);\n             }\n         }\n+      \n+        if (guardCondition != null) {\n+            Object guard = parseGuard(guardCondition.substring(guardCondition\n+                    .indexOf('[') + 1));\n+            ModelFacade.setGuard(trans, guard);\n+        }\n+       \n+        if (actionExpression != null) {\n+            Object action = parseAction(actionExpression.trim());\n+            ModelFacade.setEffect(trans, action);\n+        }\n+        return trans;\n \n-\t/* handle the Guard\n-\tWe can distinct between 4 cases:\n-        1. A guard is given. None exists yet.\n-        2. The expression of the guard was present, but is altered.\n-        3. A guard is not given. None exists yet.\n-        4. The expression of the guard was present, but is removed.\n-        The reaction in these cases should be:\n-        1. Create a new guard, set its name, language & expression, \n-\t   and hook it to the transition.\n-        2. Change the guard's expression. Leave the name & language untouched.\n-        3. Nop.\n-        4. Unhook and erase the existing guard.\n-        */\n-\tObject g = ModelFacade.getGuard(trans);\n-\tif (guard.length() > 0) {\n-\t    if (g == null) {\n-                // case 1\n-\t        /*TODO: In the next line, I should use buildGuard(), \n-\t         * but it doesn't show the guard on the diagram... \n-\t         * Why?  (MVW)*/\n-\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n-\t\tif (g != null) {\n-\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n-\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n-\t\t    ModelFacade.setName(g, \"anon\");\n-\t\t    ModelFacade.setTransition(g, trans); \n-\t\t    ModelFacade.setGuard(trans, g);\n-\t\t}\n-\t    } else {\n-                // case 2   \n-\t\t\n-\t\t/* TODO: This does not work! Why not? (MVW)\n-\t        Object expr = ModelFacade.getExpression(g);\n-\t\tModelFacade.setBody(expr,guard);\n-\t\tModelFacade.setExpression(g,expr); */\n-\t        \n-\t        //hence a less elegant workaround that works:\n-\t        String language = \n-\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n-\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n-                    .getDataTypes().createBooleanExpression(language, guard));\n-                /*  TODO: In this case, the properties panel is not updated \n-\t\t    with the changed expression!  */\n-\t    }\n-\t} else { \n-\t    if (g == null) {\n-                ;// case 3\n-\t    } else {\n-                // case 4\n-\t\tUmlFactory.getFactory().delete(g); // erase it\n-\t    }\n-\t}\n-\n-        /* handle the Effect (Action)\n-        We can distinct between 4 cases:\n-        1. An effect is given. None exists yet.\n-        2. The expression of the effect was present, but is altered.\n-        3. An effct is not given. None exists yet.\n-        4. The expression of the effect was present, but is removed.\n-        The reaction in these cases should be:\n-        1. Create a new CallAction, set its name, language & expression, \n-        and hook it to the transition.\n-        2. Change the effect's expression. Leave the actiontype, name & \n-\tlanguage untouched.\n-        3. Nop.\n-        4. Unhook and erase the existing effect.\n-        */\n-\tObject effect = ModelFacade.getEffect(trans);\n-\tif (actions.length() > 0) {\n-\t    if (effect == null) {  // case 1\n-\t        effect = UmlFactory.getFactory().getCommonBehavior()\n-\t\t    .createCallAction();\n-\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n-\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n-\t        ModelFacade.setName(effect, \"anon\");\n-\t        ModelFacade.setEffect(trans, effect);\n-\t    } else {  // case 2\n-                String language = ModelFacade.getLanguage(ModelFacade\n-\t\t    .getScript(effect));\n-                ModelFacade.setScript(effect, UmlFactory.getFactory()\n-\t\t    .getDataTypes().createActionExpression(language, actions));\n-\t    }\n-\t} else {  // case 3 & 4\n-\t    if (effect == null) {\n-                ;// case 3\n-            } else {\n-                // case 4\n-                UmlFactory.getFactory().delete(effect); // erase it\n-            }\n-\t}\n-\n-\treturn trans;\n+        //\t// strip any trailing semi-colons\n+        //\ts = s.trim();\n+        //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n+        //\t    s = s.substring(0, s.length() - 1).trim();\n+        //\n+        //        // strip off the name, and the \":\"\n+        //\tString name = \"\";\n+        //\tString trigger = \"\";\n+        //\tString guard = \"\";\n+        //\tString actions = \"\";\n+        //\tif (s.indexOf(\":\", 0) > -1) {\n+        //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n+        //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n+        //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n+        //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n+        //\t        name = s1.trim();\n+        //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n+        //\t    }\n+        //        }\n+        //\n+        //        // get the guard from between the []\n+        //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n+        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n+        //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n+        //\t\t\t\t\t\t\t     + 1);\n+        //\t    s = s.trim();\n+        //\t}\n+        //\n+        //        // everything behind the \"/\" is the action\n+        //\tif (s.indexOf(\"/\", 0) > -1) {\n+        //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n+        //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n+        //\t}\n+        //\n+        //        // and the remainder is the trigger name\n+        //\ttrigger = s;\n+        //\n+        //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n+        //\tboolean timeEvent = false;\n+        //\tboolean changeEvent = false;\n+        //\tboolean callEvent = false;\n+        //\tboolean signalEvent = false;\n+        //\tString operationName = \"\";\n+        //\tif ((s.toLowerCase().startsWith(\"after\"))\n+        //\t    && (s.indexOf(\"(\", 0) > -1)\n+        //\t    && (s.indexOf(\")\", 0) > -1))\n+        //\t{ //s shall contain the TimeExpression\n+        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n+        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n+        //\t    timeEvent = true;\n+        //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n+        //\t\t   && (s.indexOf(\"(\", 0) > -1)\n+        //\t\t   && (s.indexOf(\")\", 0) > -1))\n+        //\t{ // s shall contain the ChangeExpression\n+        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n+        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n+        //\t    changeEvent = true;\n+        //\t} else if ((s.indexOf(\"(\", 0) > -1)\n+        //            && (s.indexOf(\")\", 0) > -1))\n+        //        { // s shall contain the operation\n+        //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n+        //\t    callEvent = true;\n+        //        } else { // s shall contain the signal\n+        //            signalEvent = true;\n+        //        }\n+        //\n+        //\tLOG.debug(\"name=|\" + name + \"|\");\n+        //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n+        //\tLOG.debug(\"guard=|\" + guard + \"|\");\n+        //\tLOG.debug(\"actions=|\" + actions + \"|\");\n+        //\n+        //        // use the name we found to (re)name the transition\n+        //\tModelFacade.setName(trans, name);\n+        //\n+        //// /* The following handles the Event that is the trigger of\n+        //// this transition.\n+        //// We can distinct between 4 cases:\n+        //// 1. A trigger is given. None exists yet.\n+        //// 2. The name of the trigger was present, but is (the same or)\n+        // altered.\n+        //// 3. A trigger is not given. None exists yet.\n+        //// 4. The name of the trigger was present, but is removed.\n+        //// The reaction in these cases should be:\n+        //// 1. Create a new trigger, name it, and hook it to the transition.\n+        //// 2. Rename the trigger.\n+        //// 3. Nop.\n+        //// 4. Unhook and erase the existing trigger.\n+        ////\n+        //// TODO:\n+        //// In fact it could be made even more complicated for case 1:\n+        //// If the transition did not have a trigger before,\n+        //// a trigger-name is given, and a trigger already\n+        //// existed with that name,\n+        //// then we have to use the existing trigger object!\n+        //// */\n+        //        Object evt = ModelFacade.getTrigger(trans);\n+        //        boolean created_evt = false;\n+        //\tif (trigger.length() > 0) {\n+        //            // case 1 and 2\n+        //            if (evt == null) {\n+        //                // case 1\n+        //                if (timeEvent) { // after(...)\n+        //                    evt = UmlFactory.getFactory().getStateMachines()\n+        //                                                .buildTimeEvent(s);\n+        //                }\n+        //                if (changeEvent) { // when(...)\n+        //                    evt = UmlFactory.getFactory().getStateMachines()\n+        //                                                .buildChangeEvent(s);\n+        //                }\n+        //                if (callEvent) { // operation(paramlist)\n+        //                    evt = UmlFactory.getFactory().getStateMachines()\n+        //\t\t\t                        .buildCallEvent(trans, trigger);\n+        //                }\n+        //                if (signalEvent) { // signalname\n+        //                    evt = UmlFactory.getFactory().getStateMachines()\n+        //                                                .buildSignalEvent(trigger);\n+        //                }\n+        //                created_evt = true;\n+        //            } else {\n+        //                // case 2\n+        //                if (!ModelFacade.getName(evt).equals(trigger)) {\n+        //                    ModelFacade.setName(evt, trigger);\n+        //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n+        //                        UmlFactory.getFactory().delete(evt);\n+        //                        evt = UmlFactory.getFactory().getStateMachines()\n+        //                            .buildTimeEvent(s);\n+        //                        created_evt = true;\n+        //                    }\n+        //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n+        //                        UmlFactory.getFactory().delete(evt);\n+        //                        evt = UmlFactory.getFactory().getStateMachines()\n+        //                            .buildChangeEvent(s);\n+        //                        created_evt = true;\n+        //                    }\n+        //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n+        //                        UmlFactory.getFactory().delete(evt);\n+        //                        evt = UmlFactory.getFactory().getStateMachines()\n+        //                            .buildCallEvent(trans, trigger);\n+        //                        created_evt = true;\n+        //                    }\n+        //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n+        //                        UmlFactory.getFactory().delete(evt);\n+        //                        evt = UmlFactory.getFactory().getStateMachines()\n+        //                            .buildSignalEvent(trigger);\n+        //                        created_evt = true;\n+        //                    }\n+        //                }\n+        //            }\n+        //            if (created_evt && (evt != null)) {\n+        //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n+        //                \n+        //                /* The next part is explained by the following\n+        //                 * quote from the UML spec:\n+        //                 * \"The event declaration has scope within\n+        //                 * the package it appears in and may be used in\n+        //                 * state diagrams for classes that have visibility\n+        //                 * inside the package. An event is not local to\n+        //                 * a single class.\"\n+        //                 */\n+        //                Object enclosing = StateMachinesHelper.getHelper()\n+        //                                                .getStateMachine(trans);\n+        //                while ((!ModelFacade.isAPackage(enclosing))\n+        //\t\t       && (enclosing != null)) {\n+        //                    enclosing = ModelFacade.getNamespace(enclosing);\n+        //\t\t}\n+        //                if (enclosing != null) {\n+        //\t\t    ModelFacade.setNamespace(evt, enclosing);\n+        //\t\t}\n+        //            }\n+        //\t} else {\n+        //            // case 3 and 4\n+        //            if (evt == null) {\n+        //                ;// case 3\n+        //\t    } else {\n+        //                // case 4\n+        //                UmlFactory.getFactory().delete(evt); // erase it\n+        //            }\n+        //        }\n+        //\n+        //\t/* handle the Guard\n+        //\tWe can distinct between 4 cases:\n+        //        1. A guard is given. None exists yet.\n+        //        2. The expression of the guard was present, but is altered.\n+        //        3. A guard is not given. None exists yet.\n+        //        4. The expression of the guard was present, but is removed.\n+        //        The reaction in these cases should be:\n+        //        1. Create a new guard, set its name, language & expression,\n+        //\t   and hook it to the transition.\n+        //        2. Change the guard's expression. Leave the name & language\n+        // untouched.\n+        //        3. Nop.\n+        //        4. Unhook and erase the existing guard.\n+        //        */\n+        //\tObject g = ModelFacade.getGuard(trans);\n+        //\tif (guard.length() > 0) {\n+        //\t    if (g == null) {\n+        //                // case 1\n+        //\t        /*TODO: In the next line, I should use buildGuard(),\n+        //\t         * but it doesn't show the guard on the diagram...\n+        //\t         * Why? (MVW)*/\n+        //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n+        //\t\tif (g != null) {\n+        //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n+        //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n+        //\t\t    ModelFacade.setName(g, \"anon\");\n+        //\t\t    ModelFacade.setTransition(g, trans);\n+        //\t\t    ModelFacade.setGuard(trans, g);\n+        //\t\t}\n+        //\t    } else {\n+        //                // case 2\n+        //\t\t\n+        //\t\t/* TODO: This does not work! Why not? (MVW)\n+        //\t        Object expr = ModelFacade.getExpression(g);\n+        //\t\tModelFacade.setBody(expr,guard);\n+        //\t\tModelFacade.setExpression(g,expr); */\n+        //\t        \n+        //\t        //hence a less elegant workaround that works:\n+        //\t        String language =\n+        //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n+        //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n+        //                    .getDataTypes().createBooleanExpression(language, guard));\n+        //                /* TODO: In this case, the properties panel is not updated\n+        //\t\t    with the changed expression! */\n+        //\t    }\n+        //\t} else {\n+        //\t    if (g == null) {\n+        //                ;// case 3\n+        //\t    } else {\n+        //                // case 4\n+        //\t\tUmlFactory.getFactory().delete(g); // erase it\n+        //\t    }\n+        //\t}\n+        //\n+        //        /* handle the Effect (Action)\n+        //        We can distinct between 4 cases:\n+        //        1. An effect is given. None exists yet.\n+        //        2. The expression of the effect was present, but is altered.\n+        //        3. An effct is not given. None exists yet.\n+        //        4. The expression of the effect was present, but is removed.\n+        //        The reaction in these cases should be:\n+        //        1. Create a new CallAction, set its name, language & expression,\n+        //        and hook it to the transition.\n+        //        2. Change the effect's expression. Leave the actiontype, name &\n+        //\tlanguage untouched.\n+        //        3. Nop.\n+        //        4. Unhook and erase the existing effect.\n+        //        */\n+        //\tObject effect = ModelFacade.getEffect(trans);\n+        //\tif (actions.length() > 0) {\n+        //\t    if (effect == null) { // case 1\n+        //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n+        //\t\t    .createCallAction();\n+        //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n+        //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n+        //\t        ModelFacade.setName(effect, \"anon\");\n+        //\t        ModelFacade.setEffect(trans, effect);\n+        //\t    } else { // case 2\n+        //                String language = ModelFacade.getLanguage(ModelFacade\n+        //\t\t    .getScript(effect));\n+        //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n+        //\t\t    .getDataTypes().createActionExpression(language, actions));\n+        //\t    }\n+        //\t} else { // case 3 & 4\n+        //\t    if (effect == null) {\n+        //                ;// case 3\n+        //            } else {\n+        //                // case 4\n+        //                UmlFactory.getFactory().delete(effect); // erase it\n+        //            }\n+        //\t}\n+        //\n+        //\treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n        s = s.trim();\n        StringTokenizer tokenizer = new StringTokenizer(s, \"[/\");\n        String eventSignature = null;\n        String guardCondition = null;\n        String actionExpression = null;\n        while (tokenizer.hasMoreTokens()) {\n            String nextToken = tokenizer.nextToken();\n            if (nextToken.endsWith(\"]\")) {\n                guardCondition = nextToken.substring(0, nextToken.length() -1);\n            } else {\n                if (s.startsWith(nextToken)) {\n                    eventSignature = nextToken;\n                }\n                else\n                if (s.endsWith(nextToken)) {\n                    actionExpression = nextToken;\n                }\n            }\n        }\n           \n        if (eventSignature != null) {\n            try {\n                parseEventSignature(trans, eventSignature);\n            } catch (ParseException e) {\n                _cat.warn(e);\n            }\n        }\n      \n        if (guardCondition != null) {\n            Object guard = parseGuard(guardCondition.substring(guardCondition\n                    .indexOf('[') + 1));\n            ModelFacade.setGuard(trans, guard);\n        }\n       \n        if (actionExpression != null) {\n            Object action = parseAction(actionExpression.trim());\n            ModelFacade.setEffect(trans, action);\n        }\n        return trans;\n\n        //\t// strip any trailing semi-colons\n        //\ts = s.trim();\n        //\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n        //\t    s = s.substring(0, s.length() - 1).trim();\n        //\n        //        // strip off the name, and the \":\"\n        //\tString name = \"\";\n        //\tString trigger = \"\";\n        //\tString guard = \"\";\n        //\tString actions = \"\";\n        //\tif (s.indexOf(\":\", 0) > -1) {\n        //\t    String s1 = s.substring(0, s.indexOf(\":\"));\n        //\t    // the name may not contain a \"(\", for the case of: a(b:c)\n        //\t    // the name may not contain a \"/\", for when the action contains a \":\"\n        //\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) {\n        //\t        name = s1.trim();\n        //\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n        //\t    }\n        //        }\n        //\n        //        // get the guard from between the []\n        //\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n        //\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n        //\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n        //\t\t\t\t\t\t\t     + 1);\n        //\t    s = s.trim();\n        //\t}\n        //\n        //        // everything behind the \"/\" is the action\n        //\tif (s.indexOf(\"/\", 0) > -1) {\n        //\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n        //\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n        //\t}\n        //\n        //        // and the remainder is the trigger name\n        //\ttrigger = s;\n        //\n        //\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n        //\tboolean timeEvent = false;\n        //\tboolean changeEvent = false;\n        //\tboolean callEvent = false;\n        //\tboolean signalEvent = false;\n        //\tString operationName = \"\";\n        //\tif ((s.toLowerCase().startsWith(\"after\"))\n        //\t    && (s.indexOf(\"(\", 0) > -1)\n        //\t    && (s.indexOf(\")\", 0) > -1))\n        //\t{ //s shall contain the TimeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    timeEvent = true;\n        //\t} else if ((s.toLowerCase().startsWith(\"when\"))\n        //\t\t   && (s.indexOf(\"(\", 0) > -1)\n        //\t\t   && (s.indexOf(\")\", 0) > -1))\n        //\t{ // s shall contain the ChangeExpression\n        //\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n        //\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n        //\t    changeEvent = true;\n        //\t} else if ((s.indexOf(\"(\", 0) > -1)\n        //            && (s.indexOf(\")\", 0) > -1))\n        //        { // s shall contain the operation\n        //\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n        //\t    callEvent = true;\n        //        } else { // s shall contain the signal\n        //            signalEvent = true;\n        //        }\n        //\n        //\tLOG.debug(\"name=|\" + name + \"|\");\n        //\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n        //\tLOG.debug(\"guard=|\" + guard + \"|\");\n        //\tLOG.debug(\"actions=|\" + actions + \"|\");\n        //\n        //        // use the name we found to (re)name the transition\n        //\tModelFacade.setName(trans, name);\n        //\n        //// /* The following handles the Event that is the trigger of\n        //// this transition.\n        //// We can distinct between 4 cases:\n        //// 1. A trigger is given. None exists yet.\n        //// 2. The name of the trigger was present, but is (the same or)\n        // altered.\n        //// 3. A trigger is not given. None exists yet.\n        //// 4. The name of the trigger was present, but is removed.\n        //// The reaction in these cases should be:\n        //// 1. Create a new trigger, name it, and hook it to the transition.\n        //// 2. Rename the trigger.\n        //// 3. Nop.\n        //// 4. Unhook and erase the existing trigger.\n        ////\n        //// TODO:\n        //// In fact it could be made even more complicated for case 1:\n        //// If the transition did not have a trigger before,\n        //// a trigger-name is given, and a trigger already\n        //// existed with that name,\n        //// then we have to use the existing trigger object!\n        //// */\n        //        Object evt = ModelFacade.getTrigger(trans);\n        //        boolean created_evt = false;\n        //\tif (trigger.length() > 0) {\n        //            // case 1 and 2\n        //            if (evt == null) {\n        //                // case 1\n        //                if (timeEvent) { // after(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildTimeEvent(s);\n        //                }\n        //                if (changeEvent) { // when(...)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildChangeEvent(s);\n        //                }\n        //                if (callEvent) { // operation(paramlist)\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //\t\t\t                        .buildCallEvent(trans, trigger);\n        //                }\n        //                if (signalEvent) { // signalname\n        //                    evt = UmlFactory.getFactory().getStateMachines()\n        //                                                .buildSignalEvent(trigger);\n        //                }\n        //                created_evt = true;\n        //            } else {\n        //                // case 2\n        //                if (!ModelFacade.getName(evt).equals(trigger)) {\n        //                    ModelFacade.setName(evt, trigger);\n        //                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildTimeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildChangeEvent(s);\n        //                        created_evt = true;\n        //                    }\n        //                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildCallEvent(trans, trigger);\n        //                        created_evt = true;\n        //                    }\n        //                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n        //                        UmlFactory.getFactory().delete(evt);\n        //                        evt = UmlFactory.getFactory().getStateMachines()\n        //                            .buildSignalEvent(trigger);\n        //                        created_evt = true;\n        //                    }\n        //                }\n        //            }\n        //            if (created_evt && (evt != null)) {\n        //                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n        //                \n        //                /* The next part is explained by the following\n        //                 * quote from the UML spec:\n        //                 * \"The event declaration has scope within\n        //                 * the package it appears in and may be used in\n        //                 * state diagrams for classes that have visibility\n        //                 * inside the package. An event is not local to\n        //                 * a single class.\"\n        //                 */\n        //                Object enclosing = StateMachinesHelper.getHelper()\n        //                                                .getStateMachine(trans);\n        //                while ((!ModelFacade.isAPackage(enclosing))\n        //\t\t       && (enclosing != null)) {\n        //                    enclosing = ModelFacade.getNamespace(enclosing);\n        //\t\t}\n        //                if (enclosing != null) {\n        //\t\t    ModelFacade.setNamespace(evt, enclosing);\n        //\t\t}\n        //            }\n        //\t} else {\n        //            // case 3 and 4\n        //            if (evt == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(evt); // erase it\n        //            }\n        //        }\n        //\n        //\t/* handle the Guard\n        //\tWe can distinct between 4 cases:\n        //        1. A guard is given. None exists yet.\n        //        2. The expression of the guard was present, but is altered.\n        //        3. A guard is not given. None exists yet.\n        //        4. The expression of the guard was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new guard, set its name, language & expression,\n        //\t   and hook it to the transition.\n        //        2. Change the guard's expression. Leave the name & language\n        // untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing guard.\n        //        */\n        //\tObject g = ModelFacade.getGuard(trans);\n        //\tif (guard.length() > 0) {\n        //\t    if (g == null) {\n        //                // case 1\n        //\t        /*TODO: In the next line, I should use buildGuard(),\n        //\t         * but it doesn't show the guard on the diagram...\n        //\t         * Why? (MVW)*/\n        //\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n        //\t\tif (g != null) {\n        //\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n        //\t\t    ModelFacade.setName(g, \"anon\");\n        //\t\t    ModelFacade.setTransition(g, trans);\n        //\t\t    ModelFacade.setGuard(trans, g);\n        //\t\t}\n        //\t    } else {\n        //                // case 2\n        //\t\t\n        //\t\t/* TODO: This does not work! Why not? (MVW)\n        //\t        Object expr = ModelFacade.getExpression(g);\n        //\t\tModelFacade.setBody(expr,guard);\n        //\t\tModelFacade.setExpression(g,expr); */\n        //\t        \n        //\t        //hence a less elegant workaround that works:\n        //\t        String language =\n        //\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n        //\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n        //                    .getDataTypes().createBooleanExpression(language, guard));\n        //                /* TODO: In this case, the properties panel is not updated\n        //\t\t    with the changed expression! */\n        //\t    }\n        //\t} else {\n        //\t    if (g == null) {\n        //                ;// case 3\n        //\t    } else {\n        //                // case 4\n        //\t\tUmlFactory.getFactory().delete(g); // erase it\n        //\t    }\n        //\t}\n        //\n        //        /* handle the Effect (Action)\n        //        We can distinct between 4 cases:\n        //        1. An effect is given. None exists yet.\n        //        2. The expression of the effect was present, but is altered.\n        //        3. An effct is not given. None exists yet.\n        //        4. The expression of the effect was present, but is removed.\n        //        The reaction in these cases should be:\n        //        1. Create a new CallAction, set its name, language & expression,\n        //        and hook it to the transition.\n        //        2. Change the effect's expression. Leave the actiontype, name &\n        //\tlanguage untouched.\n        //        3. Nop.\n        //        4. Unhook and erase the existing effect.\n        //        */\n        //\tObject effect = ModelFacade.getEffect(trans);\n        //\tif (actions.length() > 0) {\n        //\t    if (effect == null) { // case 1\n        //\t        effect = UmlFactory.getFactory().getCommonBehavior()\n        //\t\t    .createCallAction();\n        //\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n        //\t        ModelFacade.setName(effect, \"anon\");\n        //\t        ModelFacade.setEffect(trans, effect);\n        //\t    } else { // case 2\n        //                String language = ModelFacade.getLanguage(ModelFacade\n        //\t\t    .getScript(effect));\n        //                ModelFacade.setScript(effect, UmlFactory.getFactory()\n        //\t\t    .getDataTypes().createActionExpression(language, actions));\n        //\t    }\n        //\t} else { // case 3 & 4\n        //\t    if (effect == null) {\n        //                ;// case 3\n        //            } else {\n        //                // case 4\n        //                UmlFactory.getFactory().delete(effect); // erase it\n        //            }\n        //\t}\n        //\n        //\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "32"
        },
        "10f720ae95053d75e83e5eac408e731094ec2257": {
            "type": "Ybodychange",
            "commitMessage": "Fixed some indentation issues (and other style issues in the same files.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6083 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "23/06/04 11:28 PM",
            "commitName": "10f720ae95053d75e83e5eac408e731094ec2257",
            "commitAuthor": "Linus Tolke",
            "commitDateOld": "23/06/04 11:29 AM",
            "commitNameOld": "31b05426b08ce4ab797813fe32cee4095fbe1198",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.5,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,268 +1,272 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    String s1 = s.substring(0, s.indexOf(\":\"));\n \t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n \t    /* the name may not contain a \"/\", for when the action contains a \":\" */\n-\t    if((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)){ \n+\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) { \n \t        name = s1.trim();\n \t        s = s.substring(s.indexOf(\":\") + 1).trim();\n \t    }  \n         }\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger name\n \ttrigger = s;\n \n \t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n \tboolean timeEvent = false;\n \tboolean changeEvent = false;\n \tboolean callEvent = false;\n \tboolean signalEvent = false;\n \tString operationName = \"\";\n \tif ((s.toLowerCase().startsWith(\"after\")) \n \t    && (s.indexOf(\"(\", 0) > -1)\n \t    && (s.indexOf(\")\", 0) > -1)) \n \t{   //s shall contain the TimeExpression\n \t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n \t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n \t    timeEvent = true;\n-\t}else if ((s.toLowerCase().startsWith(\"when\")) \n-            && (s.indexOf(\"(\", 0) > -1)\n-            && (s.indexOf(\")\", 0) > -1))\n+\t} else if ((s.toLowerCase().startsWith(\"when\")) \n+\t\t   && (s.indexOf(\"(\", 0) > -1)\n+\t\t   && (s.indexOf(\")\", 0) > -1))\n \t{   // s shall contain the ChangeExpression\n \t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n \t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n \t    changeEvent = true;\n-\t}else if ((s.indexOf(\"(\", 0) > -1)\n+\t} else if ((s.indexOf(\"(\", 0) > -1)\n             && (s.indexOf(\")\", 0) > -1))\n         {   // s shall contain the operation \n \t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n \t    callEvent = true;\n-        }else { // s shall contain the signal \n+        } else { // s shall contain the signal \n             signalEvent = true;\n         }\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the Event that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is (the same or) altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         TODO:\n         In fact it could be made even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n         boolean created_evt = false;\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n-                if (timeEvent){ // after(...)\n+                if (timeEvent) { // after(...)\n                     evt = UmlFactory.getFactory().getStateMachines()\n                                                 .buildTimeEvent(s);\n                 }\n                 if (changeEvent) {  // when(...)\n                     evt = UmlFactory.getFactory().getStateMachines()\n                                                 .buildChangeEvent(s);\n                 }\n-                if (callEvent){  // operation(paramlist)\n+                if (callEvent) {  // operation(paramlist)\n                     evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t                        .buildCallEvent(trans, trigger);\n                 }\n-                if (signalEvent){  // signalname\n+                if (signalEvent) {  // signalname\n                     evt = UmlFactory.getFactory().getStateMachines()\n                                                 .buildSignalEvent(trigger);\n                 }\n                 created_evt = true;\n             } else {\n                 // case 2\n-                if (!ModelFacade.getName(evt).equals(trigger)){\n+                if (!ModelFacade.getName(evt).equals(trigger)) {\n                     ModelFacade.setName(evt, trigger);\n                     if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildTimeEvent(s);\n                         created_evt = true;\n                     }\n                     if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildChangeEvent(s);\n                         created_evt = true;\n                     }\n                     if (callEvent && !ModelFacade.isACallEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildCallEvent(trans, trigger);\n                         created_evt = true;\n                     }\n                     if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildSignalEvent(trigger);\n                         created_evt = true;\n                     }\n                 }\n             }\n             if (created_evt && (evt != null)) {\n                 StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n                 \n                 /* The next part is explained by the following \n                  * quote from the UML spec:\n                  * \"The event declaration has scope within \n                  * the package it appears in and may be used in \n                  * state diagrams for classes that have visibility \n                  * inside the package. An event is not local to \n                  * a single class.\"\n                  */\n                 Object enclosing = StateMachinesHelper.getHelper()\n                                                 .getStateMachine(trans);\n-                while((!ModelFacade.isAPackage(enclosing))&&(enclosing != null))\n+                while ((!ModelFacade.isAPackage(enclosing))\n+\t\t       && (enclosing != null)) {\n                     enclosing = ModelFacade.getNamespace(enclosing);\n-                if (enclosing!= null) ModelFacade.setNamespace(evt, enclosing);\n+\t\t}\n+                if (enclosing != null) {\n+\t\t    ModelFacade.setNamespace(evt, enclosing);\n+\t\t}\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t        /*TODO: In the next line, I should use buildGuard(), \n \t         * but it doesn't show the guard on the diagram... \n \t         * Why?  (MVW)*/\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans); \n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    String s1 = s.substring(0, s.indexOf(\":\"));\n\t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n\t    /* the name may not contain a \"/\", for when the action contains a \":\" */\n\t    if ((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)) { \n\t        name = s1.trim();\n\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n\t    }  \n        }\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger name\n\ttrigger = s;\n\n\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n\tboolean timeEvent = false;\n\tboolean changeEvent = false;\n\tboolean callEvent = false;\n\tboolean signalEvent = false;\n\tString operationName = \"\";\n\tif ((s.toLowerCase().startsWith(\"after\")) \n\t    && (s.indexOf(\"(\", 0) > -1)\n\t    && (s.indexOf(\")\", 0) > -1)) \n\t{   //s shall contain the TimeExpression\n\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n\t    timeEvent = true;\n\t} else if ((s.toLowerCase().startsWith(\"when\")) \n\t\t   && (s.indexOf(\"(\", 0) > -1)\n\t\t   && (s.indexOf(\")\", 0) > -1))\n\t{   // s shall contain the ChangeExpression\n\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n\t    changeEvent = true;\n\t} else if ((s.indexOf(\"(\", 0) > -1)\n            && (s.indexOf(\")\", 0) > -1))\n        {   // s shall contain the operation \n\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n\t    callEvent = true;\n        } else { // s shall contain the signal \n            signalEvent = true;\n        }\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the Event that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is (the same or) altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        TODO:\n        In fact it could be made even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n        boolean created_evt = false;\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                if (timeEvent) { // after(...)\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildTimeEvent(s);\n                }\n                if (changeEvent) {  // when(...)\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildChangeEvent(s);\n                }\n                if (callEvent) {  // operation(paramlist)\n                    evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t                        .buildCallEvent(trans, trigger);\n                }\n                if (signalEvent) {  // signalname\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildSignalEvent(trigger);\n                }\n                created_evt = true;\n            } else {\n                // case 2\n                if (!ModelFacade.getName(evt).equals(trigger)) {\n                    ModelFacade.setName(evt, trigger);\n                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildTimeEvent(s);\n                        created_evt = true;\n                    }\n                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildChangeEvent(s);\n                        created_evt = true;\n                    }\n                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildCallEvent(trans, trigger);\n                        created_evt = true;\n                    }\n                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildSignalEvent(trigger);\n                        created_evt = true;\n                    }\n                }\n            }\n            if (created_evt && (evt != null)) {\n                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n                \n                /* The next part is explained by the following \n                 * quote from the UML spec:\n                 * \"The event declaration has scope within \n                 * the package it appears in and may be used in \n                 * state diagrams for classes that have visibility \n                 * inside the package. An event is not local to \n                 * a single class.\"\n                 */\n                Object enclosing = StateMachinesHelper.getHelper()\n                                                .getStateMachine(trans);\n                while ((!ModelFacade.isAPackage(enclosing))\n\t\t       && (enclosing != null)) {\n                    enclosing = ModelFacade.getNamespace(enclosing);\n\t\t}\n                if (enclosing != null) {\n\t\t    ModelFacade.setNamespace(evt, enclosing);\n\t\t}\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t        /*TODO: In the next line, I should use buildGuard(), \n\t         * but it doesn't show the guard on the diagram... \n\t         * Why?  (MVW)*/\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans); \n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "47"
        },
        "31b05426b08ce4ab797813fe32cee4095fbe1198": {
            "type": "Ybodychange",
            "commitMessage": "Solved a little problem with transition string - the following was not supported:\n\"trigger / action\" with action containing a \":\".\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6082 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "23/06/04 11:29 AM",
            "commitName": "31b05426b08ce4ab797813fe32cee4095fbe1198",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "29/05/04 11:11 PM",
            "commitNameOld": "994b0ce2014b076e74258d6c2e7ba3d7260260d2",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 24.51,
            "commitsBetweenForRepo": 54,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,266 +1,268 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n+\t    String s1 = s.substring(0, s.indexOf(\":\"));\n \t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n-\t    if(s.substring(0, s.indexOf(\":\")).indexOf(\"(\") < 0){ \n-\t        name = s.substring(0, s.indexOf(\":\")).trim();\n+\t    /* the name may not contain a \"/\", for when the action contains a \":\" */\n+\t    if((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)){ \n+\t        name = s1.trim();\n \t        s = s.substring(s.indexOf(\":\") + 1).trim();\n \t    }  \n         }\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger name\n \ttrigger = s;\n \n \t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n \tboolean timeEvent = false;\n \tboolean changeEvent = false;\n \tboolean callEvent = false;\n \tboolean signalEvent = false;\n \tString operationName = \"\";\n \tif ((s.toLowerCase().startsWith(\"after\")) \n \t    && (s.indexOf(\"(\", 0) > -1)\n \t    && (s.indexOf(\")\", 0) > -1)) \n \t{   //s shall contain the TimeExpression\n \t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n \t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n \t    timeEvent = true;\n \t}else if ((s.toLowerCase().startsWith(\"when\")) \n             && (s.indexOf(\"(\", 0) > -1)\n             && (s.indexOf(\")\", 0) > -1))\n \t{   // s shall contain the ChangeExpression\n \t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n \t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n \t    changeEvent = true;\n \t}else if ((s.indexOf(\"(\", 0) > -1)\n             && (s.indexOf(\")\", 0) > -1))\n         {   // s shall contain the operation \n \t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n \t    callEvent = true;\n         }else { // s shall contain the signal \n             signalEvent = true;\n         }\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the Event that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is (the same or) altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         TODO:\n         In fact it could be made even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n         boolean created_evt = false;\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 if (timeEvent){ // after(...)\n                     evt = UmlFactory.getFactory().getStateMachines()\n                                                 .buildTimeEvent(s);\n                 }\n                 if (changeEvent) {  // when(...)\n                     evt = UmlFactory.getFactory().getStateMachines()\n                                                 .buildChangeEvent(s);\n                 }\n                 if (callEvent){  // operation(paramlist)\n                     evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t                        .buildCallEvent(trans, trigger);\n                 }\n                 if (signalEvent){  // signalname\n                     evt = UmlFactory.getFactory().getStateMachines()\n                                                 .buildSignalEvent(trigger);\n                 }\n                 created_evt = true;\n             } else {\n                 // case 2\n                 if (!ModelFacade.getName(evt).equals(trigger)){\n                     ModelFacade.setName(evt, trigger);\n                     if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildTimeEvent(s);\n                         created_evt = true;\n                     }\n                     if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildChangeEvent(s);\n                         created_evt = true;\n                     }\n                     if (callEvent && !ModelFacade.isACallEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildCallEvent(trans, trigger);\n                         created_evt = true;\n                     }\n                     if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n                         UmlFactory.getFactory().delete(evt);\n                         evt = UmlFactory.getFactory().getStateMachines()\n                             .buildSignalEvent(trigger);\n                         created_evt = true;\n                     }\n                 }\n             }\n             if (created_evt && (evt != null)) {\n                 StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n                 \n                 /* The next part is explained by the following \n                  * quote from the UML spec:\n                  * \"The event declaration has scope within \n                  * the package it appears in and may be used in \n                  * state diagrams for classes that have visibility \n                  * inside the package. An event is not local to \n                  * a single class.\"\n                  */\n                 Object enclosing = StateMachinesHelper.getHelper()\n                                                 .getStateMachine(trans);\n                 while((!ModelFacade.isAPackage(enclosing))&&(enclosing != null))\n                     enclosing = ModelFacade.getNamespace(enclosing);\n                 if (enclosing!= null) ModelFacade.setNamespace(evt, enclosing);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t        /*TODO: In the next line, I should use buildGuard(), \n \t         * but it doesn't show the guard on the diagram... \n \t         * Why?  (MVW)*/\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans); \n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    String s1 = s.substring(0, s.indexOf(\":\"));\n\t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n\t    /* the name may not contain a \"/\", for when the action contains a \":\" */\n\t    if((s1.indexOf(\"(\") < 0) && (s1.indexOf(\"/\") < 0)){ \n\t        name = s1.trim();\n\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n\t    }  \n        }\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger name\n\ttrigger = s;\n\n\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n\tboolean timeEvent = false;\n\tboolean changeEvent = false;\n\tboolean callEvent = false;\n\tboolean signalEvent = false;\n\tString operationName = \"\";\n\tif ((s.toLowerCase().startsWith(\"after\")) \n\t    && (s.indexOf(\"(\", 0) > -1)\n\t    && (s.indexOf(\")\", 0) > -1)) \n\t{   //s shall contain the TimeExpression\n\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n\t    timeEvent = true;\n\t}else if ((s.toLowerCase().startsWith(\"when\")) \n            && (s.indexOf(\"(\", 0) > -1)\n            && (s.indexOf(\")\", 0) > -1))\n\t{   // s shall contain the ChangeExpression\n\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n\t    changeEvent = true;\n\t}else if ((s.indexOf(\"(\", 0) > -1)\n            && (s.indexOf(\")\", 0) > -1))\n        {   // s shall contain the operation \n\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n\t    callEvent = true;\n        }else { // s shall contain the signal \n            signalEvent = true;\n        }\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the Event that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is (the same or) altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        TODO:\n        In fact it could be made even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n        boolean created_evt = false;\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                if (timeEvent){ // after(...)\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildTimeEvent(s);\n                }\n                if (changeEvent) {  // when(...)\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildChangeEvent(s);\n                }\n                if (callEvent){  // operation(paramlist)\n                    evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t                        .buildCallEvent(trans, trigger);\n                }\n                if (signalEvent){  // signalname\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildSignalEvent(trigger);\n                }\n                created_evt = true;\n            } else {\n                // case 2\n                if (!ModelFacade.getName(evt).equals(trigger)){\n                    ModelFacade.setName(evt, trigger);\n                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildTimeEvent(s);\n                        created_evt = true;\n                    }\n                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildChangeEvent(s);\n                        created_evt = true;\n                    }\n                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildCallEvent(trans, trigger);\n                        created_evt = true;\n                    }\n                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildSignalEvent(trigger);\n                        created_evt = true;\n                    }\n                }\n            }\n            if (created_evt && (evt != null)) {\n                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n                \n                /* The next part is explained by the following \n                 * quote from the UML spec:\n                 * \"The event declaration has scope within \n                 * the package it appears in and may be used in \n                 * state diagrams for classes that have visibility \n                 * inside the package. An event is not local to \n                 * a single class.\"\n                 */\n                Object enclosing = StateMachinesHelper.getHelper()\n                                                .getStateMachine(trans);\n                while((!ModelFacade.isAPackage(enclosing))&&(enclosing != null))\n                    enclosing = ModelFacade.getNamespace(enclosing);\n                if (enclosing!= null) ModelFacade.setNamespace(evt, enclosing);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t        /*TODO: In the next line, I should use buildGuard(), \n\t         * but it doesn't show the guard on the diagram... \n\t         * Why?  (MVW)*/\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans); \n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "994b0ce2014b076e74258d6c2e7ba3d7260260d2": {
            "type": "Ybodychange",
            "commitMessage": "Issue 1622: Implemented 4 event types.They can be created on the diagram, and in prop panels.\nProp panels of the 4 event-types are not correct yet...\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@6025 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "29/05/04 11:11 PM",
            "commitName": "994b0ce2014b076e74258d6c2e7ba3d7260260d2",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "28/04/04 10:55 AM",
            "commitNameOld": "c5399dad49d0ade7c9f96b5110e0bdb74a641cca",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 31.51,
            "commitsBetweenForRepo": 78,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,192 +1,266 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n-\t    name = s.substring(0, s.indexOf(\":\")).trim();\n-\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n-\t}\n+\t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n+\t    if(s.substring(0, s.indexOf(\":\")).indexOf(\"(\") < 0){ \n+\t        name = s.substring(0, s.indexOf(\":\")).trim();\n+\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n+\t    }  \n+        }\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n-        // and the remainder is the trigger\n+        // and the remainder is the trigger name\n \ttrigger = s;\n \n+\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n+\tboolean timeEvent = false;\n+\tboolean changeEvent = false;\n+\tboolean callEvent = false;\n+\tboolean signalEvent = false;\n+\tString operationName = \"\";\n+\tif ((s.toLowerCase().startsWith(\"after\")) \n+\t    && (s.indexOf(\"(\", 0) > -1)\n+\t    && (s.indexOf(\")\", 0) > -1)) \n+\t{   //s shall contain the TimeExpression\n+\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n+\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n+\t    timeEvent = true;\n+\t}else if ((s.toLowerCase().startsWith(\"when\")) \n+            && (s.indexOf(\"(\", 0) > -1)\n+            && (s.indexOf(\")\", 0) > -1))\n+\t{   // s shall contain the ChangeExpression\n+\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n+\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n+\t    changeEvent = true;\n+\t}else if ((s.indexOf(\"(\", 0) > -1)\n+            && (s.indexOf(\")\", 0) > -1))\n+        {   // s shall contain the operation \n+\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n+\t    callEvent = true;\n+        }else { // s shall contain the signal \n+            signalEvent = true;\n+        }\n+\n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the Event that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n-        2. The name of the trigger was present, but is altered.\n+        2. The name of the trigger was present, but is (the same or) altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n-        In fact it is even more complicated for case 1:\n+        TODO:\n+        In fact it could be made even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n+        boolean created_evt = false;\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n-                evt = UmlFactory.getFactory().getStateMachines()\n-\t\t\t\t\t\t \t.buildCallEvent();\n-                if (evt != null) {\n-                    ModelFacade.setName(evt, trigger);\n-                    ModelFacade.setTrigger(trans, evt);\n-                    \n-                    /* The next part is explained by the following \n-                     * quote from the UML spec:\n-                     * \"The event declaration has scope within \n-                     * the package it appears in and may be used in \n-                     * state diagrams for classes that have visibility \n-                     * inside the package. An event is not local to \n-                     * a single class.\"\n-                     */\n-                    //TODO: next statement fails for internal transitions\n-                    Object enclosingPackage = ModelFacade.getStateMachine(trans);\n-                    while((! ModelFacade.isAPackage(enclosingPackage))&&(enclosingPackage != null))\n-                        enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n-                    if (enclosingPackage!= null) ModelFacade.setNamespace(evt, enclosingPackage);\n+                if (timeEvent){ // after(...)\n+                    evt = UmlFactory.getFactory().getStateMachines()\n+                                                .buildTimeEvent(s);\n                 }\n+                if (changeEvent) {  // when(...)\n+                    evt = UmlFactory.getFactory().getStateMachines()\n+                                                .buildChangeEvent(s);\n+                }\n+                if (callEvent){  // operation(paramlist)\n+                    evt = UmlFactory.getFactory().getStateMachines()\n+\t\t\t                        .buildCallEvent(trans, trigger);\n+                }\n+                if (signalEvent){  // signalname\n+                    evt = UmlFactory.getFactory().getStateMachines()\n+                                                .buildSignalEvent(trigger);\n+                }\n+                created_evt = true;\n             } else {\n                 // case 2\n-                ModelFacade.setName(evt, trigger);\n+                if (!ModelFacade.getName(evt).equals(trigger)){\n+                    ModelFacade.setName(evt, trigger);\n+                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n+                        UmlFactory.getFactory().delete(evt);\n+                        evt = UmlFactory.getFactory().getStateMachines()\n+                            .buildTimeEvent(s);\n+                        created_evt = true;\n+                    }\n+                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n+                        UmlFactory.getFactory().delete(evt);\n+                        evt = UmlFactory.getFactory().getStateMachines()\n+                            .buildChangeEvent(s);\n+                        created_evt = true;\n+                    }\n+                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n+                        UmlFactory.getFactory().delete(evt);\n+                        evt = UmlFactory.getFactory().getStateMachines()\n+                            .buildCallEvent(trans, trigger);\n+                        created_evt = true;\n+                    }\n+                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n+                        UmlFactory.getFactory().delete(evt);\n+                        evt = UmlFactory.getFactory().getStateMachines()\n+                            .buildSignalEvent(trigger);\n+                        created_evt = true;\n+                    }\n+                }\n+            }\n+            if (created_evt && (evt != null)) {\n+                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n+                \n+                /* The next part is explained by the following \n+                 * quote from the UML spec:\n+                 * \"The event declaration has scope within \n+                 * the package it appears in and may be used in \n+                 * state diagrams for classes that have visibility \n+                 * inside the package. An event is not local to \n+                 * a single class.\"\n+                 */\n+                Object enclosing = StateMachinesHelper.getHelper()\n+                                                .getStateMachine(trans);\n+                while((!ModelFacade.isAPackage(enclosing))&&(enclosing != null))\n+                    enclosing = ModelFacade.getNamespace(enclosing);\n+                if (enclosing!= null) ModelFacade.setNamespace(evt, enclosing);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t        /*TODO: In the next line, I should use buildGuard(), \n \t         * but it doesn't show the guard on the diagram... \n \t         * Why?  (MVW)*/\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans); \n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    /* the name may not contain a \"(\", for the case of: a(b:c) */\n\t    if(s.substring(0, s.indexOf(\":\")).indexOf(\"(\") < 0){ \n\t        name = s.substring(0, s.indexOf(\":\")).trim();\n\t        s = s.substring(s.indexOf(\":\") + 1).trim();\n\t    }  \n        }\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger name\n\ttrigger = s;\n\n\t// let's look for a TimeEvent, ChangeEvent, CallEvent or SignalEvent\n\tboolean timeEvent = false;\n\tboolean changeEvent = false;\n\tboolean callEvent = false;\n\tboolean signalEvent = false;\n\tString operationName = \"\";\n\tif ((s.toLowerCase().startsWith(\"after\")) \n\t    && (s.indexOf(\"(\", 0) > -1)\n\t    && (s.indexOf(\")\", 0) > -1)) \n\t{   //s shall contain the TimeExpression\n\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n\t    timeEvent = true;\n\t}else if ((s.toLowerCase().startsWith(\"when\")) \n            && (s.indexOf(\"(\", 0) > -1)\n            && (s.indexOf(\")\", 0) > -1))\n\t{   // s shall contain the ChangeExpression\n\t    s = s.substring(s.indexOf(\"(\") + 1).trim();\n\t    s = s.substring(0, s.lastIndexOf(\")\")).trim();\n\t    changeEvent = true;\n\t}else if ((s.indexOf(\"(\", 0) > -1)\n            && (s.indexOf(\")\", 0) > -1))\n        {   // s shall contain the operation \n\t    operationName = s.substring(0, s.indexOf(\"(\")).trim();\n\t    callEvent = true;\n        }else { // s shall contain the signal \n            signalEvent = true;\n        }\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the Event that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is (the same or) altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        TODO:\n        In fact it could be made even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n        boolean created_evt = false;\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                if (timeEvent){ // after(...)\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildTimeEvent(s);\n                }\n                if (changeEvent) {  // when(...)\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildChangeEvent(s);\n                }\n                if (callEvent){  // operation(paramlist)\n                    evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t                        .buildCallEvent(trans, trigger);\n                }\n                if (signalEvent){  // signalname\n                    evt = UmlFactory.getFactory().getStateMachines()\n                                                .buildSignalEvent(trigger);\n                }\n                created_evt = true;\n            } else {\n                // case 2\n                if (!ModelFacade.getName(evt).equals(trigger)){\n                    ModelFacade.setName(evt, trigger);\n                    if (timeEvent && !ModelFacade.isATimeEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildTimeEvent(s);\n                        created_evt = true;\n                    }\n                    if (changeEvent && !ModelFacade.isAChangeEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildChangeEvent(s);\n                        created_evt = true;\n                    }\n                    if (callEvent && !ModelFacade.isACallEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildCallEvent(trans, trigger);\n                        created_evt = true;\n                    }\n                    if (signalEvent && !ModelFacade.isASignalEvent(evt)) {\n                        UmlFactory.getFactory().delete(evt);\n                        evt = UmlFactory.getFactory().getStateMachines()\n                            .buildSignalEvent(trigger);\n                        created_evt = true;\n                    }\n                }\n            }\n            if (created_evt && (evt != null)) {\n                StateMachinesHelper.getHelper().setEventAsTrigger(trans, evt);\n                \n                /* The next part is explained by the following \n                 * quote from the UML spec:\n                 * \"The event declaration has scope within \n                 * the package it appears in and may be used in \n                 * state diagrams for classes that have visibility \n                 * inside the package. An event is not local to \n                 * a single class.\"\n                 */\n                Object enclosing = StateMachinesHelper.getHelper()\n                                                .getStateMachine(trans);\n                while((!ModelFacade.isAPackage(enclosing))&&(enclosing != null))\n                    enclosing = ModelFacade.getNamespace(enclosing);\n                if (enclosing!= null) ModelFacade.setNamespace(evt, enclosing);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t        /*TODO: In the next line, I should use buildGuard(), \n\t         * but it doesn't show the guard on the diagram... \n\t         * Why?  (MVW)*/\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans); \n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "276a0444269a3d1688df8aa45552cdcff1513be8": {
            "type": "Ybodychange",
            "commitMessage": "Found out how to get the statemachine for a state.\nTried to use buid... instead of create...\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5911 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "19/04/04 12:43 PM",
            "commitName": "276a0444269a3d1688df8aa45552cdcff1513be8",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "18/04/04 12:04 PM",
            "commitNameOld": "f0f03eebc4cfb6db7c7fc93d1dbf390d0e37ddcd",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 1.03,
            "commitsBetweenForRepo": 6,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,189 +1,192 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the Event that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, evt);\n                     \n                     /* The next part is explained by the following \n                      * quote from the UML spec:\n                      * \"The event declaration has scope within \n                      * the package it appears in and may be used in \n                      * state diagrams for classes that have visibility \n                      * inside the package. An event is not local to \n                      * a single class.\"\n                      */\n                     //TODO: next statement fails for internal transitions\n                     Object enclosingPackage = ModelFacade.getStateMachine(trans);\n                     while((! ModelFacade.isAPackage(enclosingPackage))&&(enclosingPackage != null))\n                         enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n                     if (enclosingPackage!= null) ModelFacade.setNamespace(evt, enclosingPackage);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n+\t        /*TODO: In the next line, I should use buildGuard(), \n+\t         * but it doesn't show the guard on the diagram... \n+\t         * Why?  (MVW)*/\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n-\t\t    ModelFacade.setTransition(g, trans);\n+\t\t    ModelFacade.setTransition(g, trans); \n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the Event that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, evt);\n                    \n                    /* The next part is explained by the following \n                     * quote from the UML spec:\n                     * \"The event declaration has scope within \n                     * the package it appears in and may be used in \n                     * state diagrams for classes that have visibility \n                     * inside the package. An event is not local to \n                     * a single class.\"\n                     */\n                    //TODO: next statement fails for internal transitions\n                    Object enclosingPackage = ModelFacade.getStateMachine(trans);\n                    while((! ModelFacade.isAPackage(enclosingPackage))&&(enclosingPackage != null))\n                        enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n                    if (enclosingPackage!= null) ModelFacade.setNamespace(evt, enclosingPackage);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t        /*TODO: In the next line, I should use buildGuard(), \n\t         * but it doesn't show the guard on the diagram... \n\t         * Why?  (MVW)*/\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans); \n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "f0f03eebc4cfb6db7c7fc93d1dbf390d0e37ddcd": {
            "type": "Ybodychange",
            "commitMessage": "Solved issue 1759: Activity name lost after editing in diagram.\nHowever, there are still some problems with internal transitions.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5905 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "18/04/04 12:04 PM",
            "commitName": "f0f03eebc4cfb6db7c7fc93d1dbf390d0e37ddcd",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "17/04/04 8:38 AM",
            "commitNameOld": "1005b0bcebf2b43be8c7436f8e328cd7e3db77a3",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 1.14,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,188 +1,189 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n-        /* The following handles the CallEvent that is the trigger of\n+        /* The following handles the Event that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, evt);\n+                    \n                     /* The next part is explained by the following \n                      * quote from the UML spec:\n                      * \"The event declaration has scope within \n                      * the package it appears in and may be used in \n                      * state diagrams for classes that have visibility \n                      * inside the package. An event is not local to \n                      * a single class.\"\n                      */\n+                    //TODO: next statement fails for internal transitions\n                     Object enclosingPackage = ModelFacade.getStateMachine(trans);\n-                    while(! ModelFacade.isAPackage(enclosingPackage)) {\n+                    while((! ModelFacade.isAPackage(enclosingPackage))&&(enclosingPackage != null))\n                         enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n-                    };\n-                    ModelFacade.setNamespace(evt, enclosingPackage);\n+                    if (enclosingPackage!= null) ModelFacade.setNamespace(evt, enclosingPackage);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the Event that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, evt);\n                    \n                    /* The next part is explained by the following \n                     * quote from the UML spec:\n                     * \"The event declaration has scope within \n                     * the package it appears in and may be used in \n                     * state diagrams for classes that have visibility \n                     * inside the package. An event is not local to \n                     * a single class.\"\n                     */\n                    //TODO: next statement fails for internal transitions\n                    Object enclosingPackage = ModelFacade.getStateMachine(trans);\n                    while((! ModelFacade.isAPackage(enclosingPackage))&&(enclosingPackage != null))\n                        enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n                    if (enclosingPackage!= null) ModelFacade.setNamespace(evt, enclosingPackage);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "1005b0bcebf2b43be8c7436f8e328cd7e3db77a3": {
            "type": "Ybodychange",
            "commitMessage": "Set the namespace to the enclosing package when an event is created.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5903 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "17/04/04 8:38 AM",
            "commitName": "1005b0bcebf2b43be8c7436f8e328cd7e3db77a3",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "17/04/04 4:38 AM",
            "commitNameOld": "995df27655f04b06beb62c428c5a9e9796ac5c99",
            "commitAuthorOld": "Michael Stockman",
            "daysBetweenCommits": 0.17,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,175 +1,188 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n-                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n+                    ModelFacade.setTrigger(trans, evt);\n+                    /* The next part is explained by the following \n+                     * quote from the UML spec:\n+                     * \"The event declaration has scope within \n+                     * the package it appears in and may be used in \n+                     * state diagrams for classes that have visibility \n+                     * inside the package. An event is not local to \n+                     * a single class.\"\n+                     */\n+                    Object enclosingPackage = ModelFacade.getStateMachine(trans);\n+                    while(! ModelFacade.isAPackage(enclosingPackage)) {\n+                        enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n+                    };\n+                    ModelFacade.setNamespace(evt, enclosingPackage);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, evt);\n                    /* The next part is explained by the following \n                     * quote from the UML spec:\n                     * \"The event declaration has scope within \n                     * the package it appears in and may be used in \n                     * state diagrams for classes that have visibility \n                     * inside the package. An event is not local to \n                     * a single class.\"\n                     */\n                    Object enclosingPackage = ModelFacade.getStateMachine(trans);\n                    while(! ModelFacade.isAPackage(enclosingPackage)) {\n                        enclosingPackage = ModelFacade.getNamespace(enclosingPackage);\n                    };\n                    ModelFacade.setNamespace(evt, enclosingPackage);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "995df27655f04b06beb62c428c5a9e9796ac5c99": {
            "type": "Ybodychange",
            "commitMessage": "Don't remove more than the ';' at the end of a trigger.\nRemove all trailing ';'.\nAlso neccesary to retrim then, since it may be preceeded by whitespace.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5902 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "17/04/04 4:38 AM",
            "commitName": "995df27655f04b06beb62c428c5a9e9796ac5c99",
            "commitAuthor": "Michael Stockman",
            "commitDateOld": "17/04/04 3:57 AM",
            "commitNameOld": "ab51ea546e9bd19002ab573ad20edfa3e1a22cf1",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.03,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,176 +1,175 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n-        if (s.length() > 0) // otherwise an exception in next line\n-\tif (s.charAt(s.length() - 1) == ';')\n-\t    s = s.substring(0, s.length() - 2);\n+\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n+\t    s = s.substring(0, s.length() - 1).trim();\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    if (effect == null) {\n                 ;// case 3\n             } else {\n                 // case 4\n                 UmlFactory.getFactory().delete(effect); // erase it\n             }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\twhile (s.length() > 0 && s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 1).trim();\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "ab51ea546e9bd19002ab573ad20edfa3e1a22cf1": {
            "type": "Ybodychange",
            "commitMessage": "Finally I found out how to delete a modelelement...\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5901 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "17/04/04 3:57 AM",
            "commitName": "ab51ea546e9bd19002ab573ad20edfa3e1a22cf1",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "15/04/04 12:04 PM",
            "commitNameOld": "005ba3be21dac34710dd52abdc8a62bc751395f2",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 1.66,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,178 +1,176 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n-\tif (s.length() == 0) return null;\n+        if (s.length() > 0) // otherwise an exception in next line\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n-                ModelFacade.setTrigger(trans, null); // unhook it\n-                // now erase it:\n-\t\tProjectManager.getManager().getCurrentProject()\n-\t\t\t\t\t\t\t.moveToTrash(evt);\n+                UmlFactory.getFactory().delete(evt); // erase it\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n-\t\tModelFacade.setGuard(trans, null); // unhook it\n-\t\t// now erase it:\n-\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n-\t\t/*ProjectManager.getManager().getCurrentProject()\n-\t\t\t\t\t\t\t.moveToTrash(g);*/\n+\t\tUmlFactory.getFactory().delete(g); // erase it\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n         and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n \t        effect = UmlFactory.getFactory().getCommonBehavior()\n \t\t    .createCallAction();\n \t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n                 String language = ModelFacade.getLanguage(ModelFacade\n \t\t    .getScript(effect));\n                 ModelFacade.setScript(effect, UmlFactory.getFactory()\n \t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n-\t    ModelFacade.setEffect(trans, null);\n+\t    if (effect == null) {\n+                ;// case 3\n+            } else {\n+                // case 4\n+                UmlFactory.getFactory().delete(effect); // erase it\n+            }\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n        if (s.length() > 0) // otherwise an exception in next line\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                UmlFactory.getFactory().delete(evt); // erase it\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tUmlFactory.getFactory().delete(g); // erase it\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    if (effect == null) {\n                ;// case 3\n            } else {\n                // case 4\n                UmlFactory.getFactory().delete(effect); // erase it\n            }\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "547f664cf54b2ff7a8d9cfa09d5fb6d2ef39e4d8": {
            "type": "Ybodychange",
            "commitMessage": "Solve a bug in handling an Effect. Style issues.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5882 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "06/04/04 1:05 PM",
            "commitName": "547f664cf54b2ff7a8d9cfa09d5fb6d2ef39e4d8",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "06/04/04 11:47 AM",
            "commitNameOld": "10c7c61ec067e094a29159187b19755d3daded21",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.05,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,181 +1,178 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n                 // now erase it:\n \t\tProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(evt);\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n-\t\t// Beware: the language should not be reset to \"Java\" or lost.\n \t\t\n \t\t/* TODO: This does not work! Why not? (MVW)\n \t        Object expr = ModelFacade.getExpression(g);\n \t\tModelFacade.setBody(expr,guard);\n \t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tModelFacade.setGuard(trans, null); // unhook it\n \t\t// now erase it:\n \t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n \t\t/*ProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(g);*/\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n-       and hook it to the transition.\n+        and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n-\t/* TODO: If the effect is not a CallAction, then it is reset \n-\tto a CallAction (case 2). */\n-\t/* TODO: The name and language are reset when the expression is \n-\taltered (case 2). */\n \tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n \t    if (effect == null) {  // case 1\n-\t        effect = UmlFactory.getFactory().getCommonBehavior().createCallAction();\n-\t        ModelFacade.setScript(effect, UmlFactory.getFactory().getDataTypes()\n-                                            .createActionExpression(\"Java\", actions));\n+\t        effect = UmlFactory.getFactory().getCommonBehavior()\n+\t\t    .createCallAction();\n+\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n+\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n \t        ModelFacade.setName(effect, \"anon\");\n \t        ModelFacade.setEffect(trans, effect);\n \t    } else {  // case 2\n-                String language = ModelFacade.getLanguage(ModelFacade.getExpression(g));\n-                ModelFacade.setScript(effect, UmlFactory.getFactory().getDataTypes()\n-                        .createActionExpression(language, actions));\n+                String language = ModelFacade.getLanguage(ModelFacade\n+\t\t    .getScript(effect));\n+                ModelFacade.setScript(effect, UmlFactory.getFactory()\n+\t\t    .getDataTypes().createActionExpression(language, actions));\n \t    }\n \t} else {  // case 3 & 4\n \t    ModelFacade.setEffect(trans, null);\n \t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it:\n\t\tProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(evt);\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t\t/*ProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(g);*/\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior()\n\t\t    .createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade\n\t\t    .getScript(effect));\n                ModelFacade.setScript(effect, UmlFactory.getFactory()\n\t\t    .getDataTypes().createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    ModelFacade.setEffect(trans, null);\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "10c7c61ec067e094a29159187b19755d3daded21": {
            "type": "Ybodychange",
            "commitMessage": "Issue 2541. Solved these 2 bugs:\nIf the effect is not a CallAction, then it is reset to a CallAction (case 2).\nThe name and language are reset when the expression is altered (case 2).\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5881 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "06/04/04 11:47 AM",
            "commitName": "10c7c61ec067e094a29159187b19755d3daded21",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "05/04/04 1:17 PM",
            "commitNameOld": "21a89ecdb5dedf02760621620e714c2447739202",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.94,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,172 +1,181 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n                 // now erase it:\n \t\tProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(evt);\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t// Beware: the language should not be reset to \"Java\" or lost.\n \t\t\n-\t\t//TODO: This does not work! Why not?\n-\t        //Object expr = ModelFacade.getExpression(g);\n-\t\t//ModelFacade.setBody(expr,guard);\n+\t\t/* TODO: This does not work! Why not? (MVW)\n+\t        Object expr = ModelFacade.getExpression(g);\n+\t\tModelFacade.setBody(expr,guard);\n+\t\tModelFacade.setExpression(g,expr); */\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n-                LOG.info(\"Guard - Case 2 - Language = '\" + language + \"'.\");\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tModelFacade.setGuard(trans, null); // unhook it\n \t\t// now erase it:\n \t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n \t\t/*ProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(g);*/\n \t    }\n \t}\n \n         /* handle the Effect (Action)\n         We can distinct between 4 cases:\n         1. An effect is given. None exists yet.\n         2. The expression of the effect was present, but is altered.\n         3. An effct is not given. None exists yet.\n         4. The expression of the effect was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new CallAction, set its name, language & expression, \n        and hook it to the transition.\n         2. Change the effect's expression. Leave the actiontype, name & \n \tlanguage untouched.\n         3. Nop.\n         4. Unhook and erase the existing effect.\n         */\n \t/* TODO: If the effect is not a CallAction, then it is reset \n \tto a CallAction (case 2). */\n \t/* TODO: The name and language are reset when the expression is \n \taltered (case 2). */\n+\tObject effect = ModelFacade.getEffect(trans);\n \tif (actions.length() > 0) {\n-\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n-\t    ModelFacade.setName(effect, \"anon\");\n-\t    ModelFacade.setEffect(trans, effect);\n-\t}\n-\telse // case 3 & 4\n+\t    if (effect == null) {  // case 1\n+\t        effect = UmlFactory.getFactory().getCommonBehavior().createCallAction();\n+\t        ModelFacade.setScript(effect, UmlFactory.getFactory().getDataTypes()\n+                                            .createActionExpression(\"Java\", actions));\n+\t        ModelFacade.setName(effect, \"anon\");\n+\t        ModelFacade.setEffect(trans, effect);\n+\t    } else {  // case 2\n+                String language = ModelFacade.getLanguage(ModelFacade.getExpression(g));\n+                ModelFacade.setScript(effect, UmlFactory.getFactory().getDataTypes()\n+                        .createActionExpression(language, actions));\n+\t    }\n+\t} else {  // case 3 & 4\n \t    ModelFacade.setEffect(trans, null);\n+\t}\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it:\n\t\tProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(evt);\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t// Beware: the language should not be reset to \"Java\" or lost.\n\t\t\n\t\t/* TODO: This does not work! Why not? (MVW)\n\t        Object expr = ModelFacade.getExpression(g);\n\t\tModelFacade.setBody(expr,guard);\n\t\tModelFacade.setExpression(g,expr); */\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t\t/*ProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(g);*/\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n       and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\t/* TODO: If the effect is not a CallAction, then it is reset \n\tto a CallAction (case 2). */\n\t/* TODO: The name and language are reset when the expression is \n\taltered (case 2). */\n\tObject effect = ModelFacade.getEffect(trans);\n\tif (actions.length() > 0) {\n\t    if (effect == null) {  // case 1\n\t        effect = UmlFactory.getFactory().getCommonBehavior().createCallAction();\n\t        ModelFacade.setScript(effect, UmlFactory.getFactory().getDataTypes()\n                                            .createActionExpression(\"Java\", actions));\n\t        ModelFacade.setName(effect, \"anon\");\n\t        ModelFacade.setEffect(trans, effect);\n\t    } else {  // case 2\n                String language = ModelFacade.getLanguage(ModelFacade.getExpression(g));\n                ModelFacade.setScript(effect, UmlFactory.getFactory().getDataTypes()\n                        .createActionExpression(language, actions));\n\t    }\n\t} else {  // case 3 & 4\n\t    ModelFacade.setEffect(trans, null);\n\t}\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "21a89ecdb5dedf02760621620e714c2447739202": {
            "type": "Ybodychange",
            "commitMessage": "Added comments about how to handle an Effect. Issue 2541.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5878 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "05/04/04 1:17 PM",
            "commitName": "21a89ecdb5dedf02760621620e714c2447739202",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "04/04/04 9:19 AM",
            "commitNameOld": "8cec53660cffeb36087c77ea34d47b17381188e2",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 1.17,
            "commitsBetweenForRepo": 7,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,154 +1,172 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n                 // now erase it:\n \t\tProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(evt);\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2   \n \t\t// Beware: the language should not be reset to \"Java\" or lost.\n \t\t\n \t\t//TODO: This does not work! Why not?\n \t        //Object expr = ModelFacade.getExpression(g);\n \t\t//ModelFacade.setBody(expr,guard);\n \t        \n \t        //hence a less elegant workaround that works:\n \t        String language = \n \t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n                 LOG.info(\"Guard - Case 2 - Language = '\" + language + \"'.\");\n \t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                     .getDataTypes().createBooleanExpression(language, guard));\n                 /*  TODO: In this case, the properties panel is not updated \n \t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tModelFacade.setGuard(trans, null); // unhook it\n \t\t// now erase it:\n \t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n \t\t/*ProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(g);*/\n \t    }\n \t}\n \n+        /* handle the Effect (Action)\n+        We can distinct between 4 cases:\n+        1. An effect is given. None exists yet.\n+        2. The expression of the effect was present, but is altered.\n+        3. An effct is not given. None exists yet.\n+        4. The expression of the effect was present, but is removed.\n+        The reaction in these cases should be:\n+        1. Create a new CallAction, set its name, language & expression, \n+       and hook it to the transition.\n+        2. Change the effect's expression. Leave the actiontype, name & \n+\tlanguage untouched.\n+        3. Nop.\n+        4. Unhook and erase the existing effect.\n+        */\n+\t/* TODO: If the effect is not a CallAction, then it is reset \n+\tto a CallAction (case 2). */\n+\t/* TODO: The name and language are reset when the expression is \n+\taltered (case 2). */\n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n-\telse\n+\telse // case 3 & 4\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it:\n\t\tProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(evt);\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t// Beware: the language should not be reset to \"Java\" or lost.\n\t\t\n\t\t//TODO: This does not work! Why not?\n\t        //Object expr = ModelFacade.getExpression(g);\n\t\t//ModelFacade.setBody(expr,guard);\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n                LOG.info(\"Guard - Case 2 - Language = '\" + language + \"'.\");\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t\t/*ProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(g);*/\n\t    }\n\t}\n\n        /* handle the Effect (Action)\n        We can distinct between 4 cases:\n        1. An effect is given. None exists yet.\n        2. The expression of the effect was present, but is altered.\n        3. An effct is not given. None exists yet.\n        4. The expression of the effect was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new CallAction, set its name, language & expression, \n       and hook it to the transition.\n        2. Change the effect's expression. Leave the actiontype, name & \n\tlanguage untouched.\n        3. Nop.\n        4. Unhook and erase the existing effect.\n        */\n\t/* TODO: If the effect is not a CallAction, then it is reset \n\tto a CallAction (case 2). */\n\t/* TODO: The name and language are reset when the expression is \n\taltered (case 2). */\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse // case 3 & 4\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "8cec53660cffeb36087c77ea34d47b17381188e2": {
            "type": "Ybodychange",
            "commitMessage": "Changing a guard on the diagram now retains the language. Issue 2541.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5870 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "04/04/04 9:19 AM",
            "commitName": "8cec53660cffeb36087c77ea34d47b17381188e2",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "03/04/04 10:41 PM",
            "commitNameOld": "3cf3cf89b00ca66a682294aa97f19be0e26ddc17",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.4,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,146 +1,154 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \tLOG.debug(\"name=|\" + name + \"|\");\n \tLOG.debug(\"trigger=|\" + trigger + \"|\");\n \tLOG.debug(\"guard=|\" + guard + \"|\");\n \tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n-                /* TODO: Why not createCallEvent() in the next line? */\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n                 // now erase it:\n \t\tProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(evt);\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n-                // case 2\n-\t\t/* TODO: Creating a new expression here, \n-\t\twhich causes the language to be reset to \"Java\".  \n-\t\tInstead we should only change the string! */\n-\t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n-\t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n+                // case 2   \n+\t\t// Beware: the language should not be reset to \"Java\" or lost.\n+\t\t\n+\t\t//TODO: This does not work! Why not?\n+\t        //Object expr = ModelFacade.getExpression(g);\n+\t\t//ModelFacade.setBody(expr,guard);\n+\t        \n+\t        //hence a less elegant workaround that works:\n+\t        String language = \n+\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n+                LOG.info(\"Guard - Case 2 - Language = '\" + language + \"'.\");\n+\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n+                    .getDataTypes().createBooleanExpression(language, guard));\n+                /*  TODO: In this case, the properties panel is not updated \n+\t\t    with the changed expression!  */\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tModelFacade.setGuard(trans, null); // unhook it\n \t\t// now erase it:\n \t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n \t\t/*ProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(g);*/\n \t    }\n \t}\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it:\n\t\tProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(evt);\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2   \n\t\t// Beware: the language should not be reset to \"Java\" or lost.\n\t\t\n\t\t//TODO: This does not work! Why not?\n\t        //Object expr = ModelFacade.getExpression(g);\n\t\t//ModelFacade.setBody(expr,guard);\n\t        \n\t        //hence a less elegant workaround that works:\n\t        String language = \n\t\t\tModelFacade.getLanguage(ModelFacade.getExpression(g));\n                LOG.info(\"Guard - Case 2 - Language = '\" + language + \"'.\");\n\t        ModelFacade.setExpression(g, UmlFactory.getFactory()\n                    .getDataTypes().createBooleanExpression(language, guard));\n                /*  TODO: In this case, the properties panel is not updated \n\t\t    with the changed expression!  */\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t\t/*ProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(g);*/\n\t    }\n\t}\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "3cf3cf89b00ca66a682294aa97f19be0e26ddc17": {
            "type": "Ybodychange",
            "commitMessage": "Replaced _cat by LOG (by deprecating the latter).\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5866 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "03/04/04 10:41 PM",
            "commitName": "3cf3cf89b00ca66a682294aa97f19be0e26ddc17",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "20/03/04 12:55 PM",
            "commitNameOld": "66c46530ff4bedf0c57d40f59e43e509d7faf71b",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 14.41,
            "commitsBetweenForRepo": 33,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,146 +1,146 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n-\t_cat.debug(\"name=|\" + name + \"|\");\n-\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n-\t_cat.debug(\"guard=|\" + guard + \"|\");\n-\t_cat.debug(\"actions=|\" + actions + \"|\");\n+\tLOG.debug(\"name=|\" + name + \"|\");\n+\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n+\tLOG.debug(\"guard=|\" + guard + \"|\");\n+\tLOG.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 /* TODO: Why not createCallEvent() in the next line? */\n                 evt = UmlFactory.getFactory().getStateMachines()\n \t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n                 // now erase it:\n \t\tProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(evt);\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2\n \t\t/* TODO: Creating a new expression here, \n \t\twhich causes the language to be reset to \"Java\".  \n \t\tInstead we should only change the string! */\n \t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tModelFacade.setGuard(trans, null); // unhook it\n \t\t// now erase it:\n \t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n \t\t/*ProjectManager.getManager().getCurrentProject()\n \t\t\t\t\t\t\t.moveToTrash(g);*/\n \t    }\n \t}\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\tLOG.debug(\"name=|\" + name + \"|\");\n\tLOG.debug(\"trigger=|\" + trigger + \"|\");\n\tLOG.debug(\"guard=|\" + guard + \"|\");\n\tLOG.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                /* TODO: Why not createCallEvent() in the next line? */\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it:\n\t\tProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(evt);\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2\n\t\t/* TODO: Creating a new expression here, \n\t\twhich causes the language to be reset to \"Java\".  \n\t\tInstead we should only change the string! */\n\t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t\t/*ProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(g);*/\n\t    }\n\t}\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "66c46530ff4bedf0c57d40f59e43e509d7faf71b": {
            "type": "Ybodychange",
            "commitMessage": "Issue 2541: I managed to erase the Event in case 4.\nI hope it is the correct way...  At least the explorer & diagram get updated.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5832 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "20/03/04 12:55 PM",
            "commitName": "66c46530ff4bedf0c57d40f59e43e509d7faf71b",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "19/03/04 7:40 AM",
            "commitNameOld": "5bc0511b92af047aacf04c9c92a1ff6987ff3838",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 1.22,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,144 +1,146 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. Rename the trigger.\n         3. Nop.\n         4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 /* TODO: Why not createCallEvent() in the next line? */\n-                evt = UmlFactory.getFactory().getStateMachines().buildCallEvent();\n+                evt = UmlFactory.getFactory().getStateMachines()\n+\t\t\t\t\t\t \t.buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n             if (evt == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n-                // now erase it\n-                /* TODO: Erase the event!*/\n-                /* This does not work: (and besides, it can be another kind of event) */\n-                /* StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt); */\n+                // now erase it:\n+\t\tProjectManager.getManager().getCurrentProject()\n+\t\t\t\t\t\t\t.moveToTrash(evt);\n             }\n         }\n \n \t/* handle the Guard\n \tWe can distinct between 4 cases:\n         1. A guard is given. None exists yet.\n         2. The expression of the guard was present, but is altered.\n         3. A guard is not given. None exists yet.\n         4. The expression of the guard was present, but is removed.\n         The reaction in these cases should be:\n         1. Create a new guard, set its name, language & expression, \n \t   and hook it to the transition.\n         2. Change the guard's expression. Leave the name & language untouched.\n         3. Nop.\n         4. Unhook and erase the existing guard.\n         */\n \tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n \t    if (g == null) {\n                 // case 1\n \t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n \t\tif (g != null) {\n \t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n \t\t    ModelFacade.setName(g, \"anon\");\n \t\t    ModelFacade.setTransition(g, trans);\n \t\t    ModelFacade.setGuard(trans, g);\n \t\t}\n \t    } else {\n                 // case 2\n \t\t/* TODO: Creating a new expression here, \n \t\twhich causes the language to be reset to \"Java\".  \n \t\tInstead we should only change the string! */\n \t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n \t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n \t    }\n \t} else { \n \t    if (g == null) {\n                 ;// case 3\n \t    } else {\n                 // case 4\n \t\tModelFacade.setGuard(trans, null); // unhook it\n \t\t// now erase it:\n \t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n+\t\t/*ProjectManager.getManager().getCurrentProject()\n+\t\t\t\t\t\t\t.moveToTrash(g);*/\n \t    }\n \t}\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                /* TODO: Why not createCallEvent() in the next line? */\n                evt = UmlFactory.getFactory().getStateMachines()\n\t\t\t\t\t\t \t.buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it:\n\t\tProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(evt);\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2\n\t\t/* TODO: Creating a new expression here, \n\t\twhich causes the language to be reset to \"Java\".  \n\t\tInstead we should only change the string! */\n\t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t\t/*ProjectManager.getManager().getCurrentProject()\n\t\t\t\t\t\t\t.moveToTrash(g);*/\n\t    }\n\t}\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "5bc0511b92af047aacf04c9c92a1ff6987ff3838": {
            "type": "Ybodychange",
            "commitMessage": "Issue 2541: About the creation of a guard on a transition.\nIn case 2 (see description in the new code)the creation used to work, but the name of the guard was reset back to \"anon\", and the language to \"Java\".\nNow I changed the code to retain the name. The language not yet.\nIn case 4 the guard was not erased, simply unhooked. Maybe that's enough? I do not know, hence added a \"TODO:\" in the code.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5827 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "19/03/04 7:40 AM",
            "commitName": "5bc0511b92af047aacf04c9c92a1ff6987ff3838",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "18/03/04 12:14 PM",
            "commitNameOld": "4bb3b53cd9428bc0bdfec609c273867d3192d33f",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.81,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,111 +1,144 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n         // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n         /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n-        The reaction in these cases is:\n+        The reaction in these cases should be:\n         1. Create a new trigger, name it, and hook it to the transition.\n-        2. The trigger is renamed.\n+        2. Rename the trigger.\n         3. Nop.\n-        4. The existing trigger is unhooked and erased.\n+        4. Unhook and erase the existing trigger.\n         \n         In fact it is even more complicated for case 1:\n         If the transition did not have a trigger before, \n         a trigger-name is given, and a trigger already\n         existed with that name,\n         then we have to use the existing trigger object!\n         */\n         Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n                 /* TODO: Why not createCallEvent() in the next line? */\n                 evt = UmlFactory.getFactory().getStateMachines().buildCallEvent();\n                 if (evt != null) {\n                     ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n-            if (trigger.length() == 0) {\n+            if (evt == null) {\n+                ;// case 3\n+\t    } else {\n                 // case 4\n                 ModelFacade.setTrigger(trans, null); // unhook it\n                 // now erase it\n                 /* TODO: Erase the event!*/\n                 /* This does not work: (and besides, it can be another kind of event) */\n                 /* StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt); */\n-            } else {\n-                ;// case 3\n             }\n         }\n \n+\t/* handle the Guard\n+\tWe can distinct between 4 cases:\n+        1. A guard is given. None exists yet.\n+        2. The expression of the guard was present, but is altered.\n+        3. A guard is not given. None exists yet.\n+        4. The expression of the guard was present, but is removed.\n+        The reaction in these cases should be:\n+        1. Create a new guard, set its name, language & expression, \n+\t   and hook it to the transition.\n+        2. Change the guard's expression. Leave the name & language untouched.\n+        3. Nop.\n+        4. Unhook and erase the existing guard.\n+        */\n+\tObject g = ModelFacade.getGuard(trans);\n \tif (guard.length() > 0) {\n-\t    Object g = parseGuard(guard);\n-\t    if (g != null) {\n-\t\tModelFacade.setName(g, \"anon\");\n-\t\tModelFacade.setTransition(g, trans);\n-\t\tModelFacade.setGuard(trans, g);\n+\t    if (g == null) {\n+                // case 1\n+\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n+\t\tif (g != null) {\n+\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n+\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n+\t\t    ModelFacade.setName(g, \"anon\");\n+\t\t    ModelFacade.setTransition(g, trans);\n+\t\t    ModelFacade.setGuard(trans, g);\n+\t\t}\n+\t    } else {\n+                // case 2\n+\t\t/* TODO: Creating a new expression here, \n+\t\twhich causes the language to be reset to \"Java\".  \n+\t\tInstead we should only change the string! */\n+\t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n+\t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n+\t    }\n+\t} else { \n+\t    if (g == null) {\n+                ;// case 3\n+\t    } else {\n+                // case 4\n+\t\tModelFacade.setGuard(trans, null); // unhook it\n+\t\t// now erase it:\n+\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n \t    }\n \t}\n-\telse\n-\t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. Rename the trigger.\n        3. Nop.\n        4. Unhook and erase the existing trigger.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                /* TODO: Why not createCallEvent() in the next line? */\n                evt = UmlFactory.getFactory().getStateMachines().buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (evt == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it\n                /* TODO: Erase the event!*/\n                /* This does not work: (and besides, it can be another kind of event) */\n                /* StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt); */\n            }\n        }\n\n\t/* handle the Guard\n\tWe can distinct between 4 cases:\n        1. A guard is given. None exists yet.\n        2. The expression of the guard was present, but is altered.\n        3. A guard is not given. None exists yet.\n        4. The expression of the guard was present, but is removed.\n        The reaction in these cases should be:\n        1. Create a new guard, set its name, language & expression, \n\t   and hook it to the transition.\n        2. Change the guard's expression. Leave the name & language untouched.\n        3. Nop.\n        4. Unhook and erase the existing guard.\n        */\n\tObject g = ModelFacade.getGuard(trans);\n\tif (guard.length() > 0) {\n\t    if (g == null) {\n                // case 1\n\t\tg = UmlFactory.getFactory().getStateMachines().createGuard();\n\t\tif (g != null) {\n\t\t    ModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    \t.getDataTypes().createBooleanExpression(\"Java\", guard));\n\t\t    ModelFacade.setName(g, \"anon\");\n\t\t    ModelFacade.setTransition(g, trans);\n\t\t    ModelFacade.setGuard(trans, g);\n\t\t}\n\t    } else {\n                // case 2\n\t\t/* TODO: Creating a new expression here, \n\t\twhich causes the language to be reset to \"Java\".  \n\t\tInstead we should only change the string! */\n\t\tModelFacade.setExpression(g, UmlFactory.getFactory()\n\t\t    .getDataTypes().createBooleanExpression(\"Java\", guard));\n\t    }\n\t} else { \n\t    if (g == null) {\n                ;// case 3\n\t    } else {\n                // case 4\n\t\tModelFacade.setGuard(trans, null); // unhook it\n\t\t// now erase it:\n\t\t/* TODO: Erase the guard and the expression, or shouldn't we? */\n\t    }\n\t}\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "4bb3b53cd9428bc0bdfec609c273867d3192d33f": {
            "type": "Ybodychange",
            "commitMessage": "Improved comments & clarified code.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5826 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "18/03/04 12:14 PM",
            "commitName": "4bb3b53cd9428bc0bdfec609c273867d3192d33f",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "17/03/04 1:36 PM",
            "commitNameOld": "2ab27dd030dd71ad056acf9d29de903e765e8987",
            "commitAuthorOld": "Michael Stockman",
            "daysBetweenCommits": 0.94,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,102 +1,111 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n-        // strip of the name, and the \":\"\n+        // strip off the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n+        // use the name we found to (re)name the transition\n \tModelFacade.setName(trans, name);\n \n-        /* The following handles the callevent that is the trigger of\n+        /* The following handles the CallEvent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases is:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. The trigger is renamed.\n         3. Nop.\n         4. The existing trigger is unhooked and erased.\n         \n-        In fact it is even more complicated:\n-        If a new/changed name is given for a trigger, and a trigger already\n-        existed with that name, which was not yet hooked to this transition,\n-        then it would be necessary in these cases to use the existing object!\n+        In fact it is even more complicated for case 1:\n+        If the transition did not have a trigger before, \n+        a trigger-name is given, and a trigger already\n+        existed with that name,\n+        then we have to use the existing trigger object!\n         */\n-        Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n+        Object evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null) {\n                 // case 1\n-                evt = parseEvent(trigger);\n+                /* TODO: Why not createCallEvent() in the next line? */\n+                evt = UmlFactory.getFactory().getStateMachines().buildCallEvent();\n                 if (evt != null) {\n+                    ModelFacade.setName(evt, trigger);\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t} else { \n             // case 3 and 4\n-\t    ModelFacade.setTrigger(trans, null); // unhook it\n-            //ModelFacade.removexxxx(evt); // erase it\n-            /* This does not work:\n-            StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n-            TODO: Erase the event!*/\n+            if (trigger.length() == 0) {\n+                // case 4\n+                ModelFacade.setTrigger(trans, null); // unhook it\n+                // now erase it\n+                /* TODO: Erase the event!*/\n+                /* This does not work: (and besides, it can be another kind of event) */\n+                /* StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt); */\n+            } else {\n+                ;// case 3\n+            }\n         }\n \n \tif (guard.length() > 0) {\n \t    Object g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tModelFacade.setTransition(g, trans);\n \t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n \t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip off the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n        // use the name we found to (re)name the transition\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the CallEvent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases is:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. The trigger is renamed.\n        3. Nop.\n        4. The existing trigger is unhooked and erased.\n        \n        In fact it is even more complicated for case 1:\n        If the transition did not have a trigger before, \n        a trigger-name is given, and a trigger already\n        existed with that name,\n        then we have to use the existing trigger object!\n        */\n        Object evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                /* TODO: Why not createCallEvent() in the next line? */\n                evt = UmlFactory.getFactory().getStateMachines().buildCallEvent();\n                if (evt != null) {\n                    ModelFacade.setName(evt, trigger);\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n            if (trigger.length() == 0) {\n                // case 4\n                ModelFacade.setTrigger(trans, null); // unhook it\n                // now erase it\n                /* TODO: Erase the event!*/\n                /* This does not work: (and besides, it can be another kind of event) */\n                /* StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt); */\n            } else {\n                ;// case 3\n            }\n        }\n\n\tif (guard.length() > 0) {\n\t    Object g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "21546cc8946c6a86a94098c25d9d5fbf9b82698e": {
            "type": "Ybodychange",
            "commitMessage": "Checkstyle issues & clarified comment.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5818 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "14/03/04 1:45 PM",
            "commitName": "21546cc8946c6a86a94098c25d9d5fbf9b82698e",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "14/03/04 1:33 AM",
            "commitNameOld": "1cf53f99717ae24f050f38d4e0eabbfd33ef38e8",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 0.51,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,102 +1,102 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip of the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, name);\n \n         /* The following handles the callevent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n         2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n         4. The name of the trigger was present, but is removed.\n         The reaction in these cases is:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. The trigger is renamed.\n         3. Nop.\n         4. The existing trigger is unhooked and erased.\n         \n         In fact it is even more complicated:\n         If a new/changed name is given for a trigger, and a trigger already\n-        existed with that name, which was not yet hooked to this transition.\n-        It would be necessary in these cases to use the existing object!\n+        existed with that name, which was not yet hooked to this transition,\n+        then it would be necessary in these cases to use the existing object!\n         */\n         Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n-            if (evt == null){\n+            if (evt == null) {\n                 // case 1\n                 evt = parseEvent(trigger);\n                 if (evt != null) {\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n-            }else {\n+            } else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n-\t}else { \n+\t} else { \n             // case 3 and 4\n \t    ModelFacade.setTrigger(trans, null); // unhook it\n             //ModelFacade.removexxxx(evt); // erase it\n             /* This does not work:\n             StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n             TODO: Erase the event!*/\n         }\n \n \tif (guard.length() > 0) {\n \t    Object g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tModelFacade.setTransition(g, trans);\n \t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n \t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip of the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the callevent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases is:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. The trigger is renamed.\n        3. Nop.\n        4. The existing trigger is unhooked and erased.\n        \n        In fact it is even more complicated:\n        If a new/changed name is given for a trigger, and a trigger already\n        existed with that name, which was not yet hooked to this transition,\n        then it would be necessary in these cases to use the existing object!\n        */\n        Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null) {\n                // case 1\n                evt = parseEvent(trigger);\n                if (evt != null) {\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            } else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t} else { \n            // case 3 and 4\n\t    ModelFacade.setTrigger(trans, null); // unhook it\n            //ModelFacade.removexxxx(evt); // erase it\n            /* This does not work:\n            StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n            TODO: Erase the event!*/\n        }\n\n\tif (guard.length() > 0) {\n\t    Object g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "1cf53f99717ae24f050f38d4e0eabbfd33ef38e8": {
            "type": "Ybodychange",
            "commitMessage": "Issue 2541: updating of triggers in the diagram - added comment.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5817 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "14/03/04 1:33 AM",
            "commitName": "1cf53f99717ae24f050f38d4e0eabbfd33ef38e8",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "11/03/04 9:47 AM",
            "commitNameOld": "6116c5944ed0c2388600c46619fbd82321081755",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 2.66,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,97 +1,102 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n         // strip of the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n         // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n         // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n         // and the remainder is the trigger\n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, name);\n \n         /* The following handles the callevent that is the trigger of\n         this transition. \n         We can distinct between 4 cases:\n         1. A trigger is given. None exists yet.\n-        2. A trigger is given. One exists already.\n+        2. The name of the trigger was present, but is altered.\n         3. A trigger is not given. None exists yet.\n-        4. A trigger is not given. One exists already.\n+        4. The name of the trigger was present, but is removed.\n         The reaction in these cases is:\n         1. Create a new trigger, name it, and hook it to the transition.\n         2. The trigger is renamed.\n         3. Nop.\n         4. The existing trigger is unhooked and erased.\n+        \n+        In fact it is even more complicated:\n+        If a new/changed name is given for a trigger, and a trigger already\n+        existed with that name, which was not yet hooked to this transition.\n+        It would be necessary in these cases to use the existing object!\n         */\n         Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n             // case 1 and 2\n             if (evt == null){\n                 // case 1\n                 evt = parseEvent(trigger);\n                 if (evt != null) {\n                     ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                 }\n             }else {\n                 // case 2\n                 ModelFacade.setName(evt, trigger);\n             }\n \t}else { \n             // case 3 and 4\n \t    ModelFacade.setTrigger(trans, null); // unhook it\n             //ModelFacade.removexxxx(evt); // erase it\n             /* This does not work:\n             StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n             TODO: Erase the event!*/\n         }\n \n \tif (guard.length() > 0) {\n \t    Object g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tModelFacade.setTransition(g, trans);\n \t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n \t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip of the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the callevent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. The name of the trigger was present, but is altered.\n        3. A trigger is not given. None exists yet.\n        4. The name of the trigger was present, but is removed.\n        The reaction in these cases is:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. The trigger is renamed.\n        3. Nop.\n        4. The existing trigger is unhooked and erased.\n        \n        In fact it is even more complicated:\n        If a new/changed name is given for a trigger, and a trigger already\n        existed with that name, which was not yet hooked to this transition.\n        It would be necessary in these cases to use the existing object!\n        */\n        Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null){\n                // case 1\n                evt = parseEvent(trigger);\n                if (evt != null) {\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            }else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t}else { \n            // case 3 and 4\n\t    ModelFacade.setTrigger(trans, null); // unhook it\n            //ModelFacade.removexxxx(evt); // erase it\n            /* This does not work:\n            StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n            TODO: Erase the event!*/\n        }\n\n\tif (guard.length() > 0) {\n\t    Object g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "6116c5944ed0c2388600c46619fbd82321081755": {
            "type": "Ybodychange",
            "commitMessage": "Issue 2541: updating of triggers in the diagram - solved case 2 (see description in issue 2541).\nSolved some Checkstyle issues.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@5812 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "11/03/04 9:47 AM",
            "commitName": "6116c5944ed0c2388600c46619fbd82321081755",
            "commitAuthor": "Michiel van der Wulp",
            "commitDateOld": "08/03/04 11:36 AM",
            "commitNameOld": "ab259d28ce8a26976720998420906274d038ff8c",
            "commitAuthorOld": "Michiel van der Wulp",
            "daysBetweenCommits": 2.92,
            "commitsBetweenForRepo": 16,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,97 @@\n     public Object parseTransition(Object trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n+        // strip of the name, and the \":\"\n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n+        // get the guard from between the []\n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n+        // everything behind the \"/\" is the action\n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n+        // and the remainder is the trigger\n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, name);\n \n+        /* The following handles the callevent that is the trigger of\n+        this transition. \n+        We can distinct between 4 cases:\n+        1. A trigger is given. None exists yet.\n+        2. A trigger is given. One exists already.\n+        3. A trigger is not given. None exists yet.\n+        4. A trigger is not given. One exists already.\n+        The reaction in these cases is:\n+        1. Create a new trigger, name it, and hook it to the transition.\n+        2. The trigger is renamed.\n+        3. Nop.\n+        4. The existing trigger is unhooked and erased.\n+        */\n+        Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n \tif (trigger.length() > 0) {\n-\t    Object/*MEvent*/ evt = parseEvent(trigger);\n-\t    if (evt != null) {\n-\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n-\t    }\n-\t}\n-\telse {\n-\t    ModelFacade.setTrigger(trans, null);\n+            // case 1 and 2\n+            if (evt == null){\n+                // case 1\n+                evt = parseEvent(trigger);\n+                if (evt != null) {\n+                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n+                }\n+            }else {\n+                // case 2\n+                ModelFacade.setName(evt, trigger);\n+            }\n+\t}else { \n+            // case 3 and 4\n+\t    ModelFacade.setTrigger(trans, null); // unhook it\n+            //ModelFacade.removexxxx(evt); // erase it\n+            /* This does not work:\n+            StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n+            TODO: Erase the event!*/\n         }\n \n \tif (guard.length() > 0) {\n \t    Object g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tModelFacade.setTransition(g, trans);\n \t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n \t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n        // strip of the name, and the \":\"\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n        // get the guard from between the []\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n        // everything behind the \"/\" is the action\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n        // and the remainder is the trigger\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, name);\n\n        /* The following handles the callevent that is the trigger of\n        this transition. \n        We can distinct between 4 cases:\n        1. A trigger is given. None exists yet.\n        2. A trigger is given. One exists already.\n        3. A trigger is not given. None exists yet.\n        4. A trigger is not given. One exists already.\n        The reaction in these cases is:\n        1. Create a new trigger, name it, and hook it to the transition.\n        2. The trigger is renamed.\n        3. Nop.\n        4. The existing trigger is unhooked and erased.\n        */\n        Object /*MEvent*/ evt = ModelFacade.getTrigger(trans);\n\tif (trigger.length() > 0) {\n            // case 1 and 2\n            if (evt == null){\n                // case 1\n                evt = parseEvent(trigger);\n                if (evt != null) {\n                    ModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n                }\n            }else {\n                // case 2\n                ModelFacade.setName(evt, trigger);\n            }\n\t}else { \n            // case 3 and 4\n\t    ModelFacade.setTrigger(trans, null); // unhook it\n            //ModelFacade.removexxxx(evt); // erase it\n            /* This does not work:\n            StateMachinesFactory.getFactory().deleteCallEvent((MCallEvent) evt);\n            TODO: Erase the event!*/\n        }\n\n\tif (guard.length() > 0) {\n\t    Object g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "362a7c39bbb6c8990d50fe8121f444d03a20942b": {
            "type": "Ybodychange",
            "commitMessage": "Removed dead code.\nDeprecated unused methods.\nMade some methods unused that shouldn't be used.\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4998 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "28/09/03 6:48 AM",
            "commitName": "362a7c39bbb6c8990d50fe8121f444d03a20942b",
            "commitAuthor": "Michael Stockman",
            "commitDateOld": "28/09/03 5:13 AM",
            "commitNameOld": "e4272a087ef58ee152af8b5db1507e31ce578786",
            "commitAuthorOld": "Michael Stockman",
            "daysBetweenCommits": 0.07,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,68 @@\n     public Object parseTransition(Object/*MTransition*/ trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n-\tModelFacade.setName(trans, parseName(name));\n+\tModelFacade.setName(trans, name);\n \n \tif (trigger.length() > 0) {\n \t    Object/*MEvent*/ evt = parseEvent(trigger);\n \t    if (evt != null) {\n \t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n \t    }\n \t}\n \telse {\n \t    ModelFacade.setTrigger(trans, null);\n         }\n \n \tif (guard.length() > 0) {\n \t    Object g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tModelFacade.setTransition(g, trans);\n \t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n \t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, name);\n\n\tif (trigger.length() > 0) {\n\t    Object/*MEvent*/ evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n\t    }\n\t}\n\telse {\n\t    ModelFacade.setTrigger(trans, null);\n        }\n\n\tif (guard.length() > 0) {\n\t    Object g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "88726d321b2ef7e02695f5a887b1e8c4fbefb9fa": {
            "type": "Ybodychange",
            "commitMessage": "Hide NSUML\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4888 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "14/09/03 8:04 AM",
            "commitName": "88726d321b2ef7e02695f5a887b1e8c4fbefb9fa",
            "commitAuthor": "Bob Tarling",
            "commitDateOld": "14/09/03 6:03 AM",
            "commitNameOld": "b3835ae2e2854cd30f2ee150f52775852df8ee98",
            "commitAuthorOld": "Bob Tarling",
            "daysBetweenCommits": 0.08,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,68 @@\n     public Object parseTransition(Object/*MTransition*/ trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, parseName(name));\n \n \tif (trigger.length() > 0) {\n-\t    MEvent evt = parseEvent(trigger);\n+\t    Object/*MEvent*/ evt = parseEvent(trigger);\n \t    if (evt != null) {\n \t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n \t    }\n \t}\n \telse {\n \t    ModelFacade.setTrigger(trans, null);\n         }\n \n \tif (guard.length() > 0) {\n-\t    MGuard g = parseGuard(guard);\n+\t    Object g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tModelFacade.setTransition(g, trans);\n \t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n \t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, parseName(name));\n\n\tif (trigger.length() > 0) {\n\t    Object/*MEvent*/ evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n\t    }\n\t}\n\telse {\n\t    ModelFacade.setTrigger(trans, null);\n        }\n\n\tif (guard.length() > 0) {\n\t    Object g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "fc2967aac59ed26d78323f4c27232dd1489fec77": {
            "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
            "commitMessage": "Un-NSUML\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4879 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "13/09/03 6:51 PM",
            "commitName": "fc2967aac59ed26d78323f4c27232dd1489fec77",
            "commitAuthor": "Bob Tarling",
            "subchanges": [
                {
                    "type": "Yparameterchange",
                    "commitMessage": "Un-NSUML\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4879 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "13/09/03 6:51 PM",
                    "commitName": "fc2967aac59ed26d78323f4c27232dd1489fec77",
                    "commitAuthor": "Bob Tarling",
                    "commitDateOld": "08/09/03 1:11 PM",
                    "commitNameOld": "bc370f3eacf056714215537f54650c50114ff5b1",
                    "commitAuthorOld": "Bob Tarling",
                    "daysBetweenCommits": 5.24,
                    "commitsBetweenForRepo": 56,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,67 +1,68 @@\n-    public MTransition parseTransition(MTransition trans, String s) {\n+    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, parseName(name));\n \n \tif (trigger.length() > 0) {\n \t    MEvent evt = parseEvent(trigger);\n \t    if (evt != null) {\n-\t\ttrans.setTrigger(/*(MCallEvent)*/ evt);\n+\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n \t    }\n \t}\n-\telse\n-\t    trans.setTrigger(null);\n+\telse {\n+\t    ModelFacade.setTrigger(trans, null);\n+        }\n \n \tif (guard.length() > 0) {\n \t    MGuard g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n-\t\tg.setTransition(trans);\n-\t\ttrans.setGuard(g);\n+\t\tModelFacade.setTransition(g, trans);\n+\t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n-\t    trans.setGuard(null);\n+\t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, parseName(name));\n\n\tif (trigger.length() > 0) {\n\t    MEvent evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n\t    }\n\t}\n\telse {\n\t    ModelFacade.setTrigger(trans, null);\n        }\n\n\tif (guard.length() > 0) {\n\t    MGuard g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {
                        "oldValue": "[trans-MTransition, s-String]",
                        "newValue": "[trans-Object, s-String]"
                    }
                },
                {
                    "type": "Yreturntypechange",
                    "commitMessage": "Un-NSUML\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4879 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "13/09/03 6:51 PM",
                    "commitName": "fc2967aac59ed26d78323f4c27232dd1489fec77",
                    "commitAuthor": "Bob Tarling",
                    "commitDateOld": "08/09/03 1:11 PM",
                    "commitNameOld": "bc370f3eacf056714215537f54650c50114ff5b1",
                    "commitAuthorOld": "Bob Tarling",
                    "daysBetweenCommits": 5.24,
                    "commitsBetweenForRepo": 56,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,67 +1,68 @@\n-    public MTransition parseTransition(MTransition trans, String s) {\n+    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, parseName(name));\n \n \tif (trigger.length() > 0) {\n \t    MEvent evt = parseEvent(trigger);\n \t    if (evt != null) {\n-\t\ttrans.setTrigger(/*(MCallEvent)*/ evt);\n+\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n \t    }\n \t}\n-\telse\n-\t    trans.setTrigger(null);\n+\telse {\n+\t    ModelFacade.setTrigger(trans, null);\n+        }\n \n \tif (guard.length() > 0) {\n \t    MGuard g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n-\t\tg.setTransition(trans);\n-\t\ttrans.setGuard(g);\n+\t\tModelFacade.setTransition(g, trans);\n+\t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n-\t    trans.setGuard(null);\n+\t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, parseName(name));\n\n\tif (trigger.length() > 0) {\n\t    MEvent evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n\t    }\n\t}\n\telse {\n\t    ModelFacade.setTrigger(trans, null);\n        }\n\n\tif (guard.length() > 0) {\n\t    MGuard g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {
                        "oldValue": "MTransition",
                        "newValue": "Object"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Un-NSUML\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4879 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "13/09/03 6:51 PM",
                    "commitName": "fc2967aac59ed26d78323f4c27232dd1489fec77",
                    "commitAuthor": "Bob Tarling",
                    "commitDateOld": "08/09/03 1:11 PM",
                    "commitNameOld": "bc370f3eacf056714215537f54650c50114ff5b1",
                    "commitAuthorOld": "Bob Tarling",
                    "daysBetweenCommits": 5.24,
                    "commitsBetweenForRepo": 56,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,67 +1,68 @@\n-    public MTransition parseTransition(MTransition trans, String s) {\n+    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, parseName(name));\n \n \tif (trigger.length() > 0) {\n \t    MEvent evt = parseEvent(trigger);\n \t    if (evt != null) {\n-\t\ttrans.setTrigger(/*(MCallEvent)*/ evt);\n+\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n \t    }\n \t}\n-\telse\n-\t    trans.setTrigger(null);\n+\telse {\n+\t    ModelFacade.setTrigger(trans, null);\n+        }\n \n \tif (guard.length() > 0) {\n \t    MGuard g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n-\t\tg.setTransition(trans);\n-\t\ttrans.setGuard(g);\n+\t\tModelFacade.setTransition(g, trans);\n+\t\tModelFacade.setGuard(trans, g);\n \t    }\n \t}\n \telse\n-\t    trans.setGuard(null);\n+\t    ModelFacade.setGuard(trans, null);\n \n \tif (actions.length() > 0) {\n \t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n \t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n \t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public Object parseTransition(Object/*MTransition*/ trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, parseName(name));\n\n\tif (trigger.length() > 0) {\n\t    MEvent evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\tModelFacade.setTrigger(trans, /*(MCallEvent)*/ evt);\n\t    }\n\t}\n\telse {\n\t    ModelFacade.setTrigger(trans, null);\n        }\n\n\tif (guard.length() > 0) {\n\t    MGuard g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tModelFacade.setTransition(g, trans);\n\t\tModelFacade.setGuard(trans, g);\n\t    }\n\t}\n\telse\n\t    ModelFacade.setGuard(trans, null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "14"
        },
        "bc370f3eacf056714215537f54650c50114ff5b1": {
            "type": "Ybodychange",
            "commitMessage": "NSUML hiding\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4821 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "08/09/03 1:11 PM",
            "commitName": "bc370f3eacf056714215537f54650c50114ff5b1",
            "commitAuthor": "Bob Tarling",
            "commitDateOld": "07/09/03 5:36 PM",
            "commitNameOld": "150cd1cfadd24baa17dd1f704456b6066d148a1c",
            "commitAuthorOld": "Bob Tarling",
            "daysBetweenCommits": 0.82,
            "commitsBetweenForRepo": 26,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,67 +1,67 @@\n     public MTransition parseTransition(MTransition trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n \tModelFacade.setName(trans, parseName(name));\n \n \tif (trigger.length() > 0) {\n \t    MEvent evt = parseEvent(trigger);\n \t    if (evt != null) {\n-\t\ttrans.setTrigger((MCallEvent) evt);\n+\t\ttrans.setTrigger(/*(MCallEvent)*/ evt);\n \t    }\n \t}\n \telse\n \t    trans.setTrigger(null);\n \n \tif (guard.length() > 0) {\n \t    MGuard g = parseGuard(guard);\n \t    if (g != null) {\n \t\tModelFacade.setName(g, \"anon\");\n \t\tg.setTransition(trans);\n \t\ttrans.setGuard(g);\n \t    }\n \t}\n \telse\n \t    trans.setGuard(null);\n \n \tif (actions.length() > 0) {\n-\t    MCallAction effect = (MCallAction) parseAction(actions);\n+\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n \t    ModelFacade.setName(effect, \"anon\");\n-\t    trans.setEffect(effect);\n+\t    ModelFacade.setEffect(trans, effect);\n \t}\n \telse\n-\t    trans.setEffect(null);\n+\t    ModelFacade.setEffect(trans, null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public MTransition parseTransition(MTransition trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, parseName(name));\n\n\tif (trigger.length() > 0) {\n\t    MEvent evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\ttrans.setTrigger(/*(MCallEvent)*/ evt);\n\t    }\n\t}\n\telse\n\t    trans.setTrigger(null);\n\n\tif (guard.length() > 0) {\n\t    MGuard g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tg.setTransition(trans);\n\t\ttrans.setGuard(g);\n\t    }\n\t}\n\telse\n\t    trans.setGuard(null);\n\n\tif (actions.length() > 0) {\n\t    Object effect = /*(MCallAction)*/ parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    ModelFacade.setEffect(trans, effect);\n\t}\n\telse\n\t    ModelFacade.setEffect(trans, null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "24"
        },
        "2ddc06fc6af74e78f2bf2e63bfcd9a7122b433ac": {
            "type": "Ybodychange",
            "commitMessage": "removed some nsuml dependencies from ParserDisplay\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@4613 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "19/08/03 3:14 PM",
            "commitName": "2ddc06fc6af74e78f2bf2e63bfcd9a7122b433ac",
            "commitAuthor": "Thomas Neustupny",
            "commitDateOld": "18/07/03 11:28 AM",
            "commitNameOld": "6b68c1f777dbcc0eaf04c717a43fef4ef8304c2a",
            "commitAuthorOld": "Michael Stockman",
            "daysBetweenCommits": 32.16,
            "commitsBetweenForRepo": 85,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,67 +1,67 @@\n     public MTransition parseTransition(MTransition trans, String s) {\n \t// strip any trailing semi-colons\n \ts = s.trim();\n \tif (s.length() == 0) return null;\n \tif (s.charAt(s.length() - 1) == ';')\n \t    s = s.substring(0, s.length() - 2);\n \n \tString name = \"\";\n \tString trigger = \"\";\n \tString guard = \"\";\n \tString actions = \"\";\n \tif (s.indexOf(\":\", 0) > -1) {\n \t    name = s.substring(0, s.indexOf(\":\")).trim();\n \t    s = s.substring(s.indexOf(\":\") + 1).trim();\n \t}\n \n \tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n \t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n \t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n \t\t\t\t\t\t\t     + 1);\n \t    s = s.trim();\n \t}\n \n \tif (s.indexOf(\"/\", 0) > -1) {\n \t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n \t    s = s.substring(0, s.indexOf(\"/\")).trim();\n \t}\n \n \ttrigger = s;\n \n \t_cat.debug(\"name=|\" + name + \"|\");\n \t_cat.debug(\"trigger=|\" + trigger + \"|\");\n \t_cat.debug(\"guard=|\" + guard + \"|\");\n \t_cat.debug(\"actions=|\" + actions + \"|\");\n \n-\ttrans.setName(parseName(name));\n+\tModelFacade.setName(trans, parseName(name));\n \n \tif (trigger.length() > 0) {\n \t    MEvent evt = parseEvent(trigger);\n \t    if (evt != null) {\n \t\ttrans.setTrigger((MCallEvent) evt);\n \t    }\n \t}\n \telse\n \t    trans.setTrigger(null);\n \n \tif (guard.length() > 0) {\n \t    MGuard g = parseGuard(guard);\n \t    if (g != null) {\n-\t\tg.setName(\"anon\");\n+\t\tModelFacade.setName(g, \"anon\");\n \t\tg.setTransition(trans);\n \t\ttrans.setGuard(g);\n \t    }\n \t}\n \telse\n \t    trans.setGuard(null);\n \n \tif (actions.length() > 0) {\n \t    MCallAction effect = (MCallAction) parseAction(actions);\n-\t    effect.setName(\"anon\");\n+\t    ModelFacade.setName(effect, \"anon\");\n \t    trans.setEffect(effect);\n \t}\n \telse\n \t    trans.setEffect(null);\n \n \treturn trans;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public MTransition parseTransition(MTransition trans, String s) {\n\t// strip any trailing semi-colons\n\ts = s.trim();\n\tif (s.length() == 0) return null;\n\tif (s.charAt(s.length() - 1) == ';')\n\t    s = s.substring(0, s.length() - 2);\n\n\tString name = \"\";\n\tString trigger = \"\";\n\tString guard = \"\";\n\tString actions = \"\";\n\tif (s.indexOf(\":\", 0) > -1) {\n\t    name = s.substring(0, s.indexOf(\":\")).trim();\n\t    s = s.substring(s.indexOf(\":\") + 1).trim();\n\t}\n\n\tif (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n\t    guard = s.substring(s.indexOf(\"[\", 0) + 1, s.indexOf(\"]\")).trim();\n\t    s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")\n\t\t\t\t\t\t\t     + 1);\n\t    s = s.trim();\n\t}\n\n\tif (s.indexOf(\"/\", 0) > -1) {\n\t    actions = s.substring(s.indexOf(\"/\") + 1).trim();\n\t    s = s.substring(0, s.indexOf(\"/\")).trim();\n\t}\n\n\ttrigger = s;\n\n\t_cat.debug(\"name=|\" + name + \"|\");\n\t_cat.debug(\"trigger=|\" + trigger + \"|\");\n\t_cat.debug(\"guard=|\" + guard + \"|\");\n\t_cat.debug(\"actions=|\" + actions + \"|\");\n\n\tModelFacade.setName(trans, parseName(name));\n\n\tif (trigger.length() > 0) {\n\t    MEvent evt = parseEvent(trigger);\n\t    if (evt != null) {\n\t\ttrans.setTrigger((MCallEvent) evt);\n\t    }\n\t}\n\telse\n\t    trans.setTrigger(null);\n\n\tif (guard.length() > 0) {\n\t    MGuard g = parseGuard(guard);\n\t    if (g != null) {\n\t\tModelFacade.setName(g, \"anon\");\n\t\tg.setTransition(trans);\n\t\ttrans.setGuard(g);\n\t    }\n\t}\n\telse\n\t    trans.setGuard(null);\n\n\tif (actions.length() > 0) {\n\t    MCallAction effect = (MCallAction) parseAction(actions);\n\t    ModelFacade.setName(effect, \"anon\");\n\t    trans.setEffect(effect);\n\t}\n\telse\n\t    trans.setEffect(null);\n\n\treturn trans;\n    }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "30"
        },
        "b098714ac13d5ccd052e98c32cce00e609442c2a": {
            "type": "Ybodychange",
            "commitMessage": "Merged the Work0_13_1_b branch into HEAD\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@2638 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "08/10/02 1:04 PM",
            "commitName": "b098714ac13d5ccd052e98c32cce00e609442c2a",
            "commitAuthor": "Jaap Branderhorst",
            "commitDateOld": "30/09/02 9:53 AM",
            "commitNameOld": "4b0efb5687a405f7542ad60a009a6de06ec8a27b",
            "commitAuthorOld": "Michael Stockman",
            "daysBetweenCommits": 8.13,
            "commitsBetweenForRepo": 20,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,66 +1,66 @@\n   public MTransition parseTransition(MTransition trans, String s) {\n     // strip any trailing semi-colons\n     s = s.trim();\n     if (s.length() == 0) return null;\n     if (s.charAt(s.length()-1) == ';')\n       s = s.substring(0, s.length() - 2);\n \n     String name = \"\";\n     String trigger = \"\";\n     String guard = \"\";\n     String actions = \"\";\n     if (s.indexOf(\":\", 0) > -1) {\n       name = s.substring(0, s.indexOf(\":\")).trim();\n       s = s.substring(s.indexOf(\":\") + 1).trim();\n     }\n \n     if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n       guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n       s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n       s = s.trim();\n     }\n \n     if (s.indexOf(\"/\", 0) > -1) {\n       actions = s.substring(s.indexOf(\"/\")+1).trim();\n       s = s.substring(0, s.indexOf(\"/\")).trim();\n     }\n \n     trigger = s;\n \n-    /*     System.out.println(\"name=|\" + name +\"|\");\n-     System.out.println(\"trigger=|\" + trigger +\"|\");\n-     System.out.println(\"guard=|\" + guard +\"|\");\n-     System.out.println(\"actions=|\" + actions +\"|\");\n-    */\n+    _cat.debug(\"name=|\" + name +\"|\");\n+    _cat.debug(\"trigger=|\" + trigger +\"|\");\n+    _cat.debug(\"guard=|\" + guard +\"|\");\n+    _cat.debug(\"actions=|\" + actions +\"|\");\n+    \n     trans.setName(parseName(name));\n \n     if (trigger.length()>0) {\n \tMEvent evt=parseEvent(trigger);\n \tif (evt!=null){\n \t    trans.setTrigger((MCallEvent)evt);\n \t}\n     }\n     else\n \ttrans.setTrigger(null);\n \n     if (guard.length()>0){\n \tMGuard g=parseGuard(guard);\n \tif (g!=null){\n \t    g.setName(\"anon\");\n \t    g.setTransition(trans);\n \t    trans.setGuard(g);\n \t}\n     }\n     else\n \ttrans.setGuard(null);\n \n     if (actions.length()>0){\n \tMCallAction effect=(MCallAction)parseAction(actions);\n \teffect.setName(\"anon\");\n \ttrans.setEffect(effect);\n     }\n     else\n \ttrans.setEffect(null);\n \n     return trans;\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public MTransition parseTransition(MTransition trans, String s) {\n    // strip any trailing semi-colons\n    s = s.trim();\n    if (s.length() == 0) return null;\n    if (s.charAt(s.length()-1) == ';')\n      s = s.substring(0, s.length() - 2);\n\n    String name = \"\";\n    String trigger = \"\";\n    String guard = \"\";\n    String actions = \"\";\n    if (s.indexOf(\":\", 0) > -1) {\n      name = s.substring(0, s.indexOf(\":\")).trim();\n      s = s.substring(s.indexOf(\":\") + 1).trim();\n    }\n\n    if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n      guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n      s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n      s = s.trim();\n    }\n\n    if (s.indexOf(\"/\", 0) > -1) {\n      actions = s.substring(s.indexOf(\"/\")+1).trim();\n      s = s.substring(0, s.indexOf(\"/\")).trim();\n    }\n\n    trigger = s;\n\n    _cat.debug(\"name=|\" + name +\"|\");\n    _cat.debug(\"trigger=|\" + trigger +\"|\");\n    _cat.debug(\"guard=|\" + guard +\"|\");\n    _cat.debug(\"actions=|\" + actions +\"|\");\n    \n    trans.setName(parseName(name));\n\n    if (trigger.length()>0) {\n\tMEvent evt=parseEvent(trigger);\n\tif (evt!=null){\n\t    trans.setTrigger((MCallEvent)evt);\n\t}\n    }\n    else\n\ttrans.setTrigger(null);\n\n    if (guard.length()>0){\n\tMGuard g=parseGuard(guard);\n\tif (g!=null){\n\t    g.setName(\"anon\");\n\t    g.setTransition(trans);\n\t    trans.setGuard(g);\n\t}\n    }\n    else\n\ttrans.setGuard(null);\n\n    if (actions.length()>0){\n\tMCallAction effect=(MCallAction)parseAction(actions);\n\teffect.setName(\"anon\");\n\ttrans.setEffect(effect);\n    }\n    else\n\ttrans.setEffect(null);\n\n    return trans;\n  }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "273"
        },
        "56e6f745d5f53dfc71f668a0a78fe44624e1842a": {
            "type": "Ybodychange",
            "commitMessage": "PropPanel update in state diagrams\nPR:\nObtained from:\nSubmitted by:\toliver heyden\nReviewed by:\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@677 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "05/04/01 2:22 AM",
            "commitName": "56e6f745d5f53dfc71f668a0a78fe44624e1842a",
            "commitAuthor": "Oliver Heyden",
            "commitDateOld": "02/04/01 7:28 AM",
            "commitNameOld": "5ae659fcab22b8c248b3d089c39ac5f1e011861b",
            "commitAuthorOld": "Oliver Heyden",
            "daysBetweenCommits": 2.79,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,52 +1,66 @@\n   public MTransition parseTransition(MTransition trans, String s) {\n     // strip any trailing semi-colons\n     s = s.trim();\n     if (s.length() == 0) return null;\n     if (s.charAt(s.length()-1) == ';')\n       s = s.substring(0, s.length() - 2);\n \n     String name = \"\";\n     String trigger = \"\";\n     String guard = \"\";\n     String actions = \"\";\n     if (s.indexOf(\":\", 0) > -1) {\n       name = s.substring(0, s.indexOf(\":\")).trim();\n       s = s.substring(s.indexOf(\":\") + 1).trim();\n     }\n \n     if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n       guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n       s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n       s = s.trim();\n     }\n \n     if (s.indexOf(\"/\", 0) > -1) {\n       actions = s.substring(s.indexOf(\"/\")+1).trim();\n       s = s.substring(0, s.indexOf(\"/\")).trim();\n     }\n \n     trigger = s;\n \n     /*     System.out.println(\"name=|\" + name +\"|\");\n      System.out.println(\"trigger=|\" + trigger +\"|\");\n      System.out.println(\"guard=|\" + guard +\"|\");\n      System.out.println(\"actions=|\" + actions +\"|\");\n     */   \n     trans.setName(parseName(name));\n \n-    MEvent evt=parseEvent(trigger);\n-    if (evt!=null){\n-        trans.setTrigger((MCallEvent)evt);\n+    if (trigger.length()>0) {\n+\tMEvent evt=parseEvent(trigger);\n+\tif (evt!=null){\n+\t    trans.setTrigger((MCallEvent)evt);\n+\t}\n     }\n-    MGuard g=parseGuard(guard);\n-    if (g!=null){\n-\tg.setName(\"guard\");\n-        g.setTransition(trans);\n-        trans.setGuard(g);\n+    else\n+\ttrans.setTrigger(null);\n+\n+    if (guard.length()>0){\n+\tMGuard g=parseGuard(guard);\n+\tif (g!=null){\n+\t    g.setName(\"anon\");\n+\t    g.setTransition(trans);\n+\t    trans.setGuard(g);\n+\t}\n     }\n-    MCallAction effect=(MCallAction)parseAction(actions);\n-    effect.setName(\"effect\");\n-    trans.setEffect(effect);\n+    else\n+\ttrans.setGuard(null);\n+    \n+    if (actions.length()>0){\n+\tMCallAction effect=(MCallAction)parseAction(actions);\n+\teffect.setName(\"anon\");\n+\ttrans.setEffect(effect);\n+    }\n+    else\n+\ttrans.setEffect(null);\n \n     return trans;\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public MTransition parseTransition(MTransition trans, String s) {\n    // strip any trailing semi-colons\n    s = s.trim();\n    if (s.length() == 0) return null;\n    if (s.charAt(s.length()-1) == ';')\n      s = s.substring(0, s.length() - 2);\n\n    String name = \"\";\n    String trigger = \"\";\n    String guard = \"\";\n    String actions = \"\";\n    if (s.indexOf(\":\", 0) > -1) {\n      name = s.substring(0, s.indexOf(\":\")).trim();\n      s = s.substring(s.indexOf(\":\") + 1).trim();\n    }\n\n    if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n      guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n      s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n      s = s.trim();\n    }\n\n    if (s.indexOf(\"/\", 0) > -1) {\n      actions = s.substring(s.indexOf(\"/\")+1).trim();\n      s = s.substring(0, s.indexOf(\"/\")).trim();\n    }\n\n    trigger = s;\n\n    /*     System.out.println(\"name=|\" + name +\"|\");\n     System.out.println(\"trigger=|\" + trigger +\"|\");\n     System.out.println(\"guard=|\" + guard +\"|\");\n     System.out.println(\"actions=|\" + actions +\"|\");\n    */   \n    trans.setName(parseName(name));\n\n    if (trigger.length()>0) {\n\tMEvent evt=parseEvent(trigger);\n\tif (evt!=null){\n\t    trans.setTrigger((MCallEvent)evt);\n\t}\n    }\n    else\n\ttrans.setTrigger(null);\n\n    if (guard.length()>0){\n\tMGuard g=parseGuard(guard);\n\tif (g!=null){\n\t    g.setName(\"anon\");\n\t    g.setTransition(trans);\n\t    trans.setGuard(g);\n\t}\n    }\n    else\n\ttrans.setGuard(null);\n    \n    if (actions.length()>0){\n\tMCallAction effect=(MCallAction)parseAction(actions);\n\teffect.setName(\"anon\");\n\ttrans.setEffect(effect);\n    }\n    else\n\ttrans.setEffect(null);\n\n    return trans;\n  }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "5ae659fcab22b8c248b3d089c39ac5f1e011861b": {
            "type": "Ymultichange(Yparameterchange,Ybodychange)",
            "commitMessage": "Property Panels' layout changed and new panels added\nPR:\nObtained from:Oliver Heyden\nSubmitted by:Oliver Heyden\nReviewed by:\tAndreas Kanzlers\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@672 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "02/04/01 7:28 AM",
            "commitName": "5ae659fcab22b8c248b3d089c39ac5f1e011861b",
            "commitAuthor": "Oliver Heyden",
            "subchanges": [
                {
                    "type": "Yparameterchange",
                    "commitMessage": "Property Panels' layout changed and new panels added\nPR:\nObtained from:Oliver Heyden\nSubmitted by:Oliver Heyden\nReviewed by:\tAndreas Kanzlers\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@672 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "02/04/01 7:28 AM",
                    "commitName": "5ae659fcab22b8c248b3d089c39ac5f1e011861b",
                    "commitAuthor": "Oliver Heyden",
                    "commitDateOld": "01/02/01 10:45 PM",
                    "commitNameOld": "13d099825e873026c3cc4b37f656d4a48444c518",
                    "commitAuthorOld": "Curt Arnold",
                    "daysBetweenCommits": 59.32,
                    "commitsBetweenForRepo": 56,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,44 +1,52 @@\n-  public MTransition parseTransition(String s) {\n+  public MTransition parseTransition(MTransition trans, String s) {\n     // strip any trailing semi-colons\n     s = s.trim();\n     if (s.length() == 0) return null;\n     if (s.charAt(s.length()-1) == ';')\n       s = s.substring(0, s.length() - 2);\n \n     String name = \"\";\n     String trigger = \"\";\n     String guard = \"\";\n     String actions = \"\";\n     if (s.indexOf(\":\", 0) > -1) {\n       name = s.substring(0, s.indexOf(\":\")).trim();\n       s = s.substring(s.indexOf(\":\") + 1).trim();\n     }\n \n     if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n       guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n       s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n       s = s.trim();\n     }\n \n     if (s.indexOf(\"/\", 0) > -1) {\n       actions = s.substring(s.indexOf(\"/\")+1).trim();\n       s = s.substring(0, s.indexOf(\"/\")).trim();\n     }\n \n     trigger = s;\n \n-//     System.out.println(\"name=|\" + name +\"|\");\n-//     System.out.println(\"trigger=|\" + trigger +\"|\");\n-//     System.out.println(\"guard=|\" + guard +\"|\");\n-//     System.out.println(\"actions=|\" + actions +\"|\");\n+    /*     System.out.println(\"name=|\" + name +\"|\");\n+     System.out.println(\"trigger=|\" + trigger +\"|\");\n+     System.out.println(\"guard=|\" + guard +\"|\");\n+     System.out.println(\"actions=|\" + actions +\"|\");\n+    */   \n+    trans.setName(parseName(name));\n \n-    MTransition t = new MTransitionImpl();\n-    t.setName(parseName(name));\n+    MEvent evt=parseEvent(trigger);\n+    if (evt!=null){\n+        trans.setTrigger((MCallEvent)evt);\n+    }\n+    MGuard g=parseGuard(guard);\n+    if (g!=null){\n+\tg.setName(\"guard\");\n+        g.setTransition(trans);\n+        trans.setGuard(g);\n+    }\n+    MCallAction effect=(MCallAction)parseAction(actions);\n+    effect.setName(\"effect\");\n+    trans.setEffect(effect);\n \n-    t.setTrigger(parseEvent(trigger));\n-    t.setGuard(parseGuard(guard));\n-    t.setEffect(parseActions(actions));\n-\n-\n-    return t;\n+    return trans;\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  public MTransition parseTransition(MTransition trans, String s) {\n    // strip any trailing semi-colons\n    s = s.trim();\n    if (s.length() == 0) return null;\n    if (s.charAt(s.length()-1) == ';')\n      s = s.substring(0, s.length() - 2);\n\n    String name = \"\";\n    String trigger = \"\";\n    String guard = \"\";\n    String actions = \"\";\n    if (s.indexOf(\":\", 0) > -1) {\n      name = s.substring(0, s.indexOf(\":\")).trim();\n      s = s.substring(s.indexOf(\":\") + 1).trim();\n    }\n\n    if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n      guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n      s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n      s = s.trim();\n    }\n\n    if (s.indexOf(\"/\", 0) > -1) {\n      actions = s.substring(s.indexOf(\"/\")+1).trim();\n      s = s.substring(0, s.indexOf(\"/\")).trim();\n    }\n\n    trigger = s;\n\n    /*     System.out.println(\"name=|\" + name +\"|\");\n     System.out.println(\"trigger=|\" + trigger +\"|\");\n     System.out.println(\"guard=|\" + guard +\"|\");\n     System.out.println(\"actions=|\" + actions +\"|\");\n    */   \n    trans.setName(parseName(name));\n\n    MEvent evt=parseEvent(trigger);\n    if (evt!=null){\n        trans.setTrigger((MCallEvent)evt);\n    }\n    MGuard g=parseGuard(guard);\n    if (g!=null){\n\tg.setName(\"guard\");\n        g.setTransition(trans);\n        trans.setGuard(g);\n    }\n    MCallAction effect=(MCallAction)parseAction(actions);\n    effect.setName(\"effect\");\n    trans.setEffect(effect);\n\n    return trans;\n  }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {
                        "oldValue": "[s-String]",
                        "newValue": "[trans-MTransition, s-String]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Property Panels' layout changed and new panels added\nPR:\nObtained from:Oliver Heyden\nSubmitted by:Oliver Heyden\nReviewed by:\tAndreas Kanzlers\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@672 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
                    "commitDate": "02/04/01 7:28 AM",
                    "commitName": "5ae659fcab22b8c248b3d089c39ac5f1e011861b",
                    "commitAuthor": "Oliver Heyden",
                    "commitDateOld": "01/02/01 10:45 PM",
                    "commitNameOld": "13d099825e873026c3cc4b37f656d4a48444c518",
                    "commitAuthorOld": "Curt Arnold",
                    "daysBetweenCommits": 59.32,
                    "commitsBetweenForRepo": 56,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,44 +1,52 @@\n-  public MTransition parseTransition(String s) {\n+  public MTransition parseTransition(MTransition trans, String s) {\n     // strip any trailing semi-colons\n     s = s.trim();\n     if (s.length() == 0) return null;\n     if (s.charAt(s.length()-1) == ';')\n       s = s.substring(0, s.length() - 2);\n \n     String name = \"\";\n     String trigger = \"\";\n     String guard = \"\";\n     String actions = \"\";\n     if (s.indexOf(\":\", 0) > -1) {\n       name = s.substring(0, s.indexOf(\":\")).trim();\n       s = s.substring(s.indexOf(\":\") + 1).trim();\n     }\n \n     if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n       guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n       s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n       s = s.trim();\n     }\n \n     if (s.indexOf(\"/\", 0) > -1) {\n       actions = s.substring(s.indexOf(\"/\")+1).trim();\n       s = s.substring(0, s.indexOf(\"/\")).trim();\n     }\n \n     trigger = s;\n \n-//     System.out.println(\"name=|\" + name +\"|\");\n-//     System.out.println(\"trigger=|\" + trigger +\"|\");\n-//     System.out.println(\"guard=|\" + guard +\"|\");\n-//     System.out.println(\"actions=|\" + actions +\"|\");\n+    /*     System.out.println(\"name=|\" + name +\"|\");\n+     System.out.println(\"trigger=|\" + trigger +\"|\");\n+     System.out.println(\"guard=|\" + guard +\"|\");\n+     System.out.println(\"actions=|\" + actions +\"|\");\n+    */   \n+    trans.setName(parseName(name));\n \n-    MTransition t = new MTransitionImpl();\n-    t.setName(parseName(name));\n+    MEvent evt=parseEvent(trigger);\n+    if (evt!=null){\n+        trans.setTrigger((MCallEvent)evt);\n+    }\n+    MGuard g=parseGuard(guard);\n+    if (g!=null){\n+\tg.setName(\"guard\");\n+        g.setTransition(trans);\n+        trans.setGuard(g);\n+    }\n+    MCallAction effect=(MCallAction)parseAction(actions);\n+    effect.setName(\"effect\");\n+    trans.setEffect(effect);\n \n-    t.setTrigger(parseEvent(trigger));\n-    t.setGuard(parseGuard(guard));\n-    t.setEffect(parseActions(actions));\n-\n-\n-    return t;\n+    return trans;\n   }\n\\ No newline at end of file\n",
                    "actualSource": "  public MTransition parseTransition(MTransition trans, String s) {\n    // strip any trailing semi-colons\n    s = s.trim();\n    if (s.length() == 0) return null;\n    if (s.charAt(s.length()-1) == ';')\n      s = s.substring(0, s.length() - 2);\n\n    String name = \"\";\n    String trigger = \"\";\n    String guard = \"\";\n    String actions = \"\";\n    if (s.indexOf(\":\", 0) > -1) {\n      name = s.substring(0, s.indexOf(\":\")).trim();\n      s = s.substring(s.indexOf(\":\") + 1).trim();\n    }\n\n    if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n      guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n      s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n      s = s.trim();\n    }\n\n    if (s.indexOf(\"/\", 0) > -1) {\n      actions = s.substring(s.indexOf(\"/\")+1).trim();\n      s = s.substring(0, s.indexOf(\"/\")).trim();\n    }\n\n    trigger = s;\n\n    /*     System.out.println(\"name=|\" + name +\"|\");\n     System.out.println(\"trigger=|\" + trigger +\"|\");\n     System.out.println(\"guard=|\" + guard +\"|\");\n     System.out.println(\"actions=|\" + actions +\"|\");\n    */   \n    trans.setName(parseName(name));\n\n    MEvent evt=parseEvent(trigger);\n    if (evt!=null){\n        trans.setTrigger((MCallEvent)evt);\n    }\n    MGuard g=parseGuard(guard);\n    if (g!=null){\n\tg.setName(\"guard\");\n        g.setTransition(trans);\n        trans.setGuard(g);\n    }\n    MCallAction effect=(MCallAction)parseAction(actions);\n    effect.setName(\"effect\");\n    trans.setEffect(effect);\n\n    return trans;\n  }",
                    "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "30"
        },
        "df5ee4f7408c487bba53c340a9156ee6bd23dce6": {
            "type": "Yintroduced",
            "commitMessage": "Initial revision\n\n\ngit-svn-id: http://argouml.tigris.org/svn/argouml/trunk@434 a161b567-7d1e-0410-9ef9-912c70fedb3f\n",
            "commitDate": "04/09/00 5:50 AM",
            "commitName": "df5ee4f7408c487bba53c340a9156ee6bd23dce6",
            "commitAuthor": "Thorsten Sturm",
            "diff": "@@ -0,0 +1,44 @@\n+  public MTransition parseTransition(String s) {\n+    // strip any trailing semi-colons\n+    s = s.trim();\n+    if (s.length() == 0) return null;\n+    if (s.charAt(s.length()-1) == ';')\n+      s = s.substring(0, s.length() - 2);\n+\n+    String name = \"\";\n+    String trigger = \"\";\n+    String guard = \"\";\n+    String actions = \"\";\n+    if (s.indexOf(\":\", 0) > -1) {\n+      name = s.substring(0, s.indexOf(\":\")).trim();\n+      s = s.substring(s.indexOf(\":\") + 1).trim();\n+    }\n+\n+    if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n+      guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n+      s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n+      s = s.trim();\n+    }\n+\n+    if (s.indexOf(\"/\", 0) > -1) {\n+      actions = s.substring(s.indexOf(\"/\")+1).trim();\n+      s = s.substring(0, s.indexOf(\"/\")).trim();\n+    }\n+\n+    trigger = s;\n+\n+//     System.out.println(\"name=|\" + name +\"|\");\n+//     System.out.println(\"trigger=|\" + trigger +\"|\");\n+//     System.out.println(\"guard=|\" + guard +\"|\");\n+//     System.out.println(\"actions=|\" + actions +\"|\");\n+\n+    MTransition t = new MTransitionImpl();\n+    t.setName(parseName(name));\n+\n+    t.setTrigger(parseEvent(trigger));\n+    t.setGuard(parseGuard(guard));\n+    t.setEffect(parseActions(actions));\n+\n+\n+    return t;\n+  }\n\\ No newline at end of file\n",
            "actualSource": "  public MTransition parseTransition(String s) {\n    // strip any trailing semi-colons\n    s = s.trim();\n    if (s.length() == 0) return null;\n    if (s.charAt(s.length()-1) == ';')\n      s = s.substring(0, s.length() - 2);\n\n    String name = \"\";\n    String trigger = \"\";\n    String guard = \"\";\n    String actions = \"\";\n    if (s.indexOf(\":\", 0) > -1) {\n      name = s.substring(0, s.indexOf(\":\")).trim();\n      s = s.substring(s.indexOf(\":\") + 1).trim();\n    }\n\n    if (s.indexOf(\"[\", 0) > -1 && s.indexOf(\"]\", 0) > -1) {\n      guard = s.substring(s.indexOf(\"[\", 0)+1, s.indexOf(\"]\")).trim();\n      s = s.substring(0, s.indexOf(\"[\")) + s.substring(s.indexOf(\"]\")+1);\n      s = s.trim();\n    }\n\n    if (s.indexOf(\"/\", 0) > -1) {\n      actions = s.substring(s.indexOf(\"/\")+1).trim();\n      s = s.substring(0, s.indexOf(\"/\")).trim();\n    }\n\n    trigger = s;\n\n//     System.out.println(\"name=|\" + name +\"|\");\n//     System.out.println(\"trigger=|\" + trigger +\"|\");\n//     System.out.println(\"guard=|\" + guard +\"|\");\n//     System.out.println(\"actions=|\" + actions +\"|\");\n\n    MTransition t = new MTransitionImpl();\n    t.setName(parseName(name));\n\n    t.setTrigger(parseEvent(trigger));\n    t.setGuard(parseGuard(guard));\n    t.setEffect(parseActions(actions));\n\n\n    return t;\n  }",
            "path": "src_new/org/argouml/uml/generator/ParserDisplay.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "5515.json"
}