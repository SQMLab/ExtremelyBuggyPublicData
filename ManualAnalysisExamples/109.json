{
    "origin": "codeshovel",
    "repositoryName": "Mindustry",
    "repositoryPath": "/home/student/fries432/Research/BugResearch/Repos/Mindustry/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "Unloader.java",
    "functionName": "updateTile",
    "functionId": "updateTile",
    "sourceFilePath": "core/src/mindustry/world/blocks/storage/Unloader.java",
    "functionStartLine": 155,
    "functionEndLine": 225,
    "numCommitsSeen": 137,
    "timeTaken": 8331,
    "changeHistory": [
        "bf6e33791d8df3df04b6fedb2ce18b9c0ff7bd53",
        "3418979f4d5508ab868a9b0dfc43abdc3f3917ea",
        "b020bf68165aadc265176df052e7efcb99f1d9d2",
        "ccb97e34d54f39e80bc7bea9e5df956d6f1c9941",
        "d988bb18213aa92b48821f54400d51d12b17612d",
        "59ade6cf09f970027ba3051f0f65f7c44f19e446",
        "66fab1b3df32da9637150a7bd75ea987f107b381",
        "459256e83abf01d3f02020fb481c8b4d77517d68",
        "7f391dacbd26248471b97f2eb444da605bd7ab51",
        "4677de80c1b8180868a8f4285926ea213d40f862",
        "2db61f93acfef6ccb8a072b493742d893690603a",
        "55da9df2a1fbcf5501919e2c5ea626f1bfdf81c8",
        "6c07c5006a92198a779dc290757473e8c25beb99",
        "7bfdbaabe746ae3aef399d43ea8b4563436b90c5",
        "1aca3025184044b566a98954ad3063e56ba7884b",
        "514d4817c8fdc38f43f85ec73fd8bd3d55cef9db",
        "a942ed2cad745de978abb71067279ef1f390105e",
        "36b9451e01afc75dacfd280160ec8624f8d055b2",
        "a7b39e56bd313c8091f9dcc3c69b909743204096",
        "da97aee8e4151a7d8cedb8922922c8ba41b1c33c",
        "2e19504b65f86a4f531fec926d16be878d490ab0",
        "1c48c1a43e851d6ec5c9d4cfb42b22b307986c80",
        "73c0ebb75f18b35de4d2ed96fc0f64842980252d",
        "2b9d618bd270324a54112122d782623b2b348c44",
        "fdf7c88083364bea9736b54fe1f22ba7cc799c85",
        "5f6c71b9d3f0e535815bd32205ebfadf4517c25c",
        "74cefb3ec999eadd50bedaf0f95324b78638f332",
        "bcb248907c8d7bb3fdce5574b4fe455c4084c0c8",
        "e8a5e35f504bde5a5b689dc6b3693685333ef1aa",
        "e847a74a25112437bc30d68db67fb51a3d1ee200",
        "57ad1d5366a2acd9dc300a4c68b31b664025f407",
        "a544888f16f050890c280fb86103dcb447d99156",
        "9397bd57c4fbdd40156b127ea90f455f99f72b63",
        "02ef633529f93785bc3ee9f49d620a816680c0a8",
        "28b235ef07be92808cdba260168ff314db426376",
        "c9eed5a936e4af960791b77818b460f5e4ef9243",
        "16f4e300a8fe5a69a80b337f40ea604e5da9e76d",
        "b6acf1af0a0def0bcd5be5c73f2d069ea193d520",
        "59a480cb3073bf74a93b15d9697dcd242e8b8cf9",
        "10f2a7b59c3c934e5415a1f34084c30848bad919",
        "134ef9e00edb8c67e436841abaa5f3aec3a8c0ad",
        "fd1678dbc9c61ad71c4008566c3f910e65916368",
        "65161a4129d30af818e2a4022388725e8e3f5193",
        "02f3386c5be005fd05946d65e368e4e35663ba0f",
        "7914a187e5c88d0b092a1ec652fa3c2676bf568a",
        "02c4e905a56d0017490aaa3e514abe22fd8c278c",
        "6cf371b9494336a302a274144b4006e74e321acd"
    ],
    "changeHistoryShort": {
        "6cf371b9494336a302a274144b4006e74e321acd": "Ybodychange",
        "02c4e905a56d0017490aaa3e514abe22fd8c278c": "Ybodychange",
        "7914a187e5c88d0b092a1ec652fa3c2676bf568a": "Ybodychange",
        "02f3386c5be005fd05946d65e368e4e35663ba0f": "Ybodychange",
        "65161a4129d30af818e2a4022388725e8e3f5193": "Ybodychange",
        "fd1678dbc9c61ad71c4008566c3f910e65916368": "Ybodychange",
        "134ef9e00edb8c67e436841abaa5f3aec3a8c0ad": "Ybodychange",
        "10f2a7b59c3c934e5415a1f34084c30848bad919": "Ybodychange",
        "59a480cb3073bf74a93b15d9697dcd242e8b8cf9": "Ybodychange",
        "b6acf1af0a0def0bcd5be5c73f2d069ea193d520": "Ybodychange",
        "16f4e300a8fe5a69a80b337f40ea604e5da9e76d": "Ybodychange",
        "c9eed5a936e4af960791b77818b460f5e4ef9243": "Ybodychange",
        "28b235ef07be92808cdba260168ff314db426376": "Ybodychange",
        "02ef633529f93785bc3ee9f49d620a816680c0a8": "Ybodychange",
        "9397bd57c4fbdd40156b127ea90f455f99f72b63": "Ybodychange",
        "a544888f16f050890c280fb86103dcb447d99156": "Ybodychange",
        "57ad1d5366a2acd9dc300a4c68b31b664025f407": "Ybodychange",
        "e847a74a25112437bc30d68db67fb51a3d1ee200": "Ybodychange",
        "e8a5e35f504bde5a5b689dc6b3693685333ef1aa": "Ybodychange",
        "bcb248907c8d7bb3fdce5574b4fe455c4084c0c8": "Ybodychange",
        "74cefb3ec999eadd50bedaf0f95324b78638f332": "Ybodychange",
        "5f6c71b9d3f0e535815bd32205ebfadf4517c25c": "Ybodychange",
        "fdf7c88083364bea9736b54fe1f22ba7cc799c85": "Ybodychange",
        "2b9d618bd270324a54112122d782623b2b348c44": "Ybodychange",
        "73c0ebb75f18b35de4d2ed96fc0f64842980252d": "Ybodychange",
        "1c48c1a43e851d6ec5c9d4cfb42b22b307986c80": "Ybodychange",
        "2e19504b65f86a4f531fec926d16be878d490ab0": "Ymultichange(Yrename,Yparameterchange)",
        "da97aee8e4151a7d8cedb8922922c8ba41b1c33c": "Ybodychange",
        "a7b39e56bd313c8091f9dcc3c69b909743204096": "Ybodychange",
        "36b9451e01afc75dacfd280160ec8624f8d055b2": "Ybodychange",
        "a942ed2cad745de978abb71067279ef1f390105e": "Ybodychange",
        "514d4817c8fdc38f43f85ec73fd8bd3d55cef9db": "Ymovefromfile",
        "1aca3025184044b566a98954ad3063e56ba7884b": "Ybodychange",
        "7bfdbaabe746ae3aef399d43ea8b4563436b90c5": "Ybodychange",
        "6c07c5006a92198a779dc290757473e8c25beb99": "Ybodychange",
        "55da9df2a1fbcf5501919e2c5ea626f1bfdf81c8": "Ybodychange",
        "2db61f93acfef6ccb8a072b493742d893690603a": "Ybodychange",
        "4677de80c1b8180868a8f4285926ea213d40f862": "Ymultichange(Yfilerename,Ybodychange)",
        "7f391dacbd26248471b97f2eb444da605bd7ab51": "Ybodychange",
        "459256e83abf01d3f02020fb481c8b4d77517d68": "Ybodychange",
        "66fab1b3df32da9637150a7bd75ea987f107b381": "Ybodychange",
        "59ade6cf09f970027ba3051f0f65f7c44f19e446": "Ybodychange",
        "d988bb18213aa92b48821f54400d51d12b17612d": "Ybodychange",
        "ccb97e34d54f39e80bc7bea9e5df956d6f1c9941": "Yfilerename",
        "b020bf68165aadc265176df052e7efcb99f1d9d2": "Ybodychange",
        "3418979f4d5508ab868a9b0dfc43abdc3f3917ea": "Ybodychange",
        "bf6e33791d8df3df04b6fedb2ce18b9c0ff7bd53": "Yintroduced"
    },
    "changeHistoryDetails": {
        "6cf371b9494336a302a274144b4006e74e321acd": {
            "type": "Ybodychange",
            "commitMessage": "Unloader optimizations from buthed\n",
            "commitDate": "08/05/24 9:24 AM",
            "commitName": "6cf371b9494336a302a274144b4006e74e321acd",
            "commitAuthor": "Anuken",
            "commitDateOld": "26/09/22 9:56 AM",
            "commitNameOld": "dec2642434ad140bbfc38b8f5d992843009e9b72",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 589.98,
            "commitsBetweenForRepo": 1933,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,71 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (possibleBlocks.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n \n             if(sortItem != null){\n                 if(isPossibleItem(sortItem)) item = sortItem;\n             }else{\n                 //selects the next item for nulloaders\n                 //inspired of nextIndex() but for all \"proximity\" (possibleBlocks) at once, and also way more powerful\n-                for(int i = 0; i < itemsLength; i++){\n-                    int total = (rotations + i + 1) % itemsLength;\n-                    Item possibleItem = content.item(total);\n+                for(int i = 0, l = allItems.length; i < l; i++){\n+                    int id = (rotations + i + 1) % l;\n+                    var possibleItem = allItems[id];\n \n                     if(isPossibleItem(possibleItem)){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 rotations = item.id; //next rotation for nulloaders //TODO maybe if(sortItem == null)\n+                var pbi = possibleBlocks.items;\n+                int pbs = possibleBlocks.size;\n \n-                for(int i = 0; i < possibleBlocks.size; i++){\n-                    var pb = possibleBlocks.get(i);\n+                for(int i = 0; i < pbs; i++){\n+                    var pb = pbi[i];\n                     var other = pb.building;\n-                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n+                    int maxAccepted = other.getMaximumAccepted(item);\n+                    pb.loadFactor = maxAccepted == 0 || other.items == null ? 0 : other.items.get(item) / (float)maxAccepted;\n                     pb.lastUsed = (pb.lastUsed + 1) % Integer.MAX_VALUE; //increment the priority if not used\n                 }\n \n                 possibleBlocks.sort(comparator);\n \n                 dumpingTo = null;\n                 dumpingFrom = null;\n \n                 //choose the building to accept the item\n-                for(int i = 0; i < possibleBlocks.size; i++){\n-                    if(possibleBlocks.get(i).canLoad){\n-                        dumpingTo = possibleBlocks.get(i);\n+                for(int i = 0; i < pbs; i++){\n+                    if(pbi[i].canLoad){\n+                        dumpingTo = pbi[i];\n                         break;\n                     }\n                 }\n \n                 //choose the building to take the item from\n-                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n-                    if(possibleBlocks.get(i).canUnload){\n-                        dumpingFrom = possibleBlocks.get(i);\n+                for(int i = pbs - 1; i >= 0; i--){\n+                    if(pbi[i].canUnload){\n+                        dumpingFrom = pbi[i];\n                         break;\n                     }\n                 }\n \n                 //trade the items\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     dumpingTo.lastUsed = 0;\n                     dumpingFrom.lastUsed = 0;\n                     any = true;\n                 }\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (possibleBlocks.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n\n            if(sortItem != null){\n                if(isPossibleItem(sortItem)) item = sortItem;\n            }else{\n                //selects the next item for nulloaders\n                //inspired of nextIndex() but for all \"proximity\" (possibleBlocks) at once, and also way more powerful\n                for(int i = 0, l = allItems.length; i < l; i++){\n                    int id = (rotations + i + 1) % l;\n                    var possibleItem = allItems[id];\n\n                    if(isPossibleItem(possibleItem)){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                rotations = item.id; //next rotation for nulloaders //TODO maybe if(sortItem == null)\n                var pbi = possibleBlocks.items;\n                int pbs = possibleBlocks.size;\n\n                for(int i = 0; i < pbs; i++){\n                    var pb = pbi[i];\n                    var other = pb.building;\n                    int maxAccepted = other.getMaximumAccepted(item);\n                    pb.loadFactor = maxAccepted == 0 || other.items == null ? 0 : other.items.get(item) / (float)maxAccepted;\n                    pb.lastUsed = (pb.lastUsed + 1) % Integer.MAX_VALUE; //increment the priority if not used\n                }\n\n                possibleBlocks.sort(comparator);\n\n                dumpingTo = null;\n                dumpingFrom = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < pbs; i++){\n                    if(pbi[i].canLoad){\n                        dumpingTo = pbi[i];\n                        break;\n                    }\n                }\n\n                //choose the building to take the item from\n                for(int i = pbs - 1; i >= 0; i--){\n                    if(pbi[i].canUnload){\n                        dumpingFrom = pbi[i];\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    dumpingTo.lastUsed = 0;\n                    dumpingFrom.lastUsed = 0;\n                    any = true;\n                }\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {}
        },
        "02c4e905a56d0017490aaa3e514abe22fd8c278c": {
            "type": "Ybodychange",
            "commitMessage": "More Optimized Unloaders (Serpulo) (#7249)\n\n* Update Unloader.java\r\n\r\n* some comments\r\n\r\n* deleted highUnloadPriority",
            "commitDate": "28/07/22 8:41 AM",
            "commitName": "02c4e905a56d0017490aaa3e514abe22fd8c278c",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "08/06/22 9:00 AM",
            "commitNameOld": "966a93ddfa576e56a28639966d864176580b4122",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 49.99,
            "commitsBetweenForRepo": 350,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,122 +1,68 @@\n         public void updateTile(){\n-            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n+            if(((unloadTimer += delta()) < speed) || (possibleBlocks.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n-            int itemslength = content.items().size;\n-\n-            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n-            if(possibleBlocks.size != proximity.size){\n-                int tmp = possibleBlocks.size;\n-                possibleBlocks.setSize(proximity.size);\n-                for(int i = tmp; i < proximity.size; i++){\n-                    possibleBlocks.set(i, new ContainerStat());\n-                }\n-                lastUsed = new int[proximity.size];\n-            }\n \n             if(sortItem != null){\n-                item = sortItem;\n-\n-                for(int pos = 0; pos < proximity.size; pos++){\n-                    var other = proximity.get(pos);\n-                    boolean interactable = other.interactable(team);\n-\n-                    //set the stats of all buildings in possibleBlocks\n-                    ContainerStat pb = possibleBlocks.get(pos);\n-                    pb.building = other;\n-                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n-                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n-                    pb.index = pos;\n-                }\n+                if(isPossibleItem(sortItem)) item = sortItem;\n             }else{\n-                //select the next item for nulloaders\n-                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n-                for(int i = 0; i < itemslength; i++){\n-                    int total = (rotations + i + 1) % itemslength;\n-                    boolean hasProvider = false;\n-                    boolean hasReceiver = false;\n-                    boolean isDistinct = false;\n+                //selects the next item for nulloaders\n+                //inspired of nextIndex() but for all \"proximity\" (possibleBlocks) at once, and also way more powerful\n+                for(int i = 0; i < itemsLength; i++){\n+                    int total = (rotations + i + 1) % itemsLength;\n                     Item possibleItem = content.item(total);\n \n-                    for(int pos = 0; pos < proximity.size; pos++){\n-                        var other = proximity.get(pos);\n-                        boolean interactable = other.interactable(team);\n-\n-                        //set the stats of all buildings in possibleBlocks while we are at it\n-                        ContainerStat pb = possibleBlocks.get(pos);\n-                        pb.building = other;\n-                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n-                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n-                        pb.index = pos;\n-\n-                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n-                        if(hasProvider && pb.canLoad) isDistinct = true;\n-                        if(hasReceiver && pb.canUnload) isDistinct = true;\n-                        hasProvider = hasProvider || pb.canUnload;\n-                        hasReceiver = hasReceiver || pb.canLoad;\n-                    }\n-                    if(isDistinct){\n+                    if(isPossibleItem(possibleItem)){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n-                //only compute the load factor if a transfer is possible\n-                for(int pos = 0; pos < proximity.size; pos++){\n-                    ContainerStat pb = possibleBlocks.get(pos);\n+                rotations = item.id; //next rotation for nulloaders //TODO maybe if(sortItem == null)\n+\n+                for(int i = 0; i < possibleBlocks.size; i++){\n+                    var pb = possibleBlocks.get(i);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n+                    pb.lastUsed = (pb.lastUsed + 1) % Integer.MAX_VALUE; //increment the priority if not used\n                 }\n \n                 possibleBlocks.sort(comparator);\n \n-                ContainerStat dumpingFrom = null;\n-                ContainerStat dumpingTo = null;\n+                dumpingTo = null;\n+                dumpingFrom = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to take the item from\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n-                //increment the priority if not used\n-                for(int i = 0; i < possibleBlocks.size; i++){\n-                    lastUsed[i] = (lastUsed[i] + 1) % 2147483647;\n-                }\n-\n                 //trade the items\n-                //TODO  && dumpingTo != dumpingFrom ?\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n-                    lastUsed[dumpingFrom.index] = 0;\n-                    lastUsed[dumpingTo.index] = 0;\n+                    dumpingTo.lastUsed = 0;\n+                    dumpingFrom.lastUsed = 0;\n                     any = true;\n                 }\n-\n-                if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n-\n-            if(proximity.size > 0){\n-                offset++;\n-                offset %= proximity.size;\n-            }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (possibleBlocks.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n\n            if(sortItem != null){\n                if(isPossibleItem(sortItem)) item = sortItem;\n            }else{\n                //selects the next item for nulloaders\n                //inspired of nextIndex() but for all \"proximity\" (possibleBlocks) at once, and also way more powerful\n                for(int i = 0; i < itemsLength; i++){\n                    int total = (rotations + i + 1) % itemsLength;\n                    Item possibleItem = content.item(total);\n\n                    if(isPossibleItem(possibleItem)){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                rotations = item.id; //next rotation for nulloaders //TODO maybe if(sortItem == null)\n\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    var pb = possibleBlocks.get(i);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                    pb.lastUsed = (pb.lastUsed + 1) % Integer.MAX_VALUE; //increment the priority if not used\n                }\n\n                possibleBlocks.sort(comparator);\n\n                dumpingTo = null;\n                dumpingFrom = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to take the item from\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    dumpingTo.lastUsed = 0;\n                    dumpingFrom.lastUsed = 0;\n                    any = true;\n                }\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "7914a187e5c88d0b092a1ec652fa3c2676bf568a": {
            "type": "Ybodychange",
            "commitMessage": "Unloader fix 4 - New Load Priority (#6840)\n\n* should solve the MD bug and some others\r\n\r\n* skill issue",
            "commitDate": "11/05/22 9:39 PM",
            "commitName": "7914a187e5c88d0b092a1ec652fa3c2676bf568a",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "16/03/22 9:31 AM",
            "commitNameOld": "02f3386c5be005fd05946d65e368e4e35663ba0f",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 56.51,
            "commitsBetweenForRepo": 472,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,123 +1,122 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n                 lastUsed = new int[proximity.size];\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                     pb.index = pos;\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                         pb.index = pos;\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n-                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                 possibleBlocks.sort(comparator);\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to take the item from\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //increment the priority if not used\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     lastUsed[i] = (lastUsed[i] + 1) % 2147483647;\n                 }\n \n                 //trade the items\n                 //TODO  && dumpingTo != dumpingFrom ?\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     lastUsed[dumpingFrom.index] = 0;\n                     lastUsed[dumpingTo.index] = 0;\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n                lastUsed = new int[proximity.size];\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                    pb.index = pos;\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                        pb.index = pos;\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                possibleBlocks.sort(comparator);\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to take the item from\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //increment the priority if not used\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    lastUsed[i] = (lastUsed[i] + 1) % 2147483647;\n                }\n\n                //trade the items\n                //TODO  && dumpingTo != dumpingFrom ?\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    lastUsed[dumpingFrom.index] = 0;\n                    lastUsed[dumpingTo.index] = 0;\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "02f3386c5be005fd05946d65e368e4e35663ba0f": {
            "type": "Ybodychange",
            "commitMessage": "Unloader fix?\n",
            "commitDate": "16/03/22 9:31 AM",
            "commitName": "02f3386c5be005fd05946d65e368e4e35663ba0f",
            "commitAuthor": "Anuken",
            "commitDateOld": "22/02/22 12:33 PM",
            "commitNameOld": "d4aff92fda74723165fedeeb7332f3c222210262",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 21.83,
            "commitsBetweenForRepo": 106,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,122 +1,123 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n                 lastUsed = new int[proximity.size];\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                     pb.index = pos;\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                         pb.index = pos;\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n                 //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                 possibleBlocks.sort(comparator);\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n-                //choose the building to give the item\n+                //choose the building to take the item from\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //increment the priority if not used\n                 for(int i = 0; i < possibleBlocks.size; i++){\n-                    lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n+                    lastUsed[i] = (lastUsed[i] + 1) % 2147483647;\n                 }\n \n                 //trade the items\n+                //TODO  && dumpingTo != dumpingFrom ?\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     lastUsed[dumpingFrom.index] = 0;\n                     lastUsed[dumpingTo.index] = 0;\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n                lastUsed = new int[proximity.size];\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                    pb.index = pos;\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                        pb.index = pos;\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                possibleBlocks.sort(comparator);\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to take the item from\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //increment the priority if not used\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    lastUsed[i] = (lastUsed[i] + 1) % 2147483647;\n                }\n\n                //trade the items\n                //TODO  && dumpingTo != dumpingFrom ?\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    lastUsed[dumpingFrom.index] = 0;\n                    lastUsed[dumpingTo.index] = 0;\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "65161a4129d30af818e2a4022388725e8e3f5193": {
            "type": "Ybodychange",
            "commitMessage": "deprecation annihilation\n",
            "commitDate": "14/02/22 9:29 PM",
            "commitName": "65161a4129d30af818e2a4022388725e8e3f5193",
            "commitAuthor": "Anuken",
            "commitDateOld": "16/12/21 9:31 AM",
            "commitNameOld": "e481de9d28ce442ea8628e91027dc99c31c3895f",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 60.5,
            "commitsBetweenForRepo": 367,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,133 +1,122 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n                 lastUsed = new int[proximity.size];\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                     pb.index = pos;\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                         pb.index = pos;\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n                 //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n-                possibleBlocks.sort(\n-                    Structs.comps(\n-                        Structs.comps(\n-                            Structs.comparingBool(e -> e.building.block.highUnloadPriority && !e.canLoad),\n-                            Structs.comparingBool(e -> e.canUnload && !e.canLoad)\n-                        ),\n-                        Structs.comps(\n-                            Structs.comparingFloat(e -> e.loadFactor),\n-                            Structs.comparingInt(e -> -lastUsed[e.index])\n-                        )\n-                    )\n-                );\n+                possibleBlocks.sort(comparator);\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //increment the priority if not used\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n                 }\n \n                 //trade the items\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     lastUsed[dumpingFrom.index] = 0;\n                     lastUsed[dumpingTo.index] = 0;\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n                lastUsed = new int[proximity.size];\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                    pb.index = pos;\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                        pb.index = pos;\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                possibleBlocks.sort(comparator);\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //increment the priority if not used\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    lastUsed[dumpingFrom.index] = 0;\n                    lastUsed[dumpingTo.index] = 0;\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "fd1678dbc9c61ad71c4008566c3f910e65916368": {
            "type": "Ybodychange",
            "commitMessage": "Unloading into plast belts - bug fix (#6347)\n\n* hortiloaders hotfix randomness\r\n\r\nImproved the unloaders' balance with multiple blocks having the same load\r\n\r\n* deterministic lets go\r\n\r\nCo-Authored-By: citrusMarmelade <20476281+citrusMarmelade@users.noreply.github.com>\r\n\r\n* update contributors\r\n\r\nforgot to add them since they helped a lot for the previous commits/PRs\r\n\r\n* unloader - fix cant load\r\n\r\nCo-authored-by: citrusMarmelade <20476281+citrusMarmelade@users.noreply.github.com>",
            "commitDate": "17/11/21 8:35 AM",
            "commitName": "fd1678dbc9c61ad71c4008566c3f910e65916368",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "01/11/21 4:34 PM",
            "commitNameOld": "134ef9e00edb8c67e436841abaa5f3aec3a8c0ad",
            "commitAuthorOld": "hortiSquash",
            "daysBetweenCommits": 15.71,
            "commitsBetweenForRepo": 31,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,127 +1,133 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n                 lastUsed = new int[proximity.size];\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                     pb.index = pos;\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                         pb.index = pos;\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n                 //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n-                possibleBlocks.sort(Structs.comps(\n-                    Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n+                possibleBlocks.sort(\n                     Structs.comps(\n-                        Structs.comparingFloat(e -> e.loadFactor),\n-                        Structs.comparingInt(e -> -lastUsed[e.index])\n-                )));\n+                        Structs.comps(\n+                            Structs.comparingBool(e -> e.building.block.highUnloadPriority && !e.canLoad),\n+                            Structs.comparingBool(e -> e.canUnload && !e.canLoad)\n+                        ),\n+                        Structs.comps(\n+                            Structs.comparingFloat(e -> e.loadFactor),\n+                            Structs.comparingInt(e -> -lastUsed[e.index])\n+                        )\n+                    )\n+                );\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //increment the priority if not used\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n                 }\n \n                 //trade the items\n-                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n+                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     lastUsed[dumpingFrom.index] = 0;\n                     lastUsed[dumpingTo.index] = 0;\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n                lastUsed = new int[proximity.size];\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                    pb.index = pos;\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                        pb.index = pos;\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                possibleBlocks.sort(\n                    Structs.comps(\n                        Structs.comps(\n                            Structs.comparingBool(e -> e.building.block.highUnloadPriority && !e.canLoad),\n                            Structs.comparingBool(e -> e.canUnload && !e.canLoad)\n                        ),\n                        Structs.comps(\n                            Structs.comparingFloat(e -> e.loadFactor),\n                            Structs.comparingInt(e -> -lastUsed[e.index])\n                        )\n                    )\n                );\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //increment the priority if not used\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || !dumpingFrom.canLoad)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    lastUsed[dumpingFrom.index] = 0;\n                    lastUsed[dumpingTo.index] = 0;\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "134ef9e00edb8c67e436841abaa5f3aec3a8c0ad": {
            "type": "Ybodychange",
            "commitMessage": "hortiloaders hotfix randomness (#6283)\n\n* hortiloaders hotfix randomness\r\n\r\nImproved the unloaders' balance with multiple blocks having the same load\r\n\r\n* deterministic lets go\r\n\r\nCo-Authored-By: citrusMarmelade <20476281+citrusMarmelade@users.noreply.github.com>\r\n\r\n* update contributors\r\n\r\nforgot to add them since they helped a lot for the previous commits/PRs\r\n\r\nCo-authored-by: citrusMarmelade <20476281+citrusMarmelade@users.noreply.github.com>",
            "commitDate": "01/11/21 4:34 PM",
            "commitName": "134ef9e00edb8c67e436841abaa5f3aec3a8c0ad",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "28/10/21 9:01 AM",
            "commitNameOld": "10f2a7b59c3c934e5415a1f34084c30848bad919",
            "commitAuthorOld": "hortiSquash",
            "daysBetweenCommits": 4.31,
            "commitsBetweenForRepo": 31,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,117 +1,127 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n+                lastUsed = new int[proximity.size];\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n-                for(int j = 0; j < proximity.size; j++){\n-                    int pos = (offset + j) % proximity.size;\n-                    var other = proximity.get(j);\n+                for(int pos = 0; pos < proximity.size; pos++){\n+                    var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n+                    pb.index = pos;\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n-                    for(int j = 0; j < proximity.size; j++){\n-                        int pos = (offset + j) % proximity.size;\n-                        var other = proximity.get(j);\n+                    for(int pos = 0; pos < proximity.size; pos++){\n+                        var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n+                        pb.index = pos;\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n-                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n+                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                 possibleBlocks.sort(Structs.comps(\n                     Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n-                    Structs.comparingFloat(e -> e.loadFactor)\n-                ));\n+                    Structs.comps(\n+                        Structs.comparingFloat(e -> e.loadFactor),\n+                        Structs.comparingInt(e -> -lastUsed[e.index])\n+                )));\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n+                //increment the priority if not used\n+                for(int i = 0; i < possibleBlocks.size; i++){\n+                    lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n+                }\n+\n                 //trade the items\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n+                    lastUsed[dumpingFrom.index] = 0;\n+                    lastUsed[dumpingTo.index] = 0;\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n                lastUsed = new int[proximity.size];\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                    pb.index = pos;\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n                        pb.index = pos;\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load, and then by last use\n                possibleBlocks.sort(Structs.comps(\n                    Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n                    Structs.comps(\n                        Structs.comparingFloat(e -> e.loadFactor),\n                        Structs.comparingInt(e -> -lastUsed[e.index])\n                )));\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //increment the priority if not used\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    lastUsed[i] = (lastUsed[i] + 1 ) % 2147483647;\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    lastUsed[dumpingFrom.index] = 0;\n                    lastUsed[dumpingTo.index] = 0;\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "10f2a7b59c3c934e5415a1f34084c30848bad919": {
            "type": "Ybodychange",
            "commitMessage": "hortiloader hotfix (#6248)\n\nAdded an offset so they cycle through all buildings having the same load",
            "commitDate": "28/10/21 9:01 AM",
            "commitName": "10f2a7b59c3c934e5415a1f34084c30848bad919",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "25/10/21 5:22 PM",
            "commitNameOld": "59a480cb3073bf74a93b15d9697dcd242e8b8cf9",
            "commitAuthorOld": "hortiSquash",
            "daysBetweenCommits": 2.65,
            "commitsBetweenForRepo": 25,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,115 +1,117 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n-                for(int pos = 0; pos < proximity.size; pos++){\n-                    var other = proximity.get(pos);\n+                for(int j = 0; j < proximity.size; j++){\n+                    int pos = (offset + j) % proximity.size;\n+                    var other = proximity.get(j);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n-                    for(int pos = 0; pos < proximity.size; pos++){\n-                        var other = proximity.get(pos);\n+                    for(int j = 0; j < proximity.size; j++){\n+                        int pos = (offset + j) % proximity.size;\n+                        var other = proximity.get(j);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n                 //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                 possibleBlocks.sort(Structs.comps(\n                     Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n                     Structs.comparingFloat(e -> e.loadFactor)\n                 ));\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //trade the items\n                 if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int j = 0; j < proximity.size; j++){\n                    int pos = (offset + j) % proximity.size;\n                    var other = proximity.get(j);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int j = 0; j < proximity.size; j++){\n                        int pos = (offset + j) % proximity.size;\n                        var other = proximity.get(j);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                possibleBlocks.sort(Structs.comps(\n                    Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n                    Structs.comparingFloat(e -> e.loadFactor)\n                ));\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "59a480cb3073bf74a93b15d9697dcd242e8b8cf9": {
            "type": "Ybodychange",
            "commitMessage": "hortiloaders 1.0.3.0 bug fix (#6233)\n\n* hortiloaders 1.0.3.0 bug fix\r\n\r\nit didnt unload from StackConveyors/Storage when they had the same loadfactor as the factory\r\n\r\n* unloader fix, using fields",
            "commitDate": "25/10/21 5:22 PM",
            "commitName": "59a480cb3073bf74a93b15d9697dcd242e8b8cf9",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "24/10/21 2:18 PM",
            "commitNameOld": "b6acf1af0a0def0bcd5be5c73f2d069ea193d520",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 1.13,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,115 +1,115 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n                 //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                 possibleBlocks.sort(Structs.comps(\n-                    Structs.comparingBool(e -> e.building.block instanceof StorageBlock || e.building.block instanceof StackConveyor),\n+                    Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n                     Structs.comparingFloat(e -> e.loadFactor)\n                 ));\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //trade the items\n-                if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n+                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                possibleBlocks.sort(Structs.comps(\n                    Structs.comparingBool(e -> e.building.block.highUnloadPriority),\n                    Structs.comparingFloat(e -> e.loadFactor)\n                ));\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && (dumpingFrom.loadFactor != dumpingTo.loadFactor || dumpingFrom.building.block.highUnloadPriority)){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "b6acf1af0a0def0bcd5be5c73f2d069ea193d520": {
            "type": "Ybodychange",
            "commitMessage": "Comparator cleanup\n",
            "commitDate": "24/10/21 2:18 PM",
            "commitName": "b6acf1af0a0def0bcd5be5c73f2d069ea193d520",
            "commitAuthor": "Anuken",
            "commitDateOld": "24/10/21 2:14 PM",
            "commitNameOld": "16f4e300a8fe5a69a80b337f40ea604e5da9e76d",
            "commitAuthorOld": "hortiSquash",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,115 +1,115 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n                 //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n-                possibleBlocks.sort((e1, e2) -> {\n-                    int getsPriority = Boolean.compare((e1.building.block instanceof StorageBlock || e1.building.block instanceof StackConveyor), (e2.building.block instanceof StorageBlock || e2.building.block instanceof StackConveyor));\n-                    return (getsPriority != 0) ? getsPriority : Float.compare(e1.loadFactor, e2.loadFactor);\n-                });\n+                possibleBlocks.sort(Structs.comps(\n+                    Structs.comparingBool(e -> e.building.block instanceof StorageBlock || e.building.block instanceof StackConveyor),\n+                    Structs.comparingFloat(e -> e.loadFactor)\n+                ));\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //trade the items\n                 if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                possibleBlocks.sort(Structs.comps(\n                    Structs.comparingBool(e -> e.building.block instanceof StorageBlock || e.building.block instanceof StackConveyor),\n                    Structs.comparingFloat(e -> e.loadFactor)\n                ));\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "16f4e300a8fe5a69a80b337f40ea604e5da9e76d": {
            "type": "Ybodychange",
            "commitMessage": "fixed the full factory priority bug (#6211)\n\n",
            "commitDate": "24/10/21 2:14 PM",
            "commitName": "16f4e300a8fe5a69a80b337f40ea604e5da9e76d",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "22/10/21 9:57 AM",
            "commitNameOld": "c9eed5a936e4af960791b77818b460f5e4ef9243",
            "commitAuthorOld": "hortiSquash",
            "daysBetweenCommits": 2.18,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,117 +1,115 @@\n         public void updateTile(){\n             if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n             Item item = null;\n             boolean any = false;\n             int itemslength = content.items().size;\n \n             //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n             if(possibleBlocks.size != proximity.size){\n                 int tmp = possibleBlocks.size;\n                 possibleBlocks.setSize(proximity.size);\n                 for(int i = tmp; i < proximity.size; i++){\n                     possibleBlocks.set(i, new ContainerStat());\n                 }\n             }\n \n             if(sortItem != null){\n                 item = sortItem;\n \n                 for(int pos = 0; pos < proximity.size; pos++){\n                     var other = proximity.get(pos);\n                     boolean interactable = other.interactable(team);\n \n                     //set the stats of all buildings in possibleBlocks\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     pb.building = other;\n                     pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                     pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                 }\n             }else{\n                 //select the next item for nulloaders\n                 //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                 for(int i = 0; i < itemslength; i++){\n                     int total = (rotations + i + 1) % itemslength;\n                     boolean hasProvider = false;\n                     boolean hasReceiver = false;\n                     boolean isDistinct = false;\n                     Item possibleItem = content.item(total);\n \n                     for(int pos = 0; pos < proximity.size; pos++){\n                         var other = proximity.get(pos);\n                         boolean interactable = other.interactable(team);\n \n                         //set the stats of all buildings in possibleBlocks while we are at it\n                         ContainerStat pb = possibleBlocks.get(pos);\n                         pb.building = other;\n                         pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                         pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n \n                         //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                         if(hasProvider && pb.canLoad) isDistinct = true;\n                         if(hasReceiver && pb.canUnload) isDistinct = true;\n                         hasProvider = hasProvider || pb.canUnload;\n                         hasReceiver = hasReceiver || pb.canLoad;\n                     }\n                     if(isDistinct){\n                         item = possibleItem;\n                         break;\n                     }\n                 }\n             }\n \n             if(item != null){\n                 //only compute the load factor if a transfer is possible\n                 for(int pos = 0; pos < proximity.size; pos++){\n                     ContainerStat pb = possibleBlocks.get(pos);\n                     var other = pb.building;\n                     pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n-                //sort so it gives full priority to blocks that can give but not receive (mainly plast and storage), and then by load\n+                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                 possibleBlocks.sort((e1, e2) -> {\n-                    // TODO: instead of canLoad it should be ((instance of Storage) || (is it a plast belt i can unload from))\n-                    //  otherwise a 100% full factory will get full priority over the storage/plast, barely an issue but still wasting trades and thus speed\n-                    int canLoad = Boolean.compare(e2.canLoad, e1.canLoad);\n-                    return (canLoad != 0) ? canLoad : Float.compare(e1.loadFactor, e2.loadFactor);\n+                    int getsPriority = Boolean.compare((e1.building.block instanceof StorageBlock || e1.building.block instanceof StackConveyor), (e2.building.block instanceof StorageBlock || e2.building.block instanceof StackConveyor));\n+                    return (getsPriority != 0) ? getsPriority : Float.compare(e1.loadFactor, e2.loadFactor);\n                 });\n \n                 ContainerStat dumpingFrom = null;\n                 ContainerStat dumpingTo = null;\n \n                 //choose the building to accept the item\n                 for(int i = 0; i < possibleBlocks.size; i++){\n                     if(possibleBlocks.get(i).canLoad){\n                         dumpingTo = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //choose the building to give the item\n                 for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                     if(possibleBlocks.get(i).canUnload){\n                         dumpingFrom = possibleBlocks.get(i);\n                         break;\n                     }\n                 }\n \n                 //trade the items\n                 if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n                     dumpingTo.building.handleItem(this, item);\n                     dumpingFrom.building.removeStack(item, 1);\n                     any = true;\n                 }\n \n                 if(sortItem == null) rotations = item.id;\n             }\n \n             if(any){\n                 unloadTimer %= speed;\n             }else{\n                 unloadTimer = Math.min(unloadTimer, speed);\n             }\n \n             if(proximity.size > 0){\n                 offset++;\n                 offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (stackConveyors and Storage), and then by load\n                possibleBlocks.sort((e1, e2) -> {\n                    int getsPriority = Boolean.compare((e1.building.block instanceof StorageBlock || e1.building.block instanceof StackConveyor), (e2.building.block instanceof StorageBlock || e2.building.block instanceof StackConveyor));\n                    return (getsPriority != 0) ? getsPriority : Float.compare(e1.loadFactor, e2.loadFactor);\n                });\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "c9eed5a936e4af960791b77818b460f5e4ef9243": {
            "type": "Ybodychange",
            "commitMessage": "horti and the better unloaders (#6201)\n\n* hortiloaders 0.9.8.1 seq fix\r\n\r\n* tiny fixes\r\nadded more comments\r\n\r\n* a tiny fix, and rewriting of a comment",
            "commitDate": "22/10/21 9:57 AM",
            "commitName": "c9eed5a936e4af960791b77818b460f5e4ef9243",
            "commitAuthor": "hortiSquash",
            "commitDateOld": "22/10/21 8:04 AM",
            "commitNameOld": "677e0e6f5845e33be89048d225d20616e4ab2e89",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.08,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,47 +1,117 @@\n         public void updateTile(){\n-            if((unloadTimer += delta()) >= speed){\n-                boolean any = false;\n-                if(rotations == null || rotations.length != proximity.size){\n-                    rotations = new int[proximity.size];\n+            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n+            Item item = null;\n+            boolean any = false;\n+            int itemslength = content.items().size;\n+\n+            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n+            if(possibleBlocks.size != proximity.size){\n+                int tmp = possibleBlocks.size;\n+                possibleBlocks.setSize(proximity.size);\n+                for(int i = tmp; i < proximity.size; i++){\n+                    possibleBlocks.set(i, new ContainerStat());\n+                }\n+            }\n+\n+            if(sortItem != null){\n+                item = sortItem;\n+\n+                for(int pos = 0; pos < proximity.size; pos++){\n+                    var other = proximity.get(pos);\n+                    boolean interactable = other.interactable(team);\n+\n+                    //set the stats of all buildings in possibleBlocks\n+                    ContainerStat pb = possibleBlocks.get(pos);\n+                    pb.building = other;\n+                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n+                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n+                }\n+            }else{\n+                //select the next item for nulloaders\n+                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n+                for(int i = 0; i < itemslength; i++){\n+                    int total = (rotations + i + 1) % itemslength;\n+                    boolean hasProvider = false;\n+                    boolean hasReceiver = false;\n+                    boolean isDistinct = false;\n+                    Item possibleItem = content.item(total);\n+\n+                    for(int pos = 0; pos < proximity.size; pos++){\n+                        var other = proximity.get(pos);\n+                        boolean interactable = other.interactable(team);\n+\n+                        //set the stats of all buildings in possibleBlocks while we are at it\n+                        ContainerStat pb = possibleBlocks.get(pos);\n+                        pb.building = other;\n+                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n+                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n+\n+                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n+                        if(hasProvider && pb.canLoad) isDistinct = true;\n+                        if(hasReceiver && pb.canUnload) isDistinct = true;\n+                        hasProvider = hasProvider || pb.canUnload;\n+                        hasReceiver = hasReceiver || pb.canLoad;\n+                    }\n+                    if(isDistinct){\n+                        item = possibleItem;\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if(item != null){\n+                //only compute the load factor if a transfer is possible\n+                for(int pos = 0; pos < proximity.size; pos++){\n+                    ContainerStat pb = possibleBlocks.get(pos);\n+                    var other = pb.building;\n+                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                 }\n \n-                for(int i = 0; i < proximity.size; i++){\n-                    int pos = (offset + i) % proximity.size;\n-                    var other = proximity.get(pos);\n+                //sort so it gives full priority to blocks that can give but not receive (mainly plast and storage), and then by load\n+                possibleBlocks.sort((e1, e2) -> {\n+                    // TODO: instead of canLoad it should be ((instance of Storage) || (is it a plast belt i can unload from))\n+                    //  otherwise a 100% full factory will get full priority over the storage/plast, barely an issue but still wasting trades and thus speed\n+                    int canLoad = Boolean.compare(e2.canLoad, e1.canLoad);\n+                    return (canLoad != 0) ? canLoad : Float.compare(e1.loadFactor, e2.loadFactor);\n+                });\n \n-                    if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n-                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n-                        //make sure the item can't be dumped back into this block\n-                        dumpingTo = other;\n+                ContainerStat dumpingFrom = null;\n+                ContainerStat dumpingTo = null;\n \n-                        //get item to be taken\n-                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n-\n-                        //remove item if it's dumped correctly\n-                        if(put(item)){\n-                            other.items.remove(item, 1);\n-                            any = true;\n-\n-                            if(sortItem == null){\n-                                rotations[pos] = item.id + 1;\n-                            }\n-\n-                            other.itemTaken(item);\n-                        }else if(sortItem == null){\n-                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n-                        }\n+                //choose the building to accept the item\n+                for(int i = 0; i < possibleBlocks.size; i++){\n+                    if(possibleBlocks.get(i).canLoad){\n+                        dumpingTo = possibleBlocks.get(i);\n+                        break;\n                     }\n                 }\n \n-                if(any){\n-                    unloadTimer %= speed;\n-                }else{\n-                    unloadTimer = Math.min(unloadTimer, speed);\n+                //choose the building to give the item\n+                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n+                    if(possibleBlocks.get(i).canUnload){\n+                        dumpingFrom = possibleBlocks.get(i);\n+                        break;\n+                    }\n                 }\n \n-                if(proximity.size > 0){\n-                    offset ++;\n-                    offset %= proximity.size;\n+                //trade the items\n+                if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n+                    dumpingTo.building.handleItem(this, item);\n+                    dumpingFrom.building.removeStack(item, 1);\n+                    any = true;\n                 }\n+\n+                if(sortItem == null) rotations = item.id;\n+            }\n+\n+            if(any){\n+                unloadTimer %= speed;\n+            }else{\n+                unloadTimer = Math.min(unloadTimer, speed);\n+            }\n+\n+            if(proximity.size > 0){\n+                offset++;\n+                offset %= proximity.size;\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(((unloadTimer += delta()) < speed) || (proximity.size < 2)) return;\n            Item item = null;\n            boolean any = false;\n            int itemslength = content.items().size;\n\n            //initialize possibleBlocks only if the new size is bigger than the previous, to avoid unnecessary allocations\n            if(possibleBlocks.size != proximity.size){\n                int tmp = possibleBlocks.size;\n                possibleBlocks.setSize(proximity.size);\n                for(int i = tmp; i < proximity.size; i++){\n                    possibleBlocks.set(i, new ContainerStat());\n                }\n            }\n\n            if(sortItem != null){\n                item = sortItem;\n\n                for(int pos = 0; pos < proximity.size; pos++){\n                    var other = proximity.get(pos);\n                    boolean interactable = other.interactable(team);\n\n                    //set the stats of all buildings in possibleBlocks\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    pb.building = other;\n                    pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(sortItem);\n                    pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, sortItem);\n                }\n            }else{\n                //select the next item for nulloaders\n                //inspired of nextIndex() but for all proximity at once, and also way more powerful\n                for(int i = 0; i < itemslength; i++){\n                    int total = (rotations + i + 1) % itemslength;\n                    boolean hasProvider = false;\n                    boolean hasReceiver = false;\n                    boolean isDistinct = false;\n                    Item possibleItem = content.item(total);\n\n                    for(int pos = 0; pos < proximity.size; pos++){\n                        var other = proximity.get(pos);\n                        boolean interactable = other.interactable(team);\n\n                        //set the stats of all buildings in possibleBlocks while we are at it\n                        ContainerStat pb = possibleBlocks.get(pos);\n                        pb.building = other;\n                        pb.canUnload = interactable && other.canUnload() && other.items != null && other.items.has(possibleItem);\n                        pb.canLoad = interactable && !(other.block instanceof StorageBlock) && other.acceptItem(this, possibleItem);\n\n                        //the part handling framerate issues and slow conveyor belts, to avoid skipping items\n                        if(hasProvider && pb.canLoad) isDistinct = true;\n                        if(hasReceiver && pb.canUnload) isDistinct = true;\n                        hasProvider = hasProvider || pb.canUnload;\n                        hasReceiver = hasReceiver || pb.canLoad;\n                    }\n                    if(isDistinct){\n                        item = possibleItem;\n                        break;\n                    }\n                }\n            }\n\n            if(item != null){\n                //only compute the load factor if a transfer is possible\n                for(int pos = 0; pos < proximity.size; pos++){\n                    ContainerStat pb = possibleBlocks.get(pos);\n                    var other = pb.building;\n                    pb.loadFactor = (other.getMaximumAccepted(item) == 0) || (other.items == null) ? 0 : other.items.get(item) / (float)other.getMaximumAccepted(item);\n                }\n\n                //sort so it gives full priority to blocks that can give but not receive (mainly plast and storage), and then by load\n                possibleBlocks.sort((e1, e2) -> {\n                    // TODO: instead of canLoad it should be ((instance of Storage) || (is it a plast belt i can unload from))\n                    //  otherwise a 100% full factory will get full priority over the storage/plast, barely an issue but still wasting trades and thus speed\n                    int canLoad = Boolean.compare(e2.canLoad, e1.canLoad);\n                    return (canLoad != 0) ? canLoad : Float.compare(e1.loadFactor, e2.loadFactor);\n                });\n\n                ContainerStat dumpingFrom = null;\n                ContainerStat dumpingTo = null;\n\n                //choose the building to accept the item\n                for(int i = 0; i < possibleBlocks.size; i++){\n                    if(possibleBlocks.get(i).canLoad){\n                        dumpingTo = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //choose the building to give the item\n                for(int i = possibleBlocks.size - 1; i >= 0; i--){\n                    if(possibleBlocks.get(i).canUnload){\n                        dumpingFrom = possibleBlocks.get(i);\n                        break;\n                    }\n                }\n\n                //trade the items\n                if(dumpingFrom != null && dumpingTo != null && dumpingFrom.loadFactor != dumpingTo.loadFactor){\n                    dumpingTo.building.handleItem(this, item);\n                    dumpingFrom.building.removeStack(item, 1);\n                    any = true;\n                }\n\n                if(sortItem == null) rotations = item.id;\n            }\n\n            if(any){\n                unloadTimer %= speed;\n            }else{\n                unloadTimer = Math.min(unloadTimer, speed);\n            }\n\n            if(proximity.size > 0){\n                offset++;\n                offset %= proximity.size;\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "28b235ef07be92808cdba260168ff314db426376": {
            "type": "Ybodychange",
            "commitMessage": "Partial 7.0 merge - API preview\n",
            "commitDate": "02/06/21 10:08 AM",
            "commitName": "28b235ef07be92808cdba260168ff314db426376",
            "commitAuthor": "Anuken",
            "commitDateOld": "15/01/21 4:10 PM",
            "commitNameOld": "02ef633529f93785bc3ee9f49d620a816680c0a8",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 137.71,
            "commitsBetweenForRepo": 571,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,39 +1,47 @@\n         public void updateTile(){\n-            if(timer(timerUnload, speed / timeScale)){\n+            if((unloadTimer += delta()) >= speed){\n+                boolean any = false;\n                 if(rotations == null || rotations.length != proximity.size){\n                     rotations = new int[proximity.size];\n                 }\n \n                 for(int i = 0; i < proximity.size; i++){\n                     int pos = (offset + i) % proximity.size;\n                     var other = proximity.get(pos);\n \n                     if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n                     && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             other.items.remove(item, 1);\n+                            any = true;\n \n                             if(sortItem == null){\n                                 rotations[pos] = item.id + 1;\n                             }\n \n                             other.itemTaken(item);\n                         }else if(sortItem == null){\n                             rotations[pos] = other.items.nextIndex(rotations[pos]);\n                         }\n                     }\n                 }\n \n+                if(any){\n+                    unloadTimer %= speed;\n+                }else{\n+                    unloadTimer = Math.min(unloadTimer, speed);\n+                }\n+\n                 if(proximity.size > 0){\n                     offset ++;\n                     offset %= proximity.size;\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if((unloadTimer += delta()) >= speed){\n                boolean any = false;\n                if(rotations == null || rotations.length != proximity.size){\n                    rotations = new int[proximity.size];\n                }\n\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            other.items.remove(item, 1);\n                            any = true;\n\n                            if(sortItem == null){\n                                rotations[pos] = item.id + 1;\n                            }\n\n                            other.itemTaken(item);\n                        }else if(sortItem == null){\n                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n                        }\n                    }\n                }\n\n                if(any){\n                    unloadTimer %= speed;\n                }else{\n                    unloadTimer = Math.min(unloadTimer, speed);\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "443"
        },
        "02ef633529f93785bc3ee9f49d620a816680c0a8": {
            "type": "Ybodychange",
            "commitMessage": "Removed redundant parens\n",
            "commitDate": "15/01/21 4:10 PM",
            "commitName": "02ef633529f93785bc3ee9f49d620a816680c0a8",
            "commitAuthor": "Anuken",
            "commitDateOld": "24/12/20 9:33 AM",
            "commitNameOld": "9397bd57c4fbdd40156b127ea90f455f99f72b63",
            "commitAuthorOld": "Patrick 'Quezler' Mounier",
            "daysBetweenCommits": 22.28,
            "commitsBetweenForRepo": 125,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,39 +1,39 @@\n         public void updateTile(){\n-            if(timer(timerUnload, speed / timeScale())){\n+            if(timer(timerUnload, speed / timeScale)){\n                 if(rotations == null || rotations.length != proximity.size){\n                     rotations = new int[proximity.size];\n                 }\n \n                 for(int i = 0; i < proximity.size; i++){\n                     int pos = (offset + i) % proximity.size;\n                     var other = proximity.get(pos);\n \n                     if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n                     && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             other.items.remove(item, 1);\n \n                             if(sortItem == null){\n                                 rotations[pos] = item.id + 1;\n                             }\n \n                             other.itemTaken(item);\n                         }else if(sortItem == null){\n                             rotations[pos] = other.items.nextIndex(rotations[pos]);\n                         }\n                     }\n                 }\n \n                 if(proximity.size > 0){\n                     offset ++;\n                     offset %= proximity.size;\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale)){\n                if(rotations == null || rotations.length != proximity.size){\n                    rotations = new int[proximity.size];\n                }\n\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            other.items.remove(item, 1);\n\n                            if(sortItem == null){\n                                rotations[pos] = item.id + 1;\n                            }\n\n                            other.itemTaken(item);\n                        }else if(sortItem == null){\n                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n                        }\n                    }\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "9397bd57c4fbdd40156b127ea90f455f99f72b63": {
            "type": "Ybodychange",
            "commitMessage": "Prevents plastanium conveyor unload exploit (#4098)\n\n* Prevent unloaders from unloading plast loading dock\r\n\r\n* Use overridable boolean method unloadable instead\r\n\r\n* unloadable -> canUnload",
            "commitDate": "24/12/20 9:33 AM",
            "commitName": "9397bd57c4fbdd40156b127ea90f455f99f72b63",
            "commitAuthor": "Patrick 'Quezler' Mounier",
            "commitDateOld": "09/12/20 7:20 PM",
            "commitNameOld": "a544888f16f050890c280fb86103dcb447d99156",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 14.59,
            "commitsBetweenForRepo": 136,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,39 +1,39 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n                 if(rotations == null || rotations.length != proximity.size){\n                     rotations = new int[proximity.size];\n                 }\n \n                 for(int i = 0; i < proximity.size; i++){\n                     int pos = (offset + i) % proximity.size;\n                     var other = proximity.get(pos);\n \n-                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n+                    if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n                     && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             other.items.remove(item, 1);\n \n                             if(sortItem == null){\n                                 rotations[pos] = item.id + 1;\n                             }\n \n                             other.itemTaken(item);\n                         }else if(sortItem == null){\n                             rotations[pos] = other.items.nextIndex(rotations[pos]);\n                         }\n                     }\n                 }\n \n                 if(proximity.size > 0){\n                     offset ++;\n                     offset %= proximity.size;\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                if(rotations == null || rotations.length != proximity.size){\n                    rotations = new int[proximity.size];\n                }\n\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.canUnload() && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            other.items.remove(item, 1);\n\n                            if(sortItem == null){\n                                rotations[pos] = item.id + 1;\n                            }\n\n                            other.itemTaken(item);\n                        }else if(sortItem == null){\n                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n                        }\n                    }\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "a544888f16f050890c280fb86103dcb447d99156": {
            "type": "Ybodychange",
            "commitMessage": "cleanup\n",
            "commitDate": "09/12/20 7:20 PM",
            "commitName": "a544888f16f050890c280fb86103dcb447d99156",
            "commitAuthor": "Anuken",
            "commitDateOld": "09/12/20 7:19 PM",
            "commitNameOld": "57ad1d5366a2acd9dc300a4c68b31b664025f407",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,41 +1,39 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n                 if(rotations == null || rotations.length != proximity.size){\n                     rotations = new int[proximity.size];\n                 }\n \n-                Log.info(\"unloader @\", id);\n-\n                 for(int i = 0; i < proximity.size; i++){\n                     int pos = (offset + i) % proximity.size;\n                     var other = proximity.get(pos);\n \n                     if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                     && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             other.items.remove(item, 1);\n \n                             if(sortItem == null){\n                                 rotations[pos] = item.id + 1;\n                             }\n \n                             other.itemTaken(item);\n                         }else if(sortItem == null){\n                             rotations[pos] = other.items.nextIndex(rotations[pos]);\n                         }\n                     }\n                 }\n \n                 if(proximity.size > 0){\n                     offset ++;\n                     offset %= proximity.size;\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                if(rotations == null || rotations.length != proximity.size){\n                    rotations = new int[proximity.size];\n                }\n\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            other.items.remove(item, 1);\n\n                            if(sortItem == null){\n                                rotations[pos] = item.id + 1;\n                            }\n\n                            other.itemTaken(item);\n                        }else if(sortItem == null){\n                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n                        }\n                    }\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "57ad1d5366a2acd9dc300a4c68b31b664025f407": {
            "type": "Ybodychange",
            "commitMessage": "Fixed #3899\n",
            "commitDate": "09/12/20 7:19 PM",
            "commitName": "57ad1d5366a2acd9dc300a4c68b31b664025f407",
            "commitAuthor": "Anuken",
            "commitDateOld": "12/11/20 8:41 AM",
            "commitNameOld": "e847a74a25112437bc30d68db67fb51a3d1ee200",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 27.44,
            "commitsBetweenForRepo": 562,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,34 +1,41 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n+                if(rotations == null || rotations.length != proximity.size){\n+                    rotations = new int[proximity.size];\n+                }\n+\n+                Log.info(\"unloader @\", id);\n+\n                 for(int i = 0; i < proximity.size; i++){\n                     int pos = (offset + i) % proximity.size;\n                     var other = proximity.get(pos);\n \n                     if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                     && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n-                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n+                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n+                            other.items.remove(item, 1);\n+\n                             if(sortItem == null){\n-                                other.items.endTake(item);\n-                            }else{\n-                                other.items.remove(item, 1);\n+                                rotations[pos] = item.id + 1;\n                             }\n+\n                             other.itemTaken(item);\n                         }else if(sortItem == null){\n-                            other.items.failTake();\n+                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n                         }\n                     }\n                 }\n \n                 if(proximity.size > 0){\n                     offset ++;\n                     offset %= proximity.size;\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                if(rotations == null || rotations.length != proximity.size){\n                    rotations = new int[proximity.size];\n                }\n\n                Log.info(\"unloader @\", id);\n\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.takeIndex(rotations[pos]) : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            other.items.remove(item, 1);\n\n                            if(sortItem == null){\n                                rotations[pos] = item.id + 1;\n                            }\n\n                            other.itemTaken(item);\n                        }else if(sortItem == null){\n                            rotations[pos] = other.items.nextIndex(rotations[pos]);\n                        }\n                    }\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "e847a74a25112437bc30d68db67fb51a3d1ee200": {
            "type": "Ybodychange",
            "commitMessage": "Fixed #3362\n",
            "commitDate": "12/11/20 8:41 AM",
            "commitName": "e847a74a25112437bc30d68db67fb51a3d1ee200",
            "commitAuthor": "Anuken",
            "commitDateOld": "04/11/20 11:45 AM",
            "commitNameOld": "e8a5e35f504bde5a5b689dc6b3693685333ef1aa",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 7.87,
            "commitsBetweenForRepo": 104,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,32 +1,34 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n                 for(int i = 0; i < proximity.size; i++){\n                     int pos = (offset + i) % proximity.size;\n                     var other = proximity.get(pos);\n \n                     if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                     && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.beginTake() : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             if(sortItem == null){\n                                 other.items.endTake(item);\n                             }else{\n                                 other.items.remove(item, 1);\n                             }\n                             other.itemTaken(item);\n+                        }else if(sortItem == null){\n+                            other.items.failTake();\n                         }\n                     }\n                 }\n \n                 if(proximity.size > 0){\n                     offset ++;\n                     offset %= proximity.size;\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items.endTake(item);\n                            }else{\n                                other.items.remove(item, 1);\n                            }\n                            other.itemTaken(item);\n                        }else if(sortItem == null){\n                            other.items.failTake();\n                        }\n                    }\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "e8a5e35f504bde5a5b689dc6b3693685333ef1aa": {
            "type": "Ybodychange",
            "commitMessage": "More achievement cleanup\n",
            "commitDate": "04/11/20 11:45 AM",
            "commitName": "e8a5e35f504bde5a5b689dc6b3693685333ef1aa",
            "commitAuthor": "Anuken",
            "commitDateOld": "10/10/20 6:02 PM",
            "commitNameOld": "bcb248907c8d7bb3fdce5574b4fe455c4084c0c8",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 24.78,
            "commitsBetweenForRepo": 392,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,24 +1,32 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n-                for(Building other : proximity){\n+                for(int i = 0; i < proximity.size; i++){\n+                    int pos = (offset + i) % proximity.size;\n+                    var other = proximity.get(pos);\n+\n                     if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n-                        && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n+                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.beginTake() : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             if(sortItem == null){\n                                 other.items.endTake(item);\n                             }else{\n                                 other.items.remove(item, 1);\n                             }\n                             other.itemTaken(item);\n                         }\n                     }\n                 }\n+\n+                if(proximity.size > 0){\n+                    offset ++;\n+                    offset %= proximity.size;\n+                }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(int i = 0; i < proximity.size; i++){\n                    int pos = (offset + i) % proximity.size;\n                    var other = proximity.get(pos);\n\n                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                    && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items.endTake(item);\n                            }else{\n                                other.items.remove(item, 1);\n                            }\n                            other.itemTaken(item);\n                        }\n                    }\n                }\n\n                if(proximity.size > 0){\n                    offset ++;\n                    offset %= proximity.size;\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "bcb248907c8d7bb3fdce5574b4fe455c4084c0c8": {
            "type": "Ybodychange",
            "commitMessage": "Campaign core item incineration + better idle gen\n",
            "commitDate": "10/10/20 6:02 PM",
            "commitName": "bcb248907c8d7bb3fdce5574b4fe455c4084c0c8",
            "commitAuthor": "Anuken",
            "commitDateOld": "10/09/20 2:17 PM",
            "commitNameOld": "74cefb3ec999eadd50bedaf0f95324b78638f332",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 30.16,
            "commitsBetweenForRepo": 425,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,23 +1,24 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n                 for(Building other : proximity){\n                     if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                         && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.beginTake() : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             if(sortItem == null){\n                                 other.items.endTake(item);\n                             }else{\n                                 other.items.remove(item, 1);\n                             }\n+                            other.itemTaken(item);\n                         }\n                     }\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(Building other : proximity){\n                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                        && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items.endTake(item);\n                            }else{\n                                other.items.remove(item, 1);\n                            }\n                            other.itemTaken(item);\n                        }\n                    }\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "74cefb3ec999eadd50bedaf0f95324b78638f332": {
            "type": "Ybodychange",
            "commitMessage": "Dacite decoration block / Environmental renaming\n",
            "commitDate": "10/09/20 2:17 PM",
            "commitName": "74cefb3ec999eadd50bedaf0f95324b78638f332",
            "commitAuthor": "Anuken",
            "commitDateOld": "25/08/20 7:56 PM",
            "commitNameOld": "58182fe0401455a52325120ea1158a4facadc3e9",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 15.76,
            "commitsBetweenForRepo": 104,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,23 +1,23 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n                 for(Building other : proximity){\n-                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n+                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                         && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items.beginTake() : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             if(sortItem == null){\n                                 other.items.endTake(item);\n                             }else{\n                                 other.items.remove(item, 1);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(Building other : proximity){\n                    if(other.interactable(team) && other.block.unloadable && other.block.hasItems\n                        && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items.endTake(item);\n                            }else{\n                                other.items.remove(item, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "39"
        },
        "5f6c71b9d3f0e535815bd32205ebfadf4517c25c": {
            "type": "Ybodychange",
            "commitMessage": "Replaced concept of \"turns\" with raw seconds\n",
            "commitDate": "01/07/20 10:50 AM",
            "commitName": "5f6c71b9d3f0e535815bd32205ebfadf4517c25c",
            "commitAuthor": "Anuken",
            "commitDateOld": "27/06/20 6:16 PM",
            "commitNameOld": "80332e37d52a1e385a11507a2aa537fc763aa9cf",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 3.69,
            "commitsBetweenForRepo": 15,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,23 +1,23 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n                 for(Building other : proximity){\n                     if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n-                        && ((sortItem == null && other.items().total() > 0) || (sortItem != null && other.items().has(sortItem)))){\n+                        && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n-                        Item item = sortItem == null ? other.items().beginTake() : sortItem;\n+                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             if(sortItem == null){\n-                                other.items().endTake(item);\n+                                other.items.endTake(item);\n                             }else{\n-                                other.items().remove(item, 1);\n+                                other.items.remove(item, 1);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(Building other : proximity){\n                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n                        && ((sortItem == null && other.items.total() > 0) || (sortItem != null && other.items.has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items.beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items.endTake(item);\n                            }else{\n                                other.items.remove(item, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "10"
        },
        "fdf7c88083364bea9736b54fe1f22ba7cc799c85": {
            "type": "Ybodychange",
            "commitMessage": "argh\n",
            "commitDate": "26/06/20 1:27 PM",
            "commitName": "fdf7c88083364bea9736b54fe1f22ba7cc799c85",
            "commitAuthor": "Anuken",
            "commitDateOld": "19/06/20 6:31 PM",
            "commitNameOld": "6bcc103cf7093a6d513937d26a9164371192de6c",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 6.79,
            "commitsBetweenForRepo": 31,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,23 +1,23 @@\n         public void updateTile(){\n             if(timer(timerUnload, speed / timeScale())){\n-                for(Tilec other : proximity){\n+                for(Building other : proximity){\n                     if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n                         && ((sortItem == null && other.items().total() > 0) || (sortItem != null && other.items().has(sortItem)))){\n                         //make sure the item can't be dumped back into this block\n                         dumpingTo = other;\n \n                         //get item to be taken\n                         Item item = sortItem == null ? other.items().beginTake() : sortItem;\n \n                         //remove item if it's dumped correctly\n                         if(put(item)){\n                             if(sortItem == null){\n                                 other.items().endTake(item);\n                             }else{\n                                 other.items().remove(item, 1);\n                             }\n                         }\n                     }\n                 }\n             }\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(Building other : proximity){\n                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n                        && ((sortItem == null && other.items().total() > 0) || (sortItem != null && other.items().has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items().beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items().endTake(item);\n                            }else{\n                                other.items().remove(item, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "177"
        },
        "2b9d618bd270324a54112122d782623b2b348c44": {
            "type": "Ybodychange",
            "commitMessage": "Implemented various suggestions\n\n- Pathfinding weighs walls more\n- C disables all HUD\n- Unloader doesn't store items\n- Some bugfixes\n",
            "commitDate": "07/05/20 8:37 PM",
            "commitName": "2b9d618bd270324a54112122d782623b2b348c44",
            "commitAuthor": "Anuken",
            "commitDateOld": "03/05/20 10:32 AM",
            "commitNameOld": "5c00ced1e382ebea518e942d82eb72845fa6ff28",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 4.42,
            "commitsBetweenForRepo": 39,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,12 +1,23 @@\n         public void updateTile(){\n-            if(timer(timerUnload, speed / timeScale()) && items.total() == 0){\n+            if(timer(timerUnload, speed / timeScale())){\n                 for(Tilec other : proximity){\n-                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems && items.total() == 0 &&\n-                        ((sortItem == null && items.total() > 0) || hasItem(other, sortItem))){\n-                        offloadNear(removeItem(other, sortItem));\n+                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n+                        && ((sortItem == null && other.items().total() > 0) || (sortItem != null && other.items().has(sortItem)))){\n+                        //make sure the item can't be dumped back into this block\n+                        dumpingTo = other;\n+\n+                        //get item to be taken\n+                        Item item = sortItem == null ? other.items().beginTake() : sortItem;\n+\n+                        //remove item if it's dumped correctly\n+                        if(put(item)){\n+                            if(sortItem == null){\n+                                other.items().endTake(item);\n+                            }else{\n+                                other.items().remove(item, 1);\n+                            }\n+                        }\n                     }\n                 }\n             }\n-\n-            dump();\n         }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale())){\n                for(Tilec other : proximity){\n                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems\n                        && ((sortItem == null && other.items().total() > 0) || (sortItem != null && other.items().has(sortItem)))){\n                        //make sure the item can't be dumped back into this block\n                        dumpingTo = other;\n\n                        //get item to be taken\n                        Item item = sortItem == null ? other.items().beginTake() : sortItem;\n\n                        //remove item if it's dumped correctly\n                        if(put(item)){\n                            if(sortItem == null){\n                                other.items().endTake(item);\n                            }else{\n                                other.items().remove(item, 1);\n                            }\n                        }\n                    }\n                }\n            }\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "73c0ebb75f18b35de4d2ed96fc0f64842980252d": {
            "type": "Ybodychange",
            "commitMessage": "Fixed most errors in block package\n",
            "commitDate": "06/03/20 1:41 PM",
            "commitName": "73c0ebb75f18b35de4d2ed96fc0f64842980252d",
            "commitAuthor": "Anuken",
            "commitDateOld": "06/03/20 11:19 AM",
            "commitNameOld": "474446598684df8b560ef2356b086e5b4b772c9f",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.1,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,14 +1,12 @@\n-    public void updateTile(){\n-        if(timer(timerUnload, speed / timeScale()) && tile.items.total() == 0){\n-            for(Tile other : tile.proximity()){\n-                if(other.interactable(team) && other.block().unloadable && other.block().hasItems && items.total() == 0 &&\n-                ((sortItem == null && other.items.total() > 0) || hasItem(other, sortItem))){\n-                    offloadNear(tile, removeItem(other, sortItem));\n+        public void updateTile(){\n+            if(timer(timerUnload, speed / timeScale()) && items.total() == 0){\n+                for(Tilec other : proximity){\n+                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems && items.total() == 0 &&\n+                        ((sortItem == null && items.total() > 0) || hasItem(other, sortItem))){\n+                        offloadNear(removeItem(other, sortItem));\n+                    }\n                 }\n             }\n-        }\n \n-        if(items.total() > 0){\n-            tryDump(tile);\n-        }\n-    }\n\\ No newline at end of file\n+            dump();\n+        }\n\\ No newline at end of file\n",
            "actualSource": "        public void updateTile(){\n            if(timer(timerUnload, speed / timeScale()) && items.total() == 0){\n                for(Tilec other : proximity){\n                    if(other.interactable(team) && other.block().unloadable && other.block().hasItems && items.total() == 0 &&\n                        ((sortItem == null && items.total() > 0) || hasItem(other, sortItem))){\n                        offloadNear(removeItem(other, sortItem));\n                    }\n                }\n            }\n\n            dump();\n        }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "28"
        },
        "1c48c1a43e851d6ec5c9d4cfb42b22b307986c80": {
            "type": "Ybodychange",
            "commitMessage": "Cleanup\n",
            "commitDate": "05/03/20 10:23 PM",
            "commitName": "1c48c1a43e851d6ec5c9d4cfb42b22b307986c80",
            "commitAuthor": "Anuken",
            "commitDateOld": "05/03/20 7:27 PM",
            "commitNameOld": "2e19504b65f86a4f531fec926d16be878d490ab0",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.12,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,14 @@\n     public void updateTile(){\n-        UnloaderEntity entity = tile.ent();\n-\n-        if(tile.entity.timer(timerUnload, speed / entity.timeScale()) && tile.entity.items().total() == 0){\n-            for(Tile other : tile.entity.proximity()){\n-                if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n-                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n-                    offloadNear(tile, removeItem(other, entity.sortItem));\n+        if(timer(timerUnload, speed / timeScale()) && tile.items.total() == 0){\n+            for(Tile other : tile.proximity()){\n+                if(other.interactable(team) && other.block().unloadable && other.block().hasItems && items.total() == 0 &&\n+                ((sortItem == null && other.items.total() > 0) || hasItem(other, sortItem))){\n+                    offloadNear(tile, removeItem(other, sortItem));\n                 }\n             }\n         }\n \n-        if(entity.items().total() > 0){\n+        if(items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void updateTile(){\n        if(timer(timerUnload, speed / timeScale()) && tile.items.total() == 0){\n            for(Tile other : tile.proximity()){\n                if(other.interactable(team) && other.block().unloadable && other.block().hasItems && items.total() == 0 &&\n                ((sortItem == null && other.items.total() > 0) || hasItem(other, sortItem))){\n                    offloadNear(tile, removeItem(other, sortItem));\n                }\n            }\n        }\n\n        if(items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "117"
        },
        "2e19504b65f86a4f531fec926d16be878d490ab0": {
            "type": "Ymultichange(Yrename,Yparameterchange)",
            "commitMessage": "it begins\n",
            "commitDate": "05/03/20 7:27 PM",
            "commitName": "2e19504b65f86a4f531fec926d16be878d490ab0",
            "commitAuthor": "Anuken",
            "subchanges": [
                {
                    "type": "Yrename",
                    "commitMessage": "it begins\n",
                    "commitDate": "05/03/20 7:27 PM",
                    "commitName": "2e19504b65f86a4f531fec926d16be878d490ab0",
                    "commitAuthor": "Anuken",
                    "commitDateOld": "04/03/20 12:32 PM",
                    "commitNameOld": "cf31293d7bbac9da536f5174fa564a8aaa82f536",
                    "commitAuthorOld": "Anuken",
                    "daysBetweenCommits": 1.29,
                    "commitsBetweenForRepo": 8,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,16 +1,16 @@\n-    public void update(Tile tile){\n+    public void updateTile(){\n         UnloaderEntity entity = tile.ent();\n \n         if(tile.entity.timer(timerUnload, speed / entity.timeScale()) && tile.entity.items().total() == 0){\n             for(Tile other : tile.entity.proximity()){\n                 if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items().total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public void updateTile(){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer(timerUnload, speed / entity.timeScale()) && tile.entity.items().total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items().total() > 0){\n            tryDump(tile);\n        }\n    }",
                    "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
                    "extendedDetails": {
                        "oldValue": "update",
                        "newValue": "updateTile"
                    }
                },
                {
                    "type": "Yparameterchange",
                    "commitMessage": "it begins\n",
                    "commitDate": "05/03/20 7:27 PM",
                    "commitName": "2e19504b65f86a4f531fec926d16be878d490ab0",
                    "commitAuthor": "Anuken",
                    "commitDateOld": "04/03/20 12:32 PM",
                    "commitNameOld": "cf31293d7bbac9da536f5174fa564a8aaa82f536",
                    "commitAuthorOld": "Anuken",
                    "daysBetweenCommits": 1.29,
                    "commitsBetweenForRepo": 8,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,16 +1,16 @@\n-    public void update(Tile tile){\n+    public void updateTile(){\n         UnloaderEntity entity = tile.ent();\n \n         if(tile.entity.timer(timerUnload, speed / entity.timeScale()) && tile.entity.items().total() == 0){\n             for(Tile other : tile.entity.proximity()){\n                 if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items().total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public void updateTile(){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer(timerUnload, speed / entity.timeScale()) && tile.entity.items().total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items().total() > 0){\n            tryDump(tile);\n        }\n    }",
                    "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
                    "extendedDetails": {
                        "oldValue": "[tile-Tile]",
                        "newValue": "[]"
                    }
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "53"
        },
        "da97aee8e4151a7d8cedb8922922c8ba41b1c33c": {
            "type": "Ybodychange",
            "commitMessage": "it never ends\n",
            "commitDate": "05/02/20 12:03 PM",
            "commitName": "da97aee8e4151a7d8cedb8922922c8ba41b1c33c",
            "commitAuthor": "Anuken",
            "commitDateOld": "04/02/20 5:00 PM",
            "commitNameOld": "a7b39e56bd313c8091f9dcc3c69b909743204096",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.79,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         UnloaderEntity entity = tile.ent();\n \n         if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.items().total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n+                if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items().total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.items().total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.team()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items().total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "48"
        },
        "a7b39e56bd313c8091f9dcc3c69b909743204096": {
            "type": "Ybodychange",
            "commitMessage": "Cleanup continues\n",
            "commitDate": "04/02/20 5:00 PM",
            "commitName": "a7b39e56bd313c8091f9dcc3c69b909743204096",
            "commitAuthor": "Anuken",
            "commitDateOld": "04/02/20 11:14 AM",
            "commitNameOld": "36b9451e01afc75dacfd280160ec8624f8d055b2",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.24,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         UnloaderEntity entity = tile.ent();\n \n         if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.items().total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.getItems().total() == 0 &&\n+                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n-        if(entity.getItems().total() > 0){\n+        if(entity.items().total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.items().total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items().total() == 0 &&\n                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items().total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "42"
        },
        "36b9451e01afc75dacfd280160ec8624f8d055b2": {
            "type": "Ybodychange",
            "commitMessage": "Read-only component fields / Removed get/set prefix\n",
            "commitDate": "04/02/20 11:14 AM",
            "commitName": "36b9451e01afc75dacfd280160ec8624f8d055b2",
            "commitAuthor": "Anuken",
            "commitDateOld": "03/02/20 7:24 PM",
            "commitNameOld": "a942ed2cad745de978abb71067279ef1f390105e",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.66,
            "commitsBetweenForRepo": 4,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         UnloaderEntity entity = tile.ent();\n \n-        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.getItems().total() == 0){\n+        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.items().total() == 0){\n             for(Tile other : tile.entity.proximity()){\n                 if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.getItems().total() == 0 &&\n-                ((entity.sortItem == null && other.entity.getItems().total() > 0) || hasItem(other, entity.sortItem))){\n+                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.getItems().total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.items().total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.getItems().total() == 0 &&\n                ((entity.sortItem == null && other.entity.items().total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.getItems().total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "74"
        },
        "a942ed2cad745de978abb71067279ef1f390105e": {
            "type": "Ybodychange",
            "commitMessage": "More cleanup\n",
            "commitDate": "03/02/20 7:24 PM",
            "commitName": "a942ed2cad745de978abb71067279ef1f390105e",
            "commitAuthor": "Anuken",
            "commitDateOld": "02/02/20 10:38 PM",
            "commitNameOld": "f937cb30f0edce3ced8e69cc0b9f8a6c177427dd",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.87,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         UnloaderEntity entity = tile.ent();\n \n-        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n+        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.getItems().total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n-                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n+                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.getItems().total() == 0 &&\n+                ((entity.sortItem == null && other.entity.getItems().total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n-        if(entity.items.total() > 0){\n+        if(entity.getItems().total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer(timerUnload, speed / entity.timeScale) && tile.entity.getItems().total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.getItems().total() == 0 &&\n                ((entity.sortItem == null && other.entity.getItems().total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.getItems().total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "103"
        },
        "514d4817c8fdc38f43f85ec73fd8bd3d55cef9db": {
            "type": "Ymovefromfile",
            "commitMessage": "it is done\n",
            "commitDate": "25/12/19 12:39 AM",
            "commitName": "514d4817c8fdc38f43f85ec73fd8bd3d55cef9db",
            "commitAuthor": "Anuken",
            "commitDateOld": "22/12/19 9:05 PM",
            "commitNameOld": "5b21873f3c120cc298ded4683d89ee7b8fde49c0",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 2.15,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {
                "oldPath": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
                "newPath": "core/src/mindustry/world/blocks/storage/Unloader.java",
                "oldMethodName": "update",
                "newMethodName": "update"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "123"
        },
        "1aca3025184044b566a98954ad3063e56ba7884b": {
            "type": "Ybodychange",
            "commitMessage": "Many changes to improve scripting\n",
            "commitDate": "08/12/19 5:34 PM",
            "commitName": "1aca3025184044b566a98954ad3063e56ba7884b",
            "commitAuthor": "Anuken",
            "commitDateOld": "27/11/19 12:51 PM",
            "commitNameOld": "57f9aeee8691d9067beea67d897116ef295f5849",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 11.2,
            "commitsBetweenForRepo": 49,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n-        UnloaderEntity entity = tile.entity();\n+        UnloaderEntity entity = tile.ent();\n \n         if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n                 if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.ent();\n\n        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "63"
        },
        "7bfdbaabe746ae3aef399d43ea8b4563436b90c5": {
            "type": "Ybodychange",
            "commitMessage": "Int configuration / Drone rebuilding\n",
            "commitDate": "30/09/19 6:40 PM",
            "commitName": "7bfdbaabe746ae3aef399d43ea8b4563436b90c5",
            "commitAuthor": "Anuken",
            "commitDateOld": "26/09/19 6:51 PM",
            "commitNameOld": "53d4f4417872cb54ba62cdd66fd7b69ce277b7d3",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 3.99,
            "commitsBetweenForRepo": 46,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n-        SortedUnloaderEntity entity = tile.entity();\n+        UnloaderEntity entity = tile.entity();\n \n         if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n                 if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        UnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "11"
        },
        "6c07c5006a92198a779dc290757473e8c25beb99": {
            "type": "Ybodychange",
            "commitMessage": "Added client implementation for 50 achievemenets\n",
            "commitDate": "13/09/19 9:02 PM",
            "commitName": "6c07c5006a92198a779dc290757473e8c25beb99",
            "commitAuthor": "Anuken",
            "commitDateOld": "13/09/19 7:13 AM",
            "commitNameOld": "55da9df2a1fbcf5501919e2c5ea626f1bfdf81c8",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 0.58,
            "commitsBetweenForRepo": 8,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.interactable(tile.getTeam()) && other.block().unloadable && entity.items.total() == 0 &&\n+                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                     offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && other.block().hasItems && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "11"
        },
        "55da9df2a1fbcf5501919e2c5ea626f1bfdf81c8": {
            "type": "Ybodychange",
            "commitMessage": "Fixed #655\n",
            "commitDate": "13/09/19 7:13 AM",
            "commitName": "55da9df2a1fbcf5501919e2c5ea626f1bfdf81c8",
            "commitAuthor": "Anuken",
            "commitDateOld": "09/09/19 3:22 PM",
            "commitNameOld": "5a3fbf33df338c9dc302df352736510b6e5c5cda",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 3.66,
            "commitsBetweenForRepo": 25,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n-                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock)other.block()).hasItem(other, entity.sortItem))){\n-                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n+                if(other.interactable(tile.getTeam()) && other.block().unloadable && entity.items.total() == 0 &&\n+                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n+                    offloadNear(tile, removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block().unloadable && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || hasItem(other, entity.sortItem))){\n                    offloadNear(tile, removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "2db61f93acfef6ccb8a072b493742d893690603a": {
            "type": "Ybodychange",
            "commitMessage": "Balance\n",
            "commitDate": "11/03/19 8:28 AM",
            "commitName": "2db61f93acfef6ccb8a072b493742d893690603a",
            "commitAuthor": "Anuken",
            "commitDateOld": "09/03/19 8:51 AM",
            "commitNameOld": "563e015c9221da30801beacbc5af7827960d1c25",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 1.94,
            "commitsBetweenForRepo": 15,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n-        if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n+        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n                 if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed / entity.timeScale) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "4677de80c1b8180868a8f4285926ea213d40f862": {
            "type": "Ymultichange(Yfilerename,Ybodychange)",
            "commitMessage": "Destructible grey blocks / Content cleanup / Wave fixes / Impact balance\n",
            "commitDate": "16/02/19 10:10 AM",
            "commitName": "4677de80c1b8180868a8f4285926ea213d40f862",
            "commitAuthor": "Anuken",
            "subchanges": [
                {
                    "type": "Yfilerename",
                    "commitMessage": "Destructible grey blocks / Content cleanup / Wave fixes / Impact balance\n",
                    "commitDate": "16/02/19 10:10 AM",
                    "commitName": "4677de80c1b8180868a8f4285926ea213d40f862",
                    "commitAuthor": "Anuken",
                    "commitDateOld": "15/02/19 5:59 PM",
                    "commitNameOld": "fbcbca6f2465d4a09e0c22c6df9780b1be6b7903",
                    "commitAuthorOld": "Anuken",
                    "daysBetweenCommits": 0.67,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n+                if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
                    "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
                    "extendedDetails": {
                        "oldPath": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
                        "newPath": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Destructible grey blocks / Content cleanup / Wave fixes / Impact balance\n",
                    "commitDate": "16/02/19 10:10 AM",
                    "commitName": "4677de80c1b8180868a8f4285926ea213d40f862",
                    "commitAuthor": "Anuken",
                    "commitDateOld": "15/02/19 5:59 PM",
                    "commitNameOld": "fbcbca6f2465d4a09e0c22c6df9780b1be6b7903",
                    "commitAuthorOld": "Anuken",
                    "daysBetweenCommits": 0.67,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n             for(Tile other : tile.entity.proximity()){\n-                if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n+                if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.interactable(tile.getTeam()) && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
                    "path": "core/src/io/anuke/mindustry/world/blocks/storage/Unloader.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "12"
        },
        "7f391dacbd26248471b97f2eb444da605bd7ab51": {
            "type": "Ybodychange",
            "commitMessage": "Fixed low-FPS movement getting broken\n",
            "commitDate": "16/11/18 4:28 PM",
            "commitName": "7f391dacbd26248471b97f2eb444da605bd7ab51",
            "commitAuthor": "Anuken",
            "commitDateOld": "14/11/18 10:46 PM",
            "commitNameOld": "459256e83abf01d3f02020fb481c8b4d77517d68",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 1.74,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,17 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n-            Log.info(threads.getFrameID());\n             for(Tile other : tile.entity.proximity()){\n                 if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n             }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n            for(Tile other : tile.entity.proximity()){\n                if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "459256e83abf01d3f02020fb481c8b4d77517d68": {
            "type": "Ybodychange",
            "commitMessage": "Slower unloader\n",
            "commitDate": "14/11/18 10:46 PM",
            "commitName": "459256e83abf01d3f02020fb481c8b4d77517d68",
            "commitAuthor": "Anuken",
            "commitDateOld": "28/10/18 9:29 PM",
            "commitNameOld": "d4ea8c56c365ac1b74ed719b56f62059d2582af7",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 17.1,
            "commitsBetweenForRepo": 119,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,17 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n-        if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n-            tile.allNearby(other -> {\n+        if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n+            Log.info(threads.getFrameID());\n+            for(Tile other : tile.entity.proximity()){\n                 if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n-            });\n+            }\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(tile.entity.timer.get(timerUnload, speed) && tile.entity.items.total() == 0){\n            Log.info(threads.getFrameID());\n            for(Tile other : tile.entity.proximity()){\n                if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            }\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "66fab1b3df32da9637150a7bd75ea987f107b381": {
            "type": "Ybodychange",
            "commitMessage": "Added thermal generator / Enemy bases with spawning\n",
            "commitDate": "05/08/18 4:00 PM",
            "commitName": "66fab1b3df32da9637150a7bd75ea987f107b381",
            "commitAuthor": "Anuken",
            "commitDateOld": "26/07/18 2:24 PM",
            "commitNameOld": "c1c82b451d3a175d62cf5e6f7dd6e8149deceaaf",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 10.07,
            "commitsBetweenForRepo": 73,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n             tile.allNearby(other -> {\n-                if(other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n+                if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                 ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n             });\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n            tile.allNearby(other -> {\n                if(other.getTeam() == tile.getTeam() && other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "11"
        },
        "59ade6cf09f970027ba3051f0f65f7c44f19e446": {
            "type": "Ybodychange",
            "commitMessage": "Vault optimizations / Removed unloader\n",
            "commitDate": "14/07/18 9:47 AM",
            "commitName": "59ade6cf09f970027ba3051f0f65f7c44f19e446",
            "commitAuthor": "Anuken",
            "commitDateOld": "12/07/18 7:37 PM",
            "commitNameOld": "baaeb229cf97205d73fe9fb93c15198e9a5d6194",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 1.59,
            "commitsBetweenForRepo": 16,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n         if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n             tile.allNearby(other -> {\n                 if(other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n-                        ((StorageBlock) other.block()).hasItem(other, entity.sortItem)){\n+                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                     offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                 }\n             });\n         }\n \n         if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n            tile.allNearby(other -> {\n                if(other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                ((entity.sortItem == null && other.entity.items.total() > 0) || ((StorageBlock) other.block()).hasItem(other, entity.sortItem))){\n                    offloadNear(tile, ((StorageBlock) other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "d988bb18213aa92b48821f54400d51d12b17612d": {
            "type": "Ybodychange",
            "commitMessage": "Massive amount of bugfixes / Multi-liquid support / Broken build\n",
            "commitDate": "06/07/18 10:24 PM",
            "commitName": "d988bb18213aa92b48821f54400d51d12b17612d",
            "commitAuthor": "Anuken",
            "commitDateOld": "22/06/18 2:07 PM",
            "commitNameOld": "c24eb231abc54d833734fe2aab3de94192baa06c",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 14.34,
            "commitsBetweenForRepo": 137,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n-        if(entity.items.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n+        if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n             tile.allNearby(other -> {\n-                if(other.block() instanceof StorageBlock && entity.items.totalItems() == 0 &&\n+                if(other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                         ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                     offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                 }\n             });\n         }\n \n-        if(entity.items.totalItems() > 0){\n+        if(entity.items.total() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.items.total() == 0 && entity.timer.get(timerUnload, speed)){\n            tile.allNearby(other -> {\n                if(other.block() instanceof StorageBlock && entity.items.total() == 0 &&\n                        ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.items.total() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "67"
        },
        "ccb97e34d54f39e80bc7bea9e5df956d6f1c9941": {
            "type": "Yfilerename",
            "commitMessage": "Moved many block files; work on annotation processor\n",
            "commitDate": "06/06/18 1:51 PM",
            "commitName": "ccb97e34d54f39e80bc7bea9e5df956d6f1c9941",
            "commitAuthor": "Anuken",
            "commitDateOld": "05/06/18 1:03 PM",
            "commitNameOld": "917e2e40fb839b6afe1b4277bd018c2a22d3727f",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 1.03,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.items.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n            tile.allNearby(other -> {\n                if(other.block() instanceof StorageBlock && entity.items.totalItems() == 0 &&\n                        ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.items.totalItems() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java",
            "extendedDetails": {
                "oldPath": "core/src/io/anuke/mindustry/world/blocks/types/storage/SortedUnloader.java",
                "newPath": "core/src/io/anuke/mindustry/world/blocks/storage/SortedUnloader.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "b020bf68165aadc265176df052e7efcb99f1d9d2": {
            "type": "Ybodychange",
            "commitMessage": "Variable name refactorings / Untested entity sleeping\n",
            "commitDate": "17/04/18 8:31 AM",
            "commitName": "b020bf68165aadc265176df052e7efcb99f1d9d2",
            "commitAuthor": "Anuken",
            "commitDateOld": "29/03/18 8:36 PM",
            "commitNameOld": "027e8dc35eeaa6a4825bec58a2ef4dc2da5a8702",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 18.5,
            "commitsBetweenForRepo": 93,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n-        if(entity.inventory.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n+        if(entity.items.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n             tile.allNearby(other -> {\n-                if(other.block() instanceof StorageBlock && entity.inventory.totalItems() == 0 &&\n+                if(other.block() instanceof StorageBlock && entity.items.totalItems() == 0 &&\n                         ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                     offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                 }\n             });\n         }\n \n-        if(entity.inventory.totalItems() > 0){\n+        if(entity.items.totalItems() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.items.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n            tile.allNearby(other -> {\n                if(other.block() instanceof StorageBlock && entity.items.totalItems() == 0 &&\n                        ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.items.totalItems() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/types/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "14"
        },
        "3418979f4d5508ab868a9b0dfc43abdc3f3917ea": {
            "type": "Ybodychange",
            "commitMessage": "Content class reorganization, beginning work on unit factory\n",
            "commitDate": "25/03/18 12:12 PM",
            "commitName": "3418979f4d5508ab868a9b0dfc43abdc3f3917ea",
            "commitAuthor": "Anuken",
            "commitDateOld": "10/03/18 2:22 PM",
            "commitNameOld": "bf6e33791d8df3df04b6fedb2ce18b9c0ff7bd53",
            "commitAuthorOld": "Anuken",
            "daysBetweenCommits": 14.87,
            "commitsBetweenForRepo": 73,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,16 +1,16 @@\n     public void update(Tile tile){\n         SortedUnloaderEntity entity = tile.entity();\n \n-        if(entity.inventory.totalItems() == 0 && entity.timer.get(timerUnload, 5)){\n+        if(entity.inventory.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n             tile.allNearby(other -> {\n                 if(other.block() instanceof StorageBlock && entity.inventory.totalItems() == 0 &&\n                         ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                     offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                 }\n             });\n         }\n \n         if(entity.inventory.totalItems() > 0){\n             tryDump(tile);\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.inventory.totalItems() == 0 && entity.timer.get(timerUnload, speed)){\n            tile.allNearby(other -> {\n                if(other.block() instanceof StorageBlock && entity.inventory.totalItems() == 0 &&\n                        ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.inventory.totalItems() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/types/storage/SortedUnloader.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "bf6e33791d8df3df04b6fedb2ce18b9c0ff7bd53": {
            "type": "Yintroduced",
            "commitMessage": "Added sorted unloader and new block group system\n",
            "commitDate": "10/03/18 2:22 PM",
            "commitName": "bf6e33791d8df3df04b6fedb2ce18b9c0ff7bd53",
            "commitAuthor": "Anuken",
            "diff": "@@ -0,0 +1,16 @@\n+    public void update(Tile tile){\n+        SortedUnloaderEntity entity = tile.entity();\n+\n+        if(entity.inventory.totalItems() == 0 && entity.timer.get(timerUnload, 5)){\n+            tile.allNearby(other -> {\n+                if(other.block() instanceof StorageBlock && entity.inventory.totalItems() == 0 &&\n+                        ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n+                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n+                }\n+            });\n+        }\n+\n+        if(entity.inventory.totalItems() > 0){\n+            tryDump(tile);\n+        }\n+    }\n\\ No newline at end of file\n",
            "actualSource": "    public void update(Tile tile){\n        SortedUnloaderEntity entity = tile.entity();\n\n        if(entity.inventory.totalItems() == 0 && entity.timer.get(timerUnload, 5)){\n            tile.allNearby(other -> {\n                if(other.block() instanceof StorageBlock && entity.inventory.totalItems() == 0 &&\n                        ((StorageBlock)other.block()).hasItem(other, entity.sortItem)){\n                    offloadNear(tile, ((StorageBlock)other.block()).removeItem(other, entity.sortItem));\n                }\n            });\n        }\n\n        if(entity.inventory.totalItems() > 0){\n            tryDump(tile);\n        }\n    }",
            "path": "core/src/io/anuke/mindustry/world/blocks/types/storage/SortedUnloader.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "3355.json"
}