{
    "origin": "codeshovel",
    "repositoryName": "presto",
    "repositoryPath": "/home/shaiful/research/datasets/github-repos/presto/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "StatementAnalyzer.java",
    "functionName": "visitSetOperation",
    "functionId": "visitSetOperation___node-SetOperation__scope-Optional__Scope__",
    "sourceFilePath": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
    "functionStartLine": 1162,
    "functionEndLine": 1241,
    "numCommitsSeen": 967,
    "timeTaken": 14960,
    "changeHistory": [
        "bc2cc2e215c7aabb5f78a7be55b562b229f1ce07",
        "4ec3ca7a2254e34c3fbd9ee41dc3f327c67a5a9f",
        "8c5fccbdf8b6b552dc8a1a1eca8abde67ad273ed",
        "e4e86cbad97486d8d83090e90333f2ad90956f5b",
        "a3d9589ecccc70579d884bc5fecaf882bc1c2ec9",
        "af13d0c5d1b202db1d84ea9ef3f86d747792a75d",
        "58857ce6e2e01b10d64e37f3639f3d49fa13ef32",
        "df99f33ab82b20f6afc362c7eb1d165b30ef8441",
        "1b8a149be5f72edc0a892f65b25676c66acbd0dc",
        "522d0562405e990608c07dc848392dcd49e11a70",
        "2e5b1e90439428f2226f1681fa895d97eaa9ecb2",
        "5a12bd6475f2cb8903e65365fa917269ffc51589",
        "b34d126482a9916c5873a6b945538e055ec4dbd7",
        "f3ff49c3ff7201ddcd8f04dff75362b076f00644",
        "847a2bbeb29cf5eda3876b0e0a9a2d5ee92244ab",
        "0daae668786ccfd02a11de7555305a98b04507cd",
        "41cddded7fd916e63aeeb55484bd3b33c243b974",
        "05fe2b957abe5f11ae1230339e8f55e9096d8fbe",
        "dac2a6dea3b112298973839560f0220c989d2eb5",
        "f3bad1b2fbc4c233dea9d271b686fb4570ef8439",
        "8317c9ef2fdd4101660ee71a4f63655b2a8c87e8",
        "af18c0227b3fe793f2c9072ec593ff32693f821c",
        "696825b0db180ebd982bc46c8ae71412731f8886",
        "e163472c4684e053401a6f3afb71cb4046ced520",
        "f79aa806cd0900479365f953b4b284324af7de00",
        "1229e1fd5f3f1b3733d7a7678afbc086b59b2206",
        "ae66246ebbb9bcf4f1deabc399543d26beadebd3"
    ],
    "changeHistoryShort": {
        "ae66246ebbb9bcf4f1deabc399543d26beadebd3": "Ybodychange",
        "1229e1fd5f3f1b3733d7a7678afbc086b59b2206": "Ybodychange",
        "f79aa806cd0900479365f953b4b284324af7de00": "Ybodychange",
        "e163472c4684e053401a6f3afb71cb4046ced520": "Ybodychange",
        "696825b0db180ebd982bc46c8ae71412731f8886": "Ybodychange",
        "af18c0227b3fe793f2c9072ec593ff32693f821c": "Ybodychange",
        "8317c9ef2fdd4101660ee71a4f63655b2a8c87e8": "Yparameterchange",
        "f3bad1b2fbc4c233dea9d271b686fb4570ef8439": "Ybodychange",
        "dac2a6dea3b112298973839560f0220c989d2eb5": "Ybodychange",
        "05fe2b957abe5f11ae1230339e8f55e9096d8fbe": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
        "41cddded7fd916e63aeeb55484bd3b33c243b974": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
        "0daae668786ccfd02a11de7555305a98b04507cd": "Ybodychange",
        "847a2bbeb29cf5eda3876b0e0a9a2d5ee92244ab": "Ymultichange(Yreturntypechange,Ybodychange)",
        "f3ff49c3ff7201ddcd8f04dff75362b076f00644": "Ybodychange",
        "b34d126482a9916c5873a6b945538e055ec4dbd7": "Ymultichange(Ymovefromfile,Ybodychange)",
        "5a12bd6475f2cb8903e65365fa917269ffc51589": "Ybodychange",
        "2e5b1e90439428f2226f1681fa895d97eaa9ecb2": "Ybodychange",
        "522d0562405e990608c07dc848392dcd49e11a70": "Ybodychange",
        "1b8a149be5f72edc0a892f65b25676c66acbd0dc": "Ybodychange",
        "df99f33ab82b20f6afc362c7eb1d165b30ef8441": "Ybodychange",
        "58857ce6e2e01b10d64e37f3639f3d49fa13ef32": "Ybodychange",
        "af13d0c5d1b202db1d84ea9ef3f86d747792a75d": "Ybodychange",
        "a3d9589ecccc70579d884bc5fecaf882bc1c2ec9": "Ybodychange",
        "e4e86cbad97486d8d83090e90333f2ad90956f5b": "Ybodychange",
        "8c5fccbdf8b6b552dc8a1a1eca8abde67ad273ed": "Ybodychange",
        "4ec3ca7a2254e34c3fbd9ee41dc3f327c67a5a9f": "Ybodychange",
        "bc2cc2e215c7aabb5f78a7be55b562b229f1ce07": "Yintroduced"
    },
    "changeHistoryDetails": {
        "ae66246ebbb9bcf4f1deabc399543d26beadebd3": {
            "type": "Ybodychange",
            "commitMessage": "Remove Metadata.getTypeManager\n\nReplace all call sites with Metadata.getFunctionAndTypeManager\n",
            "commitDate": "10/11/20 1:09 PM",
            "commitName": "ae66246ebbb9bcf4f1deabc399543d26beadebd3",
            "commitAuthor": "Rongrong Zhong",
            "commitDateOld": "21/10/20 12:36 PM",
            "commitNameOld": "12088497e565e8727d71cecaa1abde5e720ce1fd",
            "commitAuthorOld": "prithvip",
            "daysBetweenCommits": 20.07,
            "commitsBetweenForRepo": 70,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,80 +1,80 @@\n         protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n             int outputFieldSize = outputFieldTypes.length;\n             if (isExpensiveUnionDistinct(node, outputFieldTypes)) {\n                 warningCollector.add(new PrestoWarning(\n                         PERFORMANCE_WARNING,\n                         format(\"UNION DISTINCT query should consider avoiding double/real/complex types and reducing the number of visible fields (%d) to %d\",\n                                 outputFieldSize,\n                                 UNION_DISTINCT_FIELDS_WARNING_THRESHOLD)));\n             }\n             for (Scope relationScope : relationScopes) {\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n                 String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(\n                             MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName,\n                             outputFieldSize,\n                             descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n-                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n+                    Optional<Type> commonSuperType = metadata.getFunctionAndTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(\n                                 TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n                                 i + 1,\n                                 setOperationName,\n                                 outputFieldTypes[i].getDisplayName(),\n                                 descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n                         oldField.getOriginColumnName(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            int outputFieldSize = outputFieldTypes.length;\n            if (isExpensiveUnionDistinct(node, outputFieldTypes)) {\n                warningCollector.add(new PrestoWarning(\n                        PERFORMANCE_WARNING,\n                        format(\"UNION DISTINCT query should consider avoiding double/real/complex types and reducing the number of visible fields (%d) to %d\",\n                                outputFieldSize,\n                                UNION_DISTINCT_FIELDS_WARNING_THRESHOLD)));\n            }\n            for (Scope relationScope : relationScopes) {\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(\n                            MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName,\n                            outputFieldSize,\n                            descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getFunctionAndTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(\n                                TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i + 1,\n                                setOperationName,\n                                outputFieldTypes[i].getDisplayName(),\n                                descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.getOriginColumnName(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {}
        },
        "1229e1fd5f3f1b3733d7a7678afbc086b59b2206": {
            "type": "Ybodychange",
            "commitMessage": "Warn when using expensive UNION DISTINCT queries\n\nUNION DISTINCT can be expensive, when there is a lot of data involved.\nWe are sending a warning when there there are many visible fields, and\nsome may be expensive to process.  The current criteria are, that there\nare greater than 3 visible fields, and that one is a real/double or\ncomplex type.\n",
            "commitDate": "19/05/20 11:59 AM",
            "commitName": "1229e1fd5f3f1b3733d7a7678afbc086b59b2206",
            "commitAuthor": "Gregory Nazario",
            "commitDateOld": "05/05/20 8:01 PM",
            "commitNameOld": "04138bc26a4fc801630fe936463d89d071d00c0a",
            "commitAuthorOld": "Nikhil Collooru",
            "daysBetweenCommits": 13.67,
            "commitsBetweenForRepo": 66,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,74 +1,80 @@\n         protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n-\n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n+            int outputFieldSize = outputFieldTypes.length;\n+            if (isExpensiveUnionDistinct(node, outputFieldTypes)) {\n+                warningCollector.add(new PrestoWarning(\n+                        PERFORMANCE_WARNING,\n+                        format(\"UNION DISTINCT query should consider avoiding double/real/complex types and reducing the number of visible fields (%d) to %d\",\n+                                outputFieldSize,\n+                                UNION_DISTINCT_FIELDS_WARNING_THRESHOLD)));\n+            }\n             for (Scope relationScope : relationScopes) {\n-                int outputFieldSize = outputFieldTypes.length;\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n                 String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(\n                             MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName,\n                             outputFieldSize,\n                             descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n                     Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(\n                                 TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n                                 i + 1,\n                                 setOperationName,\n                                 outputFieldTypes[i].getDisplayName(),\n                                 descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n                         oldField.getOriginColumnName(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            int outputFieldSize = outputFieldTypes.length;\n            if (isExpensiveUnionDistinct(node, outputFieldTypes)) {\n                warningCollector.add(new PrestoWarning(\n                        PERFORMANCE_WARNING,\n                        format(\"UNION DISTINCT query should consider avoiding double/real/complex types and reducing the number of visible fields (%d) to %d\",\n                                outputFieldSize,\n                                UNION_DISTINCT_FIELDS_WARNING_THRESHOLD)));\n            }\n            for (Scope relationScope : relationScopes) {\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(\n                            MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName,\n                            outputFieldSize,\n                            descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(\n                                TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i + 1,\n                                setOperationName,\n                                outputFieldTypes[i].getDisplayName(),\n                                descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.getOriginColumnName(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {}
        },
        "f79aa806cd0900479365f953b4b284324af7de00": {
            "type": "Ybodychange",
            "commitMessage": "Track origin column for fields\n\nThis is needed to ensure we only check column access privileges for\norigin columns.\n",
            "commitDate": "22/08/18 2:55 PM",
            "commitName": "f79aa806cd0900479365f953b4b284324af7de00",
            "commitAuthor": "Rebecca Schlussel",
            "commitDateOld": "13/08/18 1:06 PM",
            "commitNameOld": "4bafb4885625fdde4106a4907fefab4dce769198",
            "commitAuthorOld": "Martin Traverso",
            "daysBetweenCommits": 9.08,
            "commitsBetweenForRepo": 82,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,73 +1,74 @@\n         protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n \n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n             for (Scope relationScope : relationScopes) {\n                 int outputFieldSize = outputFieldTypes.length;\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n                 String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(\n                             MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName,\n                             outputFieldSize,\n                             descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n                     Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(\n                                 TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n                                 i + 1,\n                                 setOperationName,\n                                 outputFieldTypes[i].getDisplayName(),\n                                 descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n+                        oldField.getOriginColumnName(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            for (Scope relationScope : relationScopes) {\n                int outputFieldSize = outputFieldTypes.length;\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(\n                            MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName,\n                            outputFieldSize,\n                            descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(\n                                TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i + 1,\n                                setOperationName,\n                                outputFieldTypes[i].getDisplayName(),\n                                descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.getOriginColumnName(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {}
        },
        "e163472c4684e053401a6f3afb71cb4046ced520": {
            "type": "Ybodychange",
            "commitMessage": "Fix wrong error message for UNION type mismatch\n",
            "commitDate": "09/05/18 11:54 AM",
            "commitName": "e163472c4684e053401a6f3afb71cb4046ced520",
            "commitAuthor": "Grzegorz Kokosi\u0144ski",
            "commitDateOld": "09/05/18 11:54 AM",
            "commitNameOld": "2453e634a2737e6a4a83042848ec11082d2b22c6",
            "commitAuthorOld": "Grzegorz Kokosi\u0144ski",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,73 +1,73 @@\n         protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n \n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n             for (Scope relationScope : relationScopes) {\n                 int outputFieldSize = outputFieldTypes.length;\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n                 String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(\n                             MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName,\n                             outputFieldSize,\n                             descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n                     Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(\n                                 TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n-                                i,\n+                                i + 1,\n                                 setOperationName,\n                                 outputFieldTypes[i].getDisplayName(),\n                                 descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            for (Scope relationScope : relationScopes) {\n                int outputFieldSize = outputFieldTypes.length;\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(\n                            MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName,\n                            outputFieldSize,\n                            descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(\n                                TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i + 1,\n                                setOperationName,\n                                outputFieldTypes[i].getDisplayName(),\n                                descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "696825b0db180ebd982bc46c8ae71412731f8886": {
            "type": "Ybodychange",
            "commitMessage": "Uppercase set operation name in error message\n",
            "commitDate": "15/06/17 2:29 PM",
            "commitName": "696825b0db180ebd982bc46c8ae71412731f8886",
            "commitAuthor": "David Phillips",
            "commitDateOld": "15/06/17 5:48 AM",
            "commitNameOld": "e3bf0b92c461b9278fd81bbfc3e4b533b88d9a02",
            "commitAuthorOld": "Lukasz Osipiuk",
            "daysBetweenCommits": 0.36,
            "commitsBetweenForRepo": 7,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,66 +1,66 @@\n         protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n \n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n             for (Scope relationScope : relationScopes) {\n                 int outputFieldSize = outputFieldTypes.length;\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n-                String setOperationName = node.getClass().getSimpleName();\n+                String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName, outputFieldSize, descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n                     Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n                                 i, setOperationName, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            for (Scope relationScope : relationScopes) {\n                int outputFieldSize = outputFieldTypes.length;\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName().toUpperCase(ENGLISH);\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName, outputFieldSize, descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i, setOperationName, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "af18c0227b3fe793f2c9072ec593ff32693f821c": {
            "type": "Ybodychange",
            "commitMessage": "Fix incorrect error on type mismatch for set operation\n\nThe arguments to the error message were swapped.\n",
            "commitDate": "14/06/17 11:00 PM",
            "commitName": "af18c0227b3fe793f2c9072ec593ff32693f821c",
            "commitAuthor": "Martin Traverso",
            "commitDateOld": "07/06/17 10:26 AM",
            "commitNameOld": "ca013b2510b0df6a3d850f34fbcaa38889ef4454",
            "commitAuthorOld": "Anton Petrov",
            "daysBetweenCommits": 7.52,
            "commitsBetweenForRepo": 92,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,66 +1,66 @@\n         protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n \n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n             for (Scope relationScope : relationScopes) {\n                 int outputFieldSize = outputFieldTypes.length;\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n                 String setOperationName = node.getClass().getSimpleName();\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName, outputFieldSize, descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n                     Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n-                                i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n+                                i, setOperationName, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            for (Scope relationScope : relationScopes) {\n                int outputFieldSize = outputFieldTypes.length;\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName();\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName, outputFieldSize, descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i, setOperationName, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "8317c9ef2fdd4101660ee71a4f63655b2a8c87e8": {
            "type": "Yparameterchange",
            "commitMessage": "Use Optional<Scope> as context in StatementAnalyzer\n\nParent in Scope is optional. Therefore StatementAnalyzer\nshould also support case where AST node doesn't have\nany parent Scope. Additionally there might be an\nouter scope (e.g: for subqueries). Using optional\nparent scope context makes it easy to determine which scope\nshould be used as parent (local parent or outer query parent)\nfor newly created scopes.\n",
            "commitDate": "05/04/17 10:34 AM",
            "commitName": "8317c9ef2fdd4101660ee71a4f63655b2a8c87e8",
            "commitAuthor": "Karol Sobczak",
            "commitDateOld": "27/03/17 4:50 PM",
            "commitNameOld": "6431a1bb056ea2e3d2fb2ebb6e71b88e0451b034",
            "commitAuthorOld": "Haozhun Jin",
            "daysBetweenCommits": 8.74,
            "commitsBetweenForRepo": 77,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,66 +1,66 @@\n-        protected Scope visitSetOperation(SetOperation node, Scope scope)\n+        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n         {\n             checkState(node.getRelations().size() >= 2);\n \n             List<Scope> relationScopes = node.getRelations().stream()\n                     .map(relation -> {\n                         Scope relationScope = process(relation, scope);\n                         return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                     })\n                     .collect(toImmutableList());\n \n             Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                     .map(Field::getType)\n                     .toArray(Type[]::new);\n             for (Scope relationScope : relationScopes) {\n                 int outputFieldSize = outputFieldTypes.length;\n                 RelationType relationType = relationScope.getRelationType();\n                 int descFieldSize = relationType.getVisibleFields().size();\n                 String setOperationName = node.getClass().getSimpleName();\n                 if (outputFieldSize != descFieldSize) {\n                     throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                             node,\n                             \"%s query has different number of fields: %d, %d\",\n                             setOperationName, outputFieldSize, descFieldSize);\n                 }\n                 for (int i = 0; i < descFieldSize; i++) {\n                     Type descFieldType = relationType.getFieldByIndex(i).getType();\n                     Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                     if (!commonSuperType.isPresent()) {\n                         throw new SemanticException(TYPE_MISMATCH,\n                                 node,\n                                 \"column %d in %s query has incompatible types: %s, %s\",\n                                 i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                     }\n                     outputFieldTypes[i] = commonSuperType.get();\n                 }\n             }\n \n             Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n             RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n             for (int i = 0; i < outputFieldTypes.length; i++) {\n                 Field oldField = firstDescriptor.getFieldByIndex(i);\n                 outputDescriptorFields[i] = new Field(\n                         oldField.getRelationAlias(),\n                         oldField.getName(),\n                         outputFieldTypes[i],\n                         oldField.isHidden(),\n                         oldField.getOriginTable(),\n                         oldField.isAliased());\n             }\n \n             for (int i = 0; i < node.getRelations().size(); i++) {\n                 Relation relation = node.getRelations().get(i);\n                 Scope relationScope = relationScopes.get(i);\n                 RelationType relationType = relationScope.getRelationType();\n                 for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                     Type outputFieldType = outputFieldTypes[j];\n                     Type descFieldType = relationType.getFieldByIndex(j).getType();\n                     if (!outputFieldType.equals(descFieldType)) {\n                         analysis.addRelationCoercion(relation, outputFieldTypes);\n                         break;\n                     }\n                 }\n             }\n             return createAndAssignScope(node, scope, outputDescriptorFields);\n         }\n\\ No newline at end of file\n",
            "actualSource": "        protected Scope visitSetOperation(SetOperation node, Optional<Scope> scope)\n        {\n            checkState(node.getRelations().size() >= 2);\n\n            List<Scope> relationScopes = node.getRelations().stream()\n                    .map(relation -> {\n                        Scope relationScope = process(relation, scope);\n                        return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                    })\n                    .collect(toImmutableList());\n\n            Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                    .map(Field::getType)\n                    .toArray(Type[]::new);\n            for (Scope relationScope : relationScopes) {\n                int outputFieldSize = outputFieldTypes.length;\n                RelationType relationType = relationScope.getRelationType();\n                int descFieldSize = relationType.getVisibleFields().size();\n                String setOperationName = node.getClass().getSimpleName();\n                if (outputFieldSize != descFieldSize) {\n                    throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                            node,\n                            \"%s query has different number of fields: %d, %d\",\n                            setOperationName, outputFieldSize, descFieldSize);\n                }\n                for (int i = 0; i < descFieldSize; i++) {\n                    Type descFieldType = relationType.getFieldByIndex(i).getType();\n                    Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                    if (!commonSuperType.isPresent()) {\n                        throw new SemanticException(TYPE_MISMATCH,\n                                node,\n                                \"column %d in %s query has incompatible types: %s, %s\",\n                                i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                    }\n                    outputFieldTypes[i] = commonSuperType.get();\n                }\n            }\n\n            Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n            RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n            for (int i = 0; i < outputFieldTypes.length; i++) {\n                Field oldField = firstDescriptor.getFieldByIndex(i);\n                outputDescriptorFields[i] = new Field(\n                        oldField.getRelationAlias(),\n                        oldField.getName(),\n                        outputFieldTypes[i],\n                        oldField.isHidden(),\n                        oldField.getOriginTable(),\n                        oldField.isAliased());\n            }\n\n            for (int i = 0; i < node.getRelations().size(); i++) {\n                Relation relation = node.getRelations().get(i);\n                Scope relationScope = relationScopes.get(i);\n                RelationType relationType = relationScope.getRelationType();\n                for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                    Type outputFieldType = outputFieldTypes[j];\n                    Type descFieldType = relationType.getFieldByIndex(j).getType();\n                    if (!outputFieldType.equals(descFieldType)) {\n                        analysis.addRelationCoercion(relation, outputFieldTypes);\n                        break;\n                    }\n                }\n            }\n            return createAndAssignScope(node, scope, outputDescriptorFields);\n        }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {
                "oldValue": "[node-SetOperation, scope-Scope]",
                "newValue": "[node-SetOperation, scope-Optional<Scope>]"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "51"
        },
        "f3bad1b2fbc4c233dea9d271b686fb4570ef8439": {
            "type": "Ybodychange",
            "commitMessage": "Rename and make createScope methods private\n",
            "commitDate": "10/02/17 1:45 PM",
            "commitName": "f3bad1b2fbc4c233dea9d271b686fb4570ef8439",
            "commitAuthor": "Karol Sobczak",
            "commitDateOld": "10/02/17 1:45 PM",
            "commitNameOld": "c782454b2a2c5b970f573a9404587869bd3577a6",
            "commitAuthorOld": "Karol Sobczak",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,66 +1,66 @@\n     protected Scope visitSetOperation(SetOperation node, Scope scope)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         List<Scope> relationScopes = node.getRelations().stream()\n                 .map(relation -> {\n                     Scope relationScope = process(relation, scope);\n-                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n+                    return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                 })\n                 .collect(toImmutableList());\n \n         Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (Scope relationScope : relationScopes) {\n             int outputFieldSize = outputFieldTypes.length;\n             RelationType relationType = relationScope.getRelationType();\n             int descFieldSize = relationType.getVisibleFields().size();\n             String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"%s query has different number of fields: %d, %d\",\n                         setOperationName, outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descFieldSize; i++) {\n                 Type descFieldType = relationType.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in %s query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(\n                     oldField.getRelationAlias(),\n                     oldField.getName(),\n                     outputFieldTypes[i],\n                     oldField.isHidden(),\n                     oldField.getOriginTable(),\n                     oldField.isAliased());\n         }\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             Scope relationScope = relationScopes.get(i);\n             RelationType relationType = relationScope.getRelationType();\n             for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = relationType.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-        return createScope(node, scope, outputDescriptorFields);\n+        return createAndAssignScope(node, scope, outputDescriptorFields);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected Scope visitSetOperation(SetOperation node, Scope scope)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        List<Scope> relationScopes = node.getRelations().stream()\n                .map(relation -> {\n                    Scope relationScope = process(relation, scope);\n                    return createAndAssignScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                })\n                .collect(toImmutableList());\n\n        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (Scope relationScope : relationScopes) {\n            int outputFieldSize = outputFieldTypes.length;\n            RelationType relationType = relationScope.getRelationType();\n            int descFieldSize = relationType.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descFieldSize; i++) {\n                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(\n                    oldField.getRelationAlias(),\n                    oldField.getName(),\n                    outputFieldTypes[i],\n                    oldField.isHidden(),\n                    oldField.getOriginTable(),\n                    oldField.isAliased());\n        }\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            Scope relationScope = relationScopes.get(i);\n            RelationType relationType = relationScope.getRelationType();\n            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return createAndAssignScope(node, scope, outputDescriptorFields);\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "38"
        },
        "dac2a6dea3b112298973839560f0220c989d2eb5": {
            "type": "Ybodychange",
            "commitMessage": "Track column provenance through analyzer\n\nNeeded by DESCRIBE OUTPUT to display the origin of\nbase columns.\n",
            "commitDate": "07/11/16 5:10 PM",
            "commitName": "dac2a6dea3b112298973839560f0220c989d2eb5",
            "commitAuthor": "Anton Petrov",
            "commitDateOld": "02/11/16 3:31 PM",
            "commitNameOld": "6d9e3974e791014e918e1c887e3dd49f578b4964",
            "commitAuthorOld": "Martin Traverso",
            "daysBetweenCommits": 5.11,
            "commitsBetweenForRepo": 42,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,60 +1,66 @@\n     protected Scope visitSetOperation(SetOperation node, Scope scope)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         List<Scope> relationScopes = node.getRelations().stream()\n                 .map(relation -> {\n                     Scope relationScope = process(relation, scope);\n                     return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                 })\n                 .collect(toImmutableList());\n \n         Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (Scope relationScope : relationScopes) {\n             int outputFieldSize = outputFieldTypes.length;\n             RelationType relationType = relationScope.getRelationType();\n             int descFieldSize = relationType.getVisibleFields().size();\n             String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"%s query has different number of fields: %d, %d\",\n                         setOperationName, outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descFieldSize; i++) {\n                 Type descFieldType = relationType.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in %s query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n-            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n+            outputDescriptorFields[i] = new Field(\n+                    oldField.getRelationAlias(),\n+                    oldField.getName(),\n+                    outputFieldTypes[i],\n+                    oldField.isHidden(),\n+                    oldField.getOriginTable(),\n+                    oldField.isAliased());\n         }\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             Scope relationScope = relationScopes.get(i);\n             RelationType relationType = relationScope.getRelationType();\n             for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = relationType.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n         return createScope(node, scope, outputDescriptorFields);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected Scope visitSetOperation(SetOperation node, Scope scope)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        List<Scope> relationScopes = node.getRelations().stream()\n                .map(relation -> {\n                    Scope relationScope = process(relation, scope);\n                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                })\n                .collect(toImmutableList());\n\n        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (Scope relationScope : relationScopes) {\n            int outputFieldSize = outputFieldTypes.length;\n            RelationType relationType = relationScope.getRelationType();\n            int descFieldSize = relationType.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descFieldSize; i++) {\n                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(\n                    oldField.getRelationAlias(),\n                    oldField.getName(),\n                    outputFieldTypes[i],\n                    oldField.isHidden(),\n                    oldField.getOriginTable(),\n                    oldField.isAliased());\n        }\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            Scope relationScope = relationScopes.get(i);\n            RelationType relationType = relationScope.getRelationType();\n            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return createScope(node, scope, outputDescriptorFields);\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "11"
        },
        "05fe2b957abe5f11ae1230339e8f55e9096d8fbe": {
            "type": "Ymultichange(Yparameterchange,Yreturntypechange,Ybodychange)",
            "commitMessage": "Introduce Scope into semantic analyzer\n\nScope is an object which contains information about entities available\nfor current SQL clauses. It contains current RelationType as well as\ninformation about outer queries RelationTypes and available named queries.\n\nSemantic analyzer was changed in a way that each visit method gets and\nreturns Scope objects. The input scope gives information about the context of\ngiven node. Contains information about outer relation types and\naccessible RelationType.\nReturned Scope contains information about produced entities\n(RelationType).\n\nScopes are stored in Analysis per AST nodes.\nEach to find a Scope for a AST node (expression) we find the closest\nparent which has Scope set in Analysis.\n",
            "commitDate": "12/08/16 11:55 AM",
            "commitName": "05fe2b957abe5f11ae1230339e8f55e9096d8fbe",
            "commitAuthor": "Grzegorz Kokosi\u0144ski",
            "subchanges": [
                {
                    "type": "Yparameterchange",
                    "commitMessage": "Introduce Scope into semantic analyzer\n\nScope is an object which contains information about entities available\nfor current SQL clauses. It contains current RelationType as well as\ninformation about outer queries RelationTypes and available named queries.\n\nSemantic analyzer was changed in a way that each visit method gets and\nreturns Scope objects. The input scope gives information about the context of\ngiven node. Contains information about outer relation types and\naccessible RelationType.\nReturned Scope contains information about produced entities\n(RelationType).\n\nScopes are stored in Analysis per AST nodes.\nEach to find a Scope for a AST node (expression) we find the closest\nparent which has Scope set in Analysis.\n",
                    "commitDate": "12/08/16 11:55 AM",
                    "commitName": "05fe2b957abe5f11ae1230339e8f55e9096d8fbe",
                    "commitAuthor": "Grzegorz Kokosi\u0144ski",
                    "commitDateOld": "09/08/16 2:15 PM",
                    "commitNameOld": "07b6a5725a9652e16a3002dff5885d8f13a13bbc",
                    "commitAuthorOld": "Rebecca Schlussel",
                    "daysBetweenCommits": 2.9,
                    "commitsBetweenForRepo": 31,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,60 @@\n-    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n+    protected Scope visitSetOperation(SetOperation node, Scope scope)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        RelationType[] descriptors = node.getRelations().stream()\n-                .map(relation -> process(relation, context).withOnlyVisibleFields())\n-                .toArray(RelationType[]::new);\n-        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n+        List<Scope> relationScopes = node.getRelations().stream()\n+                .map(relation -> {\n+                    Scope relationScope = process(relation, scope);\n+                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n+                })\n+                .collect(toImmutableList());\n+\n+        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n-        for (RelationType descriptor : descriptors) {\n+        for (Scope relationScope : relationScopes) {\n             int outputFieldSize = outputFieldTypes.length;\n-            int descFieldSize = descriptor.getVisibleFields().size();\n+            RelationType relationType = relationScope.getRelationType();\n+            int descFieldSize = relationType.getVisibleFields().size();\n             String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"%s query has different number of fields: %d, %d\",\n                         setOperationName, outputFieldSize, descFieldSize);\n             }\n-            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n-                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n+            for (int i = 0; i < descFieldSize; i++) {\n+                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in %s query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n-        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n+        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n-        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n-        analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n-            RelationType descriptor = descriptors[i];\n-            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n+            Scope relationScope = relationScopes.get(i);\n+            RelationType relationType = relationScope.getRelationType();\n+            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n-                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n+                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-        return outputDescriptor;\n+        return createScope(node, scope, outputDescriptorFields);\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected Scope visitSetOperation(SetOperation node, Scope scope)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        List<Scope> relationScopes = node.getRelations().stream()\n                .map(relation -> {\n                    Scope relationScope = process(relation, scope);\n                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                })\n                .collect(toImmutableList());\n\n        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (Scope relationScope : relationScopes) {\n            int outputFieldSize = outputFieldTypes.length;\n            RelationType relationType = relationScope.getRelationType();\n            int descFieldSize = relationType.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descFieldSize; i++) {\n                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            Scope relationScope = relationScopes.get(i);\n            RelationType relationType = relationScope.getRelationType();\n            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return createScope(node, scope, outputDescriptorFields);\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {
                        "oldValue": "[node-SetOperation, context-AnalysisContext]",
                        "newValue": "[node-SetOperation, scope-Scope]"
                    }
                },
                {
                    "type": "Yreturntypechange",
                    "commitMessage": "Introduce Scope into semantic analyzer\n\nScope is an object which contains information about entities available\nfor current SQL clauses. It contains current RelationType as well as\ninformation about outer queries RelationTypes and available named queries.\n\nSemantic analyzer was changed in a way that each visit method gets and\nreturns Scope objects. The input scope gives information about the context of\ngiven node. Contains information about outer relation types and\naccessible RelationType.\nReturned Scope contains information about produced entities\n(RelationType).\n\nScopes are stored in Analysis per AST nodes.\nEach to find a Scope for a AST node (expression) we find the closest\nparent which has Scope set in Analysis.\n",
                    "commitDate": "12/08/16 11:55 AM",
                    "commitName": "05fe2b957abe5f11ae1230339e8f55e9096d8fbe",
                    "commitAuthor": "Grzegorz Kokosi\u0144ski",
                    "commitDateOld": "09/08/16 2:15 PM",
                    "commitNameOld": "07b6a5725a9652e16a3002dff5885d8f13a13bbc",
                    "commitAuthorOld": "Rebecca Schlussel",
                    "daysBetweenCommits": 2.9,
                    "commitsBetweenForRepo": 31,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,60 @@\n-    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n+    protected Scope visitSetOperation(SetOperation node, Scope scope)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        RelationType[] descriptors = node.getRelations().stream()\n-                .map(relation -> process(relation, context).withOnlyVisibleFields())\n-                .toArray(RelationType[]::new);\n-        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n+        List<Scope> relationScopes = node.getRelations().stream()\n+                .map(relation -> {\n+                    Scope relationScope = process(relation, scope);\n+                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n+                })\n+                .collect(toImmutableList());\n+\n+        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n-        for (RelationType descriptor : descriptors) {\n+        for (Scope relationScope : relationScopes) {\n             int outputFieldSize = outputFieldTypes.length;\n-            int descFieldSize = descriptor.getVisibleFields().size();\n+            RelationType relationType = relationScope.getRelationType();\n+            int descFieldSize = relationType.getVisibleFields().size();\n             String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"%s query has different number of fields: %d, %d\",\n                         setOperationName, outputFieldSize, descFieldSize);\n             }\n-            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n-                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n+            for (int i = 0; i < descFieldSize; i++) {\n+                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in %s query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n-        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n+        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n-        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n-        analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n-            RelationType descriptor = descriptors[i];\n-            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n+            Scope relationScope = relationScopes.get(i);\n+            RelationType relationType = relationScope.getRelationType();\n+            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n-                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n+                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-        return outputDescriptor;\n+        return createScope(node, scope, outputDescriptorFields);\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected Scope visitSetOperation(SetOperation node, Scope scope)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        List<Scope> relationScopes = node.getRelations().stream()\n                .map(relation -> {\n                    Scope relationScope = process(relation, scope);\n                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                })\n                .collect(toImmutableList());\n\n        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (Scope relationScope : relationScopes) {\n            int outputFieldSize = outputFieldTypes.length;\n            RelationType relationType = relationScope.getRelationType();\n            int descFieldSize = relationType.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descFieldSize; i++) {\n                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            Scope relationScope = relationScopes.get(i);\n            RelationType relationType = relationScope.getRelationType();\n            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return createScope(node, scope, outputDescriptorFields);\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {
                        "oldValue": "RelationType",
                        "newValue": "Scope"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Introduce Scope into semantic analyzer\n\nScope is an object which contains information about entities available\nfor current SQL clauses. It contains current RelationType as well as\ninformation about outer queries RelationTypes and available named queries.\n\nSemantic analyzer was changed in a way that each visit method gets and\nreturns Scope objects. The input scope gives information about the context of\ngiven node. Contains information about outer relation types and\naccessible RelationType.\nReturned Scope contains information about produced entities\n(RelationType).\n\nScopes are stored in Analysis per AST nodes.\nEach to find a Scope for a AST node (expression) we find the closest\nparent which has Scope set in Analysis.\n",
                    "commitDate": "12/08/16 11:55 AM",
                    "commitName": "05fe2b957abe5f11ae1230339e8f55e9096d8fbe",
                    "commitAuthor": "Grzegorz Kokosi\u0144ski",
                    "commitDateOld": "09/08/16 2:15 PM",
                    "commitNameOld": "07b6a5725a9652e16a3002dff5885d8f13a13bbc",
                    "commitAuthorOld": "Rebecca Schlussel",
                    "daysBetweenCommits": 2.9,
                    "commitsBetweenForRepo": 31,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,60 @@\n-    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n+    protected Scope visitSetOperation(SetOperation node, Scope scope)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        RelationType[] descriptors = node.getRelations().stream()\n-                .map(relation -> process(relation, context).withOnlyVisibleFields())\n-                .toArray(RelationType[]::new);\n-        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n+        List<Scope> relationScopes = node.getRelations().stream()\n+                .map(relation -> {\n+                    Scope relationScope = process(relation, scope);\n+                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n+                })\n+                .collect(toImmutableList());\n+\n+        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n-        for (RelationType descriptor : descriptors) {\n+        for (Scope relationScope : relationScopes) {\n             int outputFieldSize = outputFieldTypes.length;\n-            int descFieldSize = descriptor.getVisibleFields().size();\n+            RelationType relationType = relationScope.getRelationType();\n+            int descFieldSize = relationType.getVisibleFields().size();\n             String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"%s query has different number of fields: %d, %d\",\n                         setOperationName, outputFieldSize, descFieldSize);\n             }\n-            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n-                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n+            for (int i = 0; i < descFieldSize; i++) {\n+                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in %s query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n-        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n+        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n-        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n-        analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n-            RelationType descriptor = descriptors[i];\n-            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n+            Scope relationScope = relationScopes.get(i);\n+            RelationType relationType = relationScope.getRelationType();\n+            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n-                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n+                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-        return outputDescriptor;\n+        return createScope(node, scope, outputDescriptorFields);\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected Scope visitSetOperation(SetOperation node, Scope scope)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        List<Scope> relationScopes = node.getRelations().stream()\n                .map(relation -> {\n                    Scope relationScope = process(relation, scope);\n                    return createScope(relation, scope, relationScope.getRelationType().withOnlyVisibleFields());\n                })\n                .collect(toImmutableList());\n\n        Type[] outputFieldTypes = relationScopes.get(0).getRelationType().getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (Scope relationScope : relationScopes) {\n            int outputFieldSize = outputFieldTypes.length;\n            RelationType relationType = relationScope.getRelationType();\n            int descFieldSize = relationType.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descFieldSize; i++) {\n                Type descFieldType = relationType.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = relationScopes.get(0).getRelationType().withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            Scope relationScope = relationScopes.get(i);\n            RelationType relationType = relationScope.getRelationType();\n            for (int j = 0; j < relationType.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = relationType.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return createScope(node, scope, outputDescriptorFields);\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "165"
        },
        "41cddded7fd916e63aeeb55484bd3b33c243b974": {
            "type": "Ymultichange(Yrename,Yparameterchange,Ybodychange)",
            "commitMessage": "Implement INTERSECT\n\nImplement INTERSECT sql as a query rewrite. Added a new optimization\nrule for rewriting an INTERSECT query to UNION ALL. The rewrite for:\n\nSELECT a from foo\nINTERSECT\nSELECT x FROM bar\n\nis:\n\nSELECT a FROM (\n  SELECT a, COUNT(foo_marker) AS foo_cnt, COUNT(bar_marker) AS bar_cnt\n  FROM (\n    SELECT a, true as foo_marker, null as bar_marker\n    FROM foo\n\n    UNION ALL\n\n    SELECT x, null as foo_marker, true as bar_marker\n    FROM bar\n  ) t1\n  GROUP BY a\n) t2\nWHERE foo_cnt >= 1 AND bar_cnt >= 1\n\nFixes #4918\n",
            "commitDate": "04/05/16 3:25 PM",
            "commitName": "41cddded7fd916e63aeeb55484bd3b33c243b974",
            "commitAuthor": "Anu Sudarsan",
            "subchanges": [
                {
                    "type": "Yrename",
                    "commitMessage": "Implement INTERSECT\n\nImplement INTERSECT sql as a query rewrite. Added a new optimization\nrule for rewriting an INTERSECT query to UNION ALL. The rewrite for:\n\nSELECT a from foo\nINTERSECT\nSELECT x FROM bar\n\nis:\n\nSELECT a FROM (\n  SELECT a, COUNT(foo_marker) AS foo_cnt, COUNT(bar_marker) AS bar_cnt\n  FROM (\n    SELECT a, true as foo_marker, null as bar_marker\n    FROM foo\n\n    UNION ALL\n\n    SELECT x, null as foo_marker, true as bar_marker\n    FROM bar\n  ) t1\n  GROUP BY a\n) t2\nWHERE foo_cnt >= 1 AND bar_cnt >= 1\n\nFixes #4918\n",
                    "commitDate": "04/05/16 3:25 PM",
                    "commitName": "41cddded7fd916e63aeeb55484bd3b33c243b974",
                    "commitAuthor": "Anu Sudarsan",
                    "commitDateOld": "02/05/16 1:17 PM",
                    "commitNameOld": "542d91168e5828d0971f0a68c872c20c9bf5be2e",
                    "commitAuthorOld": "David Phillips",
                    "daysBetweenCommits": 2.09,
                    "commitsBetweenForRepo": 27,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,56 @@\n-    protected RelationType visitUnion(Union node, AnalysisContext context)\n+    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         RelationType[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(RelationType[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (RelationType descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n+            String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n-                        \"union query has different number of fields: %d, %d\",\n-                        outputFieldSize, descFieldSize);\n+                        \"%s query has different number of fields: %d, %d\",\n+                        setOperationName, outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n-                            \"column %d in union query has incompatible types: %s, %s\",\n-                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n+                            \"column %d in %s query has incompatible types: %s, %s\",\n+                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             RelationType descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        RelationType[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(RelationType[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (RelationType descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            RelationType descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {
                        "oldValue": "visitUnion",
                        "newValue": "visitSetOperation"
                    }
                },
                {
                    "type": "Yparameterchange",
                    "commitMessage": "Implement INTERSECT\n\nImplement INTERSECT sql as a query rewrite. Added a new optimization\nrule for rewriting an INTERSECT query to UNION ALL. The rewrite for:\n\nSELECT a from foo\nINTERSECT\nSELECT x FROM bar\n\nis:\n\nSELECT a FROM (\n  SELECT a, COUNT(foo_marker) AS foo_cnt, COUNT(bar_marker) AS bar_cnt\n  FROM (\n    SELECT a, true as foo_marker, null as bar_marker\n    FROM foo\n\n    UNION ALL\n\n    SELECT x, null as foo_marker, true as bar_marker\n    FROM bar\n  ) t1\n  GROUP BY a\n) t2\nWHERE foo_cnt >= 1 AND bar_cnt >= 1\n\nFixes #4918\n",
                    "commitDate": "04/05/16 3:25 PM",
                    "commitName": "41cddded7fd916e63aeeb55484bd3b33c243b974",
                    "commitAuthor": "Anu Sudarsan",
                    "commitDateOld": "02/05/16 1:17 PM",
                    "commitNameOld": "542d91168e5828d0971f0a68c872c20c9bf5be2e",
                    "commitAuthorOld": "David Phillips",
                    "daysBetweenCommits": 2.09,
                    "commitsBetweenForRepo": 27,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,56 @@\n-    protected RelationType visitUnion(Union node, AnalysisContext context)\n+    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         RelationType[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(RelationType[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (RelationType descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n+            String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n-                        \"union query has different number of fields: %d, %d\",\n-                        outputFieldSize, descFieldSize);\n+                        \"%s query has different number of fields: %d, %d\",\n+                        setOperationName, outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n-                            \"column %d in union query has incompatible types: %s, %s\",\n-                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n+                            \"column %d in %s query has incompatible types: %s, %s\",\n+                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             RelationType descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        RelationType[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(RelationType[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (RelationType descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            RelationType descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {
                        "oldValue": "[node-Union, context-AnalysisContext]",
                        "newValue": "[node-SetOperation, context-AnalysisContext]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Implement INTERSECT\n\nImplement INTERSECT sql as a query rewrite. Added a new optimization\nrule for rewriting an INTERSECT query to UNION ALL. The rewrite for:\n\nSELECT a from foo\nINTERSECT\nSELECT x FROM bar\n\nis:\n\nSELECT a FROM (\n  SELECT a, COUNT(foo_marker) AS foo_cnt, COUNT(bar_marker) AS bar_cnt\n  FROM (\n    SELECT a, true as foo_marker, null as bar_marker\n    FROM foo\n\n    UNION ALL\n\n    SELECT x, null as foo_marker, true as bar_marker\n    FROM bar\n  ) t1\n  GROUP BY a\n) t2\nWHERE foo_cnt >= 1 AND bar_cnt >= 1\n\nFixes #4918\n",
                    "commitDate": "04/05/16 3:25 PM",
                    "commitName": "41cddded7fd916e63aeeb55484bd3b33c243b974",
                    "commitAuthor": "Anu Sudarsan",
                    "commitDateOld": "02/05/16 1:17 PM",
                    "commitNameOld": "542d91168e5828d0971f0a68c872c20c9bf5be2e",
                    "commitAuthorOld": "David Phillips",
                    "daysBetweenCommits": 2.09,
                    "commitsBetweenForRepo": 27,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,56 @@\n-    protected RelationType visitUnion(Union node, AnalysisContext context)\n+    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         RelationType[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(RelationType[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (RelationType descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n+            String setOperationName = node.getClass().getSimpleName();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n-                        \"union query has different number of fields: %d, %d\",\n-                        outputFieldSize, descFieldSize);\n+                        \"%s query has different number of fields: %d, %d\",\n+                        setOperationName, outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n-                            \"column %d in union query has incompatible types: %s, %s\",\n-                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n+                            \"column %d in %s query has incompatible types: %s, %s\",\n+                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             RelationType descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n-\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected RelationType visitSetOperation(SetOperation node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        RelationType[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(RelationType[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (RelationType descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            String setOperationName = node.getClass().getSimpleName();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"%s query has different number of fields: %d, %d\",\n                        setOperationName, outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in %s query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), setOperationName, descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            RelationType descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "33"
        },
        "0daae668786ccfd02a11de7555305a98b04507cd": {
            "type": "Ybodychange",
            "commitMessage": "Refactor getCommonSuperType and canCoerce\n\n* Now that they take both Type and TypeSignature\n* Coercion rules were duplicated in the original code (and diverged).\n  The rules appear only once in the code after this commit.\n* Coercion between types with type parameters (e.g. array<T> and array<U>)\n  could be arbitrary and potentially complex. After this commit,\n  coercibility between types is decoupled from compatibility between\n  type parameters.\n* Add tests\n",
            "commitDate": "02/12/15 12:49 PM",
            "commitName": "0daae668786ccfd02a11de7555305a98b04507cd",
            "commitAuthor": "Haozhun Jin",
            "commitDateOld": "02/12/15 10:55 AM",
            "commitNameOld": "1bc06768a61c2885b24cfb5272121f69dd18b261",
            "commitAuthorOld": "David Phillips",
            "daysBetweenCommits": 0.08,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,56 +1,56 @@\n     protected RelationType visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         RelationType[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(RelationType[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (RelationType descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"union query has different number of fields: %d, %d\",\n                         outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n-                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n+                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in union query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             RelationType descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected RelationType visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        RelationType[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(RelationType[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (RelationType descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"union query has different number of fields: %d, %d\",\n                        outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = metadata.getTypeManager().getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in union query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            RelationType descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "13"
        },
        "847a2bbeb29cf5eda3876b0e0a9a2d5ee92244ab": {
            "type": "Ymultichange(Yreturntypechange,Ybodychange)",
            "commitMessage": "Rename TupleDescriptor to RelationType\n\nTupleDescriptor is a legacy name. It represents the type of each\nelement in a relation, so the new name is more accurate.\n\nAt some point, when the type system is unified, it should be merged\nwith RowType\n",
            "commitDate": "05/11/15 11:41 AM",
            "commitName": "847a2bbeb29cf5eda3876b0e0a9a2d5ee92244ab",
            "commitAuthor": "Martin Traverso",
            "subchanges": [
                {
                    "type": "Yreturntypechange",
                    "commitMessage": "Rename TupleDescriptor to RelationType\n\nTupleDescriptor is a legacy name. It represents the type of each\nelement in a relation, so the new name is more accurate.\n\nAt some point, when the type system is unified, it should be merged\nwith RowType\n",
                    "commitDate": "05/11/15 11:41 AM",
                    "commitName": "847a2bbeb29cf5eda3876b0e0a9a2d5ee92244ab",
                    "commitAuthor": "Martin Traverso",
                    "commitDateOld": "05/11/15 11:41 AM",
                    "commitNameOld": "f3ff49c3ff7201ddcd8f04dff75362b076f00644",
                    "commitAuthorOld": "Martin Traverso",
                    "daysBetweenCommits": 0.0,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,56 @@\n-    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n+    protected RelationType visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleDescriptor[] descriptors = node.getRelations().stream()\n+        RelationType[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n-                .toArray(TupleDescriptor[]::new);\n+                .toArray(RelationType[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n-        for (TupleDescriptor descriptor : descriptors) {\n+        for (RelationType descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"union query has different number of fields: %d, %d\",\n                         outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in union query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n-        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n+        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n-        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n+        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n-            TupleDescriptor descriptor = descriptors[i];\n+            RelationType descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected RelationType visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        RelationType[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(RelationType[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (RelationType descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"union query has different number of fields: %d, %d\",\n                        outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in union query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            RelationType descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {
                        "oldValue": "TupleDescriptor",
                        "newValue": "RelationType"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Rename TupleDescriptor to RelationType\n\nTupleDescriptor is a legacy name. It represents the type of each\nelement in a relation, so the new name is more accurate.\n\nAt some point, when the type system is unified, it should be merged\nwith RowType\n",
                    "commitDate": "05/11/15 11:41 AM",
                    "commitName": "847a2bbeb29cf5eda3876b0e0a9a2d5ee92244ab",
                    "commitAuthor": "Martin Traverso",
                    "commitDateOld": "05/11/15 11:41 AM",
                    "commitNameOld": "f3ff49c3ff7201ddcd8f04dff75362b076f00644",
                    "commitAuthorOld": "Martin Traverso",
                    "daysBetweenCommits": 0.0,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,56 +1,56 @@\n-    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n+    protected RelationType visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleDescriptor[] descriptors = node.getRelations().stream()\n+        RelationType[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n-                .toArray(TupleDescriptor[]::new);\n+                .toArray(RelationType[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(Field::getType)\n                 .toArray(Type[]::new);\n-        for (TupleDescriptor descriptor : descriptors) {\n+        for (RelationType descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"union query has different number of fields: %d, %d\",\n                         outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in union query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n-        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n+        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n-        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n+        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n-            TupleDescriptor descriptor = descriptors[i];\n+            RelationType descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected RelationType visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        RelationType[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(RelationType[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (RelationType descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"union query has different number of fields: %d, %d\",\n                        outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in union query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        RelationType firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        RelationType outputDescriptor = new RelationType(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            RelationType descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "65"
        },
        "f3ff49c3ff7201ddcd8f04dff75362b076f00644": {
            "type": "Ybodychange",
            "commitMessage": "Migrate to Java 8 streams\n",
            "commitDate": "05/11/15 11:41 AM",
            "commitName": "f3ff49c3ff7201ddcd8f04dff75362b076f00644",
            "commitAuthor": "Martin Traverso",
            "commitDateOld": "05/11/15 11:41 AM",
            "commitNameOld": "b34d126482a9916c5873a6b945538e055ec4dbd7",
            "commitAuthorOld": "Martin Traverso",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,56 +1,56 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         TupleDescriptor[] descriptors = node.getRelations().stream()\n                 .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(TupleDescriptor[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n-                .map(field -> field.getType())\n+                .map(Field::getType)\n                 .toArray(Type[]::new);\n         for (TupleDescriptor descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                         node,\n                         \"union query has different number of fields: %d, %d\",\n                         outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                             node,\n                             \"column %d in union query has incompatible types: %s, %s\",\n                             i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             TupleDescriptor descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleDescriptor[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(TupleDescriptor[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(Field::getType)\n                .toArray(Type[]::new);\n        for (TupleDescriptor descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"union query has different number of fields: %d, %d\",\n                        outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in union query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            TupleDescriptor descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "6"
        },
        "b34d126482a9916c5873a6b945538e055ec4dbd7": {
            "type": "Ymultichange(Ymovefromfile,Ybodychange)",
            "commitMessage": "Merge StatementAnalyzer with TupleAnalyzer\n\nThey were distinct classes for legacy reasons, but they are really\npart of the same process.\n",
            "commitDate": "05/11/15 11:41 AM",
            "commitName": "b34d126482a9916c5873a6b945538e055ec4dbd7",
            "commitAuthor": "Martin Traverso",
            "subchanges": [
                {
                    "type": "Ymovefromfile",
                    "commitMessage": "Merge StatementAnalyzer with TupleAnalyzer\n\nThey were distinct classes for legacy reasons, but they are really\npart of the same process.\n",
                    "commitDate": "05/11/15 11:41 AM",
                    "commitName": "b34d126482a9916c5873a6b945538e055ec4dbd7",
                    "commitAuthor": "Martin Traverso",
                    "commitDateOld": "05/11/15 11:32 AM",
                    "commitNameOld": "b75d021b62b1657cbbf2334fd664a39389c111fd",
                    "commitAuthorOld": "Nezih Yigitbasi",
                    "daysBetweenCommits": 0.01,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,58 +1,56 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, accessControl, experimentalSyntaxEnabled);\n-\n         TupleDescriptor[] descriptors = node.getRelations().stream()\n-                .map(relation -> analyzer.process(relation, context).withOnlyVisibleFields())\n+                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(TupleDescriptor[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(field -> field.getType())\n                 .toArray(Type[]::new);\n         for (TupleDescriptor descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n-                                            node,\n-                                            \"union query has different number of fields: %d, %d\",\n-                                            outputFieldSize, descFieldSize);\n+                        node,\n+                        \"union query has different number of fields: %d, %d\",\n+                        outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n-                                                node,\n-                                                \"column %d in union query has incompatible types: %s, %s\",\n-                                                i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n+                            node,\n+                            \"column %d in union query has incompatible types: %s, %s\",\n+                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             TupleDescriptor descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleDescriptor[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(TupleDescriptor[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(field -> field.getType())\n                .toArray(Type[]::new);\n        for (TupleDescriptor descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"union query has different number of fields: %d, %d\",\n                        outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in union query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            TupleDescriptor descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {
                        "oldPath": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
                        "newPath": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                        "oldMethodName": "visitUnion",
                        "newMethodName": "visitUnion"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Merge StatementAnalyzer with TupleAnalyzer\n\nThey were distinct classes for legacy reasons, but they are really\npart of the same process.\n",
                    "commitDate": "05/11/15 11:41 AM",
                    "commitName": "b34d126482a9916c5873a6b945538e055ec4dbd7",
                    "commitAuthor": "Martin Traverso",
                    "commitDateOld": "05/11/15 11:32 AM",
                    "commitNameOld": "b75d021b62b1657cbbf2334fd664a39389c111fd",
                    "commitAuthorOld": "Nezih Yigitbasi",
                    "daysBetweenCommits": 0.01,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,58 +1,56 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, accessControl, experimentalSyntaxEnabled);\n-\n         TupleDescriptor[] descriptors = node.getRelations().stream()\n-                .map(relation -> analyzer.process(relation, context).withOnlyVisibleFields())\n+                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                 .toArray(TupleDescriptor[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(field -> field.getType())\n                 .toArray(Type[]::new);\n         for (TupleDescriptor descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n-                                            node,\n-                                            \"union query has different number of fields: %d, %d\",\n-                                            outputFieldSize, descFieldSize);\n+                        node,\n+                        \"union query has different number of fields: %d, %d\",\n+                        outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n-                                                node,\n-                                                \"column %d in union query has incompatible types: %s, %s\",\n-                                                i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n+                            node,\n+                            \"column %d in union query has incompatible types: %s, %s\",\n+                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             TupleDescriptor descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleDescriptor[] descriptors = node.getRelations().stream()\n                .map(relation -> process(relation, context).withOnlyVisibleFields())\n                .toArray(TupleDescriptor[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(field -> field.getType())\n                .toArray(Type[]::new);\n        for (TupleDescriptor descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                        node,\n                        \"union query has different number of fields: %d, %d\",\n                        outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                            node,\n                            \"column %d in union query has incompatible types: %s, %s\",\n                            i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            TupleDescriptor descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
                    "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/StatementAnalyzer.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "5a12bd6475f2cb8903e65365fa917269ffc51589": {
            "type": "Ybodychange",
            "commitMessage": "Check permissions during analysis\n",
            "commitDate": "06/09/15 3:29 PM",
            "commitName": "5a12bd6475f2cb8903e65365fa917269ffc51589",
            "commitAuthor": "Dain Sundstrom",
            "commitDateOld": "02/09/15 1:38 AM",
            "commitNameOld": "462fe03920cee71c6211167aed807d268ea816a4",
            "commitAuthorOld": "Nileema Shingte",
            "daysBetweenCommits": 4.58,
            "commitsBetweenForRepo": 29,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,58 +1,58 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n+        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, accessControl, experimentalSyntaxEnabled);\n \n         TupleDescriptor[] descriptors = node.getRelations().stream()\n                 .map(relation -> analyzer.process(relation, context).withOnlyVisibleFields())\n                 .toArray(TupleDescriptor[]::new);\n         Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                 .map(field -> field.getType())\n                 .toArray(Type[]::new);\n         for (TupleDescriptor descriptor : descriptors) {\n             int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                             node,\n                                             \"union query has different number of fields: %d, %d\",\n                                             outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                 if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                                                 node,\n                                                 \"column %d in union query has incompatible types: %s, %s\",\n                                                 i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                 }\n                 outputFieldTypes[i] = commonSuperType.get();\n             }\n         }\n \n         Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n         TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n         for (int i = 0; i < outputFieldTypes.length; i++) {\n             Field oldField = firstDescriptor.getFieldByIndex(i);\n             outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n         }\n         TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n         analysis.setOutputDescriptor(node, outputDescriptor);\n \n         for (int i = 0; i < node.getRelations().size(); i++) {\n             Relation relation = node.getRelations().get(i);\n             TupleDescriptor descriptor = descriptors[i];\n             for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                 Type outputFieldType = outputFieldTypes[j];\n                 Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     analysis.addRelationCoercion(relation, outputFieldTypes);\n                     break;\n                 }\n             }\n         }\n \n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, accessControl, experimentalSyntaxEnabled);\n\n        TupleDescriptor[] descriptors = node.getRelations().stream()\n                .map(relation -> analyzer.process(relation, context).withOnlyVisibleFields())\n                .toArray(TupleDescriptor[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(field -> field.getType())\n                .toArray(Type[]::new);\n        for (TupleDescriptor descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                            node,\n                                            \"union query has different number of fields: %d, %d\",\n                                            outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                                                node,\n                                                \"column %d in union query has incompatible types: %s, %s\",\n                                                i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            TupleDescriptor descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "99"
        },
        "2e5b1e90439428f2226f1681fa895d97eaa9ecb2": {
            "type": "Ybodychange",
            "commitMessage": "Add coercion for union\n",
            "commitDate": "14/07/15 4:17 PM",
            "commitName": "2e5b1e90439428f2226f1681fa895d97eaa9ecb2",
            "commitAuthor": "Haozhun Jin",
            "commitDateOld": "03/06/15 7:30 PM",
            "commitNameOld": "177a812555294a9c526777ea12f73cf1a18f5929",
            "commitAuthorOld": "David Phillips",
            "daysBetweenCommits": 40.87,
            "commitsBetweenForRepo": 177,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,34 +1,58 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n \n-        // Use the first descriptor as the output descriptor for the UNION\n-        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n-\n-        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n-            TupleDescriptor descriptor = analyzer.process(relation, context).withOnlyVisibleFields();\n-            int outputFieldSize = outputDescriptor.getVisibleFields().size();\n+        TupleDescriptor[] descriptors = node.getRelations().stream()\n+                .map(relation -> analyzer.process(relation, context).withOnlyVisibleFields())\n+                .toArray(TupleDescriptor[]::new);\n+        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n+                .map(field -> field.getType())\n+                .toArray(Type[]::new);\n+        for (TupleDescriptor descriptor : descriptors) {\n+            int outputFieldSize = outputFieldTypes.length;\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                             node,\n                                             \"union query has different number of fields: %d, %d\",\n                                             outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n-                Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n-                if (!outputFieldType.equals(descFieldType)) {\n+                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n+                if (!commonSuperType.isPresent()) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                                                 node,\n                                                 \"column %d in union query has incompatible types: %s, %s\",\n-                                                i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n+                                                i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n+                }\n+                outputFieldTypes[i] = commonSuperType.get();\n+            }\n+        }\n+\n+        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n+        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n+        for (int i = 0; i < outputFieldTypes.length; i++) {\n+            Field oldField = firstDescriptor.getFieldByIndex(i);\n+            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n+        }\n+        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n+        analysis.setOutputDescriptor(node, outputDescriptor);\n+\n+        for (int i = 0; i < node.getRelations().size(); i++) {\n+            Relation relation = node.getRelations().get(i);\n+            TupleDescriptor descriptor = descriptors[i];\n+            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n+                Type outputFieldType = outputFieldTypes[j];\n+                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n+                if (!outputFieldType.equals(descFieldType)) {\n+                    analysis.addRelationCoercion(relation, outputFieldTypes);\n+                    break;\n                 }\n             }\n         }\n \n-        analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n\n        TupleDescriptor[] descriptors = node.getRelations().stream()\n                .map(relation -> analyzer.process(relation, context).withOnlyVisibleFields())\n                .toArray(TupleDescriptor[]::new);\n        Type[] outputFieldTypes = descriptors[0].getVisibleFields().stream()\n                .map(field -> field.getType())\n                .toArray(Type[]::new);\n        for (TupleDescriptor descriptor : descriptors) {\n            int outputFieldSize = outputFieldTypes.length;\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                            node,\n                                            \"union query has different number of fields: %d, %d\",\n                                            outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                Optional<Type> commonSuperType = FunctionRegistry.getCommonSuperType(outputFieldTypes[i], descFieldType);\n                if (!commonSuperType.isPresent()) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                                                node,\n                                                \"column %d in union query has incompatible types: %s, %s\",\n                                                i, outputFieldTypes[i].getDisplayName(), descFieldType.getDisplayName());\n                }\n                outputFieldTypes[i] = commonSuperType.get();\n            }\n        }\n\n        Field[] outputDescriptorFields = new Field[outputFieldTypes.length];\n        TupleDescriptor firstDescriptor = descriptors[0].withOnlyVisibleFields();\n        for (int i = 0; i < outputFieldTypes.length; i++) {\n            Field oldField = firstDescriptor.getFieldByIndex(i);\n            outputDescriptorFields[i] = new Field(oldField.getRelationAlias(), oldField.getName(), outputFieldTypes[i], oldField.isHidden());\n        }\n        TupleDescriptor outputDescriptor = new TupleDescriptor(outputDescriptorFields);\n        analysis.setOutputDescriptor(node, outputDescriptor);\n\n        for (int i = 0; i < node.getRelations().size(); i++) {\n            Relation relation = node.getRelations().get(i);\n            TupleDescriptor descriptor = descriptors[i];\n            for (int j = 0; j < descriptor.getVisibleFields().size(); j++) {\n                Type outputFieldType = outputFieldTypes[j];\n                Type descFieldType = descriptor.getFieldByIndex(j).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    analysis.addRelationCoercion(relation, outputFieldTypes);\n                    break;\n                }\n            }\n        }\n\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "522d0562405e990608c07dc848392dcd49e11a70": {
            "type": "Ybodychange",
            "commitMessage": "Fix analyzing UNION queries with hidden columns\n",
            "commitDate": "08/04/15 2:17 PM",
            "commitName": "522d0562405e990608c07dc848392dcd49e11a70",
            "commitAuthor": "David Phillips",
            "commitDateOld": "30/03/15 3:46 PM",
            "commitNameOld": "8f5c833f64a1c8d91796dc92779cecc02e8f2d4e",
            "commitAuthorOld": "Christopher Berner",
            "daysBetweenCommits": 8.94,
            "commitsBetweenForRepo": 71,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,34 +1,34 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n-            TupleDescriptor descriptor = analyzer.process(relation, context);\n+            TupleDescriptor descriptor = analyzer.process(relation, context).withOnlyVisibleFields();\n             int outputFieldSize = outputDescriptor.getVisibleFields().size();\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                             node,\n                                             \"union query has different number of fields: %d, %d\",\n                                             outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                 if (!outputFieldType.equals(descFieldType)) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                                                 node,\n                                                 \"column %d in union query has incompatible types: %s, %s\",\n                                                 i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n                 }\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context).withOnlyVisibleFields();\n            int outputFieldSize = outputDescriptor.getVisibleFields().size();\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                            node,\n                                            \"union query has different number of fields: %d, %d\",\n                                            outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                                                node,\n                                                \"column %d in union query has incompatible types: %s, %s\",\n                                                i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n                }\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "1b8a149be5f72edc0a892f65b25676c66acbd0dc": {
            "type": "Ybodychange",
            "commitMessage": "Fix comparison of types in analysis of UNION\n",
            "commitDate": "17/12/14 5:36 PM",
            "commitName": "1b8a149be5f72edc0a892f65b25676c66acbd0dc",
            "commitAuthor": "Christopher Berner",
            "commitDateOld": "12/12/14 4:11 PM",
            "commitNameOld": "b0ca36e43095c3700e8db245a8098de25387205e",
            "commitAuthorOld": "David Phillips",
            "daysBetweenCommits": 5.06,
            "commitsBetweenForRepo": 20,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,34 +1,34 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n             int outputFieldSize = outputDescriptor.getVisibleFields().size();\n             int descFieldSize = descriptor.getVisibleFields().size();\n             if (outputFieldSize != descFieldSize) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                             node,\n                                             \"union query has different number of fields: %d, %d\",\n                                             outputFieldSize, descFieldSize);\n             }\n             for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                 Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n                 Type descFieldType = descriptor.getFieldByIndex(i).getType();\n-                if (outputFieldType != descFieldType) {\n+                if (!outputFieldType.equals(descFieldType)) {\n                     throw new SemanticException(TYPE_MISMATCH,\n                                                 node,\n                                                 \"column %d in union query has incompatible types: %s, %s\",\n                                                 i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n                 }\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            int outputFieldSize = outputDescriptor.getVisibleFields().size();\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                            node,\n                                            \"union query has different number of fields: %d, %d\",\n                                            outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                if (!outputFieldType.equals(descFieldType)) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                                                node,\n                                                \"column %d in union query has incompatible types: %s, %s\",\n                                                i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n                }\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "df99f33ab82b20f6afc362c7eb1d165b30ef8441": {
            "type": "Ybodychange",
            "commitMessage": "Improve error message when types don't match in UNION query\n",
            "commitDate": "26/11/14 7:04 PM",
            "commitName": "df99f33ab82b20f6afc362c7eb1d165b30ef8441",
            "commitAuthor": "Zhenxiao Luo",
            "commitDateOld": "21/11/14 2:46 PM",
            "commitNameOld": "dd5f74ec7322f2e27007289b05a76fb23feadc82",
            "commitAuthorOld": "Martin Traverso",
            "daysBetweenCommits": 5.18,
            "commitsBetweenForRepo": 12,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,19 +1,34 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n-            if (!elementsEqual(transform(outputDescriptor.getVisibleFields(), typeGetter()), transform(descriptor.getVisibleFields(), typeGetter()))) {\n-                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n+            int outputFieldSize = outputDescriptor.getVisibleFields().size();\n+            int descFieldSize = descriptor.getVisibleFields().size();\n+            if (outputFieldSize != descFieldSize) {\n+                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n+                                            node,\n+                                            \"union query has different number of fields: %d, %d\",\n+                                            outputFieldSize, descFieldSize);\n+            }\n+            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n+                Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n+                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n+                if (outputFieldType != descFieldType) {\n+                    throw new SemanticException(TYPE_MISMATCH,\n+                                                node,\n+                                                \"column %d in union query has incompatible types: %s, %s\",\n+                                                i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n+                }\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            int outputFieldSize = outputDescriptor.getVisibleFields().size();\n            int descFieldSize = descriptor.getVisibleFields().size();\n            if (outputFieldSize != descFieldSize) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES,\n                                            node,\n                                            \"union query has different number of fields: %d, %d\",\n                                            outputFieldSize, descFieldSize);\n            }\n            for (int i = 0; i < descriptor.getVisibleFields().size(); i++) {\n                Type outputFieldType = outputDescriptor.getFieldByIndex(i).getType();\n                Type descFieldType = descriptor.getFieldByIndex(i).getType();\n                if (outputFieldType != descFieldType) {\n                    throw new SemanticException(TYPE_MISMATCH,\n                                                node,\n                                                \"column %d in union query has incompatible types: %s, %s\",\n                                                i, outputFieldType.getDisplayName(), descFieldType.getDisplayName());\n                }\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "58857ce6e2e01b10d64e37f3639f3d49fa13ef32": {
            "type": "Ybodychange",
            "commitMessage": "Change SqlParser to not be static\n",
            "commitDate": "27/06/14 12:19 AM",
            "commitName": "58857ce6e2e01b10d64e37f3639f3d49fa13ef32",
            "commitAuthor": "Dain Sundstrom",
            "commitDateOld": "11/06/14 4:57 PM",
            "commitNameOld": "df459ba9c103655ecc3323efbf8cafb5fe61a8d6",
            "commitAuthorOld": "David Phillips",
            "daysBetweenCommits": 15.31,
            "commitsBetweenForRepo": 103,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,19 +1,19 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, experimentalSyntaxEnabled);\n+        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n             if (!elementsEqual(transform(outputDescriptor.getVisibleFields(), typeGetter()), transform(descriptor.getVisibleFields(), typeGetter()))) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, sqlParser, experimentalSyntaxEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (!elementsEqual(transform(outputDescriptor.getVisibleFields(), typeGetter()), transform(descriptor.getVisibleFields(), typeGetter()))) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "38"
        },
        "af13d0c5d1b202db1d84ea9ef3f86d747792a75d": {
            "type": "Ybodychange",
            "commitMessage": "Add support for hidden columns\n",
            "commitDate": "28/05/14 2:20 PM",
            "commitName": "af13d0c5d1b202db1d84ea9ef3f86d747792a75d",
            "commitAuthor": "Dain Sundstrom",
            "commitDateOld": "28/05/14 2:20 PM",
            "commitNameOld": "1b072f8610f80b6084c72b8fe9a6dfe45c176c32",
            "commitAuthorOld": "Dain Sundstrom",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,19 +1,19 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, experimentalSyntaxEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n-        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n+        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n-            if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n+            if (!elementsEqual(transform(outputDescriptor.getVisibleFields(), typeGetter()), transform(descriptor.getVisibleFields(), typeGetter()))) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, experimentalSyntaxEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context).withOnlyVisibleFields();\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (!elementsEqual(transform(outputDescriptor.getVisibleFields(), typeGetter()), transform(descriptor.getVisibleFields(), typeGetter()))) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "37"
        },
        "a3d9589ecccc70579d884bc5fecaf882bc1c2ec9": {
            "type": "Ybodychange",
            "commitMessage": "Rename analyzer.approximate-queries-enabled\n\nChange name of config flag to analyzer.experimental-syntax-enabled,\nsince it's used to gate more than just approximate queries (rescaled\nsampling)\n",
            "commitDate": "25/02/14 3:32 PM",
            "commitName": "a3d9589ecccc70579d884bc5fecaf882bc1c2ec9",
            "commitAuthor": "Christopher Berner",
            "commitDateOld": "25/02/14 11:30 AM",
            "commitNameOld": "4c42dc0bcb7f701e29eeb9225c59860ac74b5c33",
            "commitAuthorOld": "Christopher Berner",
            "daysBetweenCommits": 0.17,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,19 +1,19 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, approximateQueriesEnabled);\n+        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, experimentalSyntaxEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n             if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, experimentalSyntaxEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "20"
        },
        "e4e86cbad97486d8d83090e90333f2ad90956f5b": {
            "type": "Ybodychange",
            "commitMessage": "Experimental support for approximate queries\n\nCurrently only AVG is supported. The syntax is:\nSELECT AVG(a)\nFROM my_sampled_table\nAPPROXIMATE AT 95.0 CONFIDENCE\n\nThis is disabled by default, but can be enabled with the config option analyzer.approximate-queries-enabled=true\n",
            "commitDate": "07/02/14 10:39 PM",
            "commitName": "e4e86cbad97486d8d83090e90333f2ad90956f5b",
            "commitAuthor": "Christopher Berner",
            "commitDateOld": "16/01/14 7:08 PM",
            "commitNameOld": "1703a05a2c6861d95b5b8116b48e6a4c04f48dcf",
            "commitAuthorOld": "David Phillips",
            "daysBetweenCommits": 22.15,
            "commitsBetweenForRepo": 72,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,19 +1,19 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         checkState(node.getRelations().size() >= 2);\n \n-        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n+        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, approximateQueriesEnabled);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n             if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata, approximateQueriesEnabled);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "49"
        },
        "8c5fccbdf8b6b552dc8a1a1eca8abde67ad273ed": {
            "type": "Ybodychange",
            "commitMessage": "Support cross joins\n",
            "commitDate": "23/12/13 1:50 PM",
            "commitName": "8c5fccbdf8b6b552dc8a1a1eca8abde67ad273ed",
            "commitAuthor": "Nileema Shingte",
            "commitDateOld": "17/12/13 2:21 PM",
            "commitNameOld": "a58ef2b042ce049ff376fe904ccb8b15b90880d1",
            "commitAuthorOld": "Christopher Berner",
            "daysBetweenCommits": 5.98,
            "commitsBetweenForRepo": 34,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,19 +1,19 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n-        Preconditions.checkState(node.getRelations().size() >= 2);\n+        checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n \n         // Use the first descriptor as the output descriptor for the UNION\n         TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n \n         for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n             if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                 throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "8"
        },
        "4ec3ca7a2254e34c3fbd9ee41dc3f327c67a5a9f": {
            "type": "Ybodychange",
            "commitMessage": "Fix comments for pull #574\n",
            "commitDate": "24/05/13 5:05 PM",
            "commitName": "4ec3ca7a2254e34c3fbd9ee41dc3f327c67a5a9f",
            "commitAuthor": "Eric Hwang",
            "commitDateOld": "24/05/13 5:05 PM",
            "commitNameOld": "bc2cc2e215c7aabb5f78a7be55b562b229f1ce07",
            "commitAuthorOld": "Eric Hwang",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 7,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,23 +1,19 @@\n     protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n     {\n         Preconditions.checkState(node.getRelations().size() >= 2);\n \n         TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n \n-        TupleDescriptor outputDescriptor = null;\n-        for (Relation relation : node.getRelations()) {\n+        // Use the first descriptor as the output descriptor for the UNION\n+        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n+\n+        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n             TupleDescriptor descriptor = analyzer.process(relation, context);\n-            if (outputDescriptor == null) {\n-                // Use the first descriptor as the output descriptor for the UNION\n-                outputDescriptor = descriptor;\n-            }\n-            else {\n-                if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n-                    throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n-                }\n+            if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n+                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n             }\n         }\n \n         analysis.setOutputDescriptor(node, outputDescriptor);\n         return outputDescriptor;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        Preconditions.checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n\n        // Use the first descriptor as the output descriptor for the UNION\n        TupleDescriptor outputDescriptor = analyzer.process(node.getRelations().get(0), context);\n\n        for (Relation relation : Iterables.skip(node.getRelations(), 1)) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "13"
        },
        "bc2cc2e215c7aabb5f78a7be55b562b229f1ce07": {
            "type": "Yintroduced",
            "commitMessage": "Add UNION [ALL] to distributed execution planning\n",
            "commitDate": "24/05/13 5:05 PM",
            "commitName": "bc2cc2e215c7aabb5f78a7be55b562b229f1ce07",
            "commitAuthor": "Eric Hwang",
            "diff": "@@ -0,0 +1,23 @@\n+    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n+    {\n+        Preconditions.checkState(node.getRelations().size() >= 2);\n+\n+        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n+\n+        TupleDescriptor outputDescriptor = null;\n+        for (Relation relation : node.getRelations()) {\n+            TupleDescriptor descriptor = analyzer.process(relation, context);\n+            if (outputDescriptor == null) {\n+                // Use the first descriptor as the output descriptor for the UNION\n+                outputDescriptor = descriptor;\n+            }\n+            else {\n+                if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n+                    throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n+                }\n+            }\n+        }\n+\n+        analysis.setOutputDescriptor(node, outputDescriptor);\n+        return outputDescriptor;\n+    }\n\\ No newline at end of file\n",
            "actualSource": "    protected TupleDescriptor visitUnion(Union node, AnalysisContext context)\n    {\n        Preconditions.checkState(node.getRelations().size() >= 2);\n\n        TupleAnalyzer analyzer = new TupleAnalyzer(analysis, session, metadata);\n\n        TupleDescriptor outputDescriptor = null;\n        for (Relation relation : node.getRelations()) {\n            TupleDescriptor descriptor = analyzer.process(relation, context);\n            if (outputDescriptor == null) {\n                // Use the first descriptor as the output descriptor for the UNION\n                outputDescriptor = descriptor;\n            }\n            else {\n                if (!elementsEqual(transform(outputDescriptor.getFields(), typeGetter()), transform(descriptor.getFields(), typeGetter()))) {\n                    throw new SemanticException(MISMATCHED_SET_COLUMN_TYPES, node, \"Union query terms have mismatched columns\");\n                }\n            }\n        }\n\n        analysis.setOutputDescriptor(node, outputDescriptor);\n        return outputDescriptor;\n    }",
            "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/TupleAnalyzer.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "21964.json"
}