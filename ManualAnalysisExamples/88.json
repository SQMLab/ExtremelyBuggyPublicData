{
    "origin": "codeshovel",
    "repositoryName": "tomcat",
    "repositoryPath": "/home/student/mortonss/research/better_bug_research/github_repos/tomcat/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "StandardWrapperValve.java",
    "functionName": "invoke",
    "functionId": "invoke___request-Request__response-Response",
    "sourceFilePath": "java/org/apache/catalina/core/StandardWrapperValve.java",
    "functionStartLine": 86,
    "functionEndLine": 263,
    "numCommitsSeen": 75,
    "timeTaken": 12094,
    "changeHistory": [
        "a84fabcbc6fee8a69253ad92a304b4718e96a7c9",
        "4d47722dda0aa131d8707efe0d3d9352fc2fa04e",
        "8ba833433e36483b8c90a239ee94826c168fd93e",
        "22c47be25fe7abd6f712b819e2f8416f873e07b1",
        "c3d2ce46de54d41f084210f60f9e80a57841ae43",
        "e9f1b47642d26a3cee5a520cc2dfbcbf427fdab1",
        "1bb905c8cfd9287a366e495be7c11b2b1aca5497",
        "2732fb76bebdc4bc6cfe59e5a3e9dbad8cdea5da",
        "cc3afb2c7db1d18c0328dcb4b12cdc6127397ee5",
        "133fd16ac360cf5b8bb1ae710e69c8b514c8b87f",
        "d94be0ddf0f4d826a11827ef5f5181f645f973fb",
        "27e9802b664669c7a0f37b6d075e1c8a3e12453f",
        "8008f3d25e02368349ab144f5425c7f9ac2fdfd6",
        "7c21d1fd8909169effd019a0d00ce662b3e8454a",
        "e16523c2f5a201e70406d54f2d3dba77f6eedc53",
        "c4507ffb8a72219ba5d56df248ef29b13b7f4ef9",
        "ee69bc0ee6b68c5ad89dc068a7ff304fae808633",
        "16f9ca9b3528d764e7680a9606a99e40d9e650d6",
        "857482be4b2074a4ab68810266ba796c3db3852e",
        "029af406026b1380f553ade9f540edb3326741db",
        "6dffc54a0d99c1482cb8e28edf2bb2d811e0d426",
        "f819212d99ac4b3659fef5a2c762271218bada41",
        "560cd00890b3f6af2aca0c3a9d51a45f880692dd",
        "321173bce4a5785875d942d8dd07eeb2ae22de12",
        "300e8ceb97d40a2f1571f1312ba67d9b2bce20ae",
        "d4608002d6b176cd02ee5ce1330fcd7a6d40c072",
        "376a308dbb1742f9fc88e693fb8100c44a8d7cf6",
        "61c2757a882ac9fd2fe5ddfa73faa0c8bdeda924",
        "07304aa93289d9f7328444c6d2e241a9607b21f3",
        "6c995cd2856ea5f129763e5f6393158a5fb705c6",
        "b891b869613ef8dd9248bbdfcaafb16597d666bf",
        "50e950765d6309fa1266dc8ff1c77d9db67d2758",
        "2207733b82d85e354fa1a6fd114dae665816fdf9",
        "f562edd3302866f34c0ca9fa97f6ff414450f1ae",
        "a6cda982a6e7068ee7e824d40b8e23152202b1cf",
        "d3b4844d07b76fdf8cd2ff7d28a6f6fe21ea0596",
        "513a158ee793b52cc1c0fac7780423760818b631",
        "523f9353cf849932dcba8f26cbfa9e886b87cad5",
        "e329ceb5c7aa51c33f036b375e88d7e35cc50706",
        "b3b1cd21c878d7528e38a3c58a77dc36fbc3d8b7",
        "0bb2b572b42a5d2740473e04d16d6c36aa92f0c8",
        "6f181e1062a472bc5f0234980f66cbde42c1041b",
        "c2b60ded7b961aa30201c32a11a9e7c4ee632302",
        "84afcbf511de37a063784443e0dc5d752d7e62fe",
        "61565f283b11a7db6636e13391ec2f6c0ae3f916"
    ],
    "changeHistoryShort": {
        "61565f283b11a7db6636e13391ec2f6c0ae3f916": "Ybodychange",
        "84afcbf511de37a063784443e0dc5d752d7e62fe": "Ybodychange",
        "c2b60ded7b961aa30201c32a11a9e7c4ee632302": "Ybodychange",
        "6f181e1062a472bc5f0234980f66cbde42c1041b": "Ybodychange",
        "0bb2b572b42a5d2740473e04d16d6c36aa92f0c8": "Ybodychange",
        "b3b1cd21c878d7528e38a3c58a77dc36fbc3d8b7": "Ymodifierchange",
        "e329ceb5c7aa51c33f036b375e88d7e35cc50706": "Ybodychange",
        "523f9353cf849932dcba8f26cbfa9e886b87cad5": "Ybodychange",
        "513a158ee793b52cc1c0fac7780423760818b631": "Ybodychange",
        "d3b4844d07b76fdf8cd2ff7d28a6f6fe21ea0596": "Ybodychange",
        "a6cda982a6e7068ee7e824d40b8e23152202b1cf": "Ybodychange",
        "f562edd3302866f34c0ca9fa97f6ff414450f1ae": "Ybodychange",
        "2207733b82d85e354fa1a6fd114dae665816fdf9": "Ybodychange",
        "50e950765d6309fa1266dc8ff1c77d9db67d2758": "Ybodychange",
        "b891b869613ef8dd9248bbdfcaafb16597d666bf": "Ybodychange",
        "6c995cd2856ea5f129763e5f6393158a5fb705c6": "Ybodychange",
        "07304aa93289d9f7328444c6d2e241a9607b21f3": "Ybodychange",
        "61c2757a882ac9fd2fe5ddfa73faa0c8bdeda924": "Ybodychange",
        "376a308dbb1742f9fc88e693fb8100c44a8d7cf6": "Ybodychange",
        "d4608002d6b176cd02ee5ce1330fcd7a6d40c072": "Ybodychange",
        "300e8ceb97d40a2f1571f1312ba67d9b2bce20ae": "Ybodychange",
        "321173bce4a5785875d942d8dd07eeb2ae22de12": "Ybodychange",
        "560cd00890b3f6af2aca0c3a9d51a45f880692dd": "Ybodychange",
        "f819212d99ac4b3659fef5a2c762271218bada41": "Ybodychange",
        "6dffc54a0d99c1482cb8e28edf2bb2d811e0d426": "Ybodychange",
        "029af406026b1380f553ade9f540edb3326741db": "Ybodychange",
        "857482be4b2074a4ab68810266ba796c3db3852e": "Ybodychange",
        "16f9ca9b3528d764e7680a9606a99e40d9e650d6": "Ybodychange",
        "ee69bc0ee6b68c5ad89dc068a7ff304fae808633": "Ybodychange",
        "c4507ffb8a72219ba5d56df248ef29b13b7f4ef9": "Ybodychange",
        "e16523c2f5a201e70406d54f2d3dba77f6eedc53": "Ybodychange",
        "7c21d1fd8909169effd019a0d00ce662b3e8454a": "Ybodychange",
        "8008f3d25e02368349ab144f5425c7f9ac2fdfd6": "Ybodychange",
        "27e9802b664669c7a0f37b6d075e1c8a3e12453f": "Ybodychange",
        "d94be0ddf0f4d826a11827ef5f5181f645f973fb": "Ybodychange",
        "133fd16ac360cf5b8bb1ae710e69c8b514c8b87f": "Ybodychange",
        "cc3afb2c7db1d18c0328dcb4b12cdc6127397ee5": "Ybodychange",
        "2732fb76bebdc4bc6cfe59e5a3e9dbad8cdea5da": "Ybodychange",
        "1bb905c8cfd9287a366e495be7c11b2b1aca5497": "Ybodychange",
        "e9f1b47642d26a3cee5a520cc2dfbcbf427fdab1": "Ybodychange",
        "c3d2ce46de54d41f084210f60f9e80a57841ae43": "Ybodychange",
        "22c47be25fe7abd6f712b819e2f8416f873e07b1": "Ybodychange",
        "8ba833433e36483b8c90a239ee94826c168fd93e": "Ybodychange",
        "4d47722dda0aa131d8707efe0d3d9352fc2fa04e": "Ybodychange",
        "a84fabcbc6fee8a69253ad92a304b4718e96a7c9": "Yintroduced"
    },
    "changeHistoryDetails": {
        "61565f283b11a7db6636e13391ec2f6c0ae3f916": {
            "type": "Ybodychange",
            "commitMessage": "Code cleanup, no functional change",
            "commitDate": "13/03/25 5:42 AM",
            "commitName": "61565f283b11a7db6636e13391ec2f6c0ae3f916",
            "commitAuthor": "remm",
            "commitDateOld": "08/11/23 2:29 PM",
            "commitNameOld": "66df5fd7548aac7ea3e80a75cb1b2cd2a3bda708",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 490.59,
            "commitsBetweenForRepo": 1406,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,178 +1,178 @@\n     public void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n         requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n-            servlet = null;\n+            // servlet = null; is set here\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n-                        if (log != null && log.length() > 0) {\n+                        if (log != null && !log.isEmpty()) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (BadRequestException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e, HttpServletResponse.SC_BAD_REQUEST);\n         } catch (CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof BadRequestException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (InvalidParameterException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e, e.getErrorCode());\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n             processingTime.add(time);\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            // servlet = null; is set here\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && !log.isEmpty()) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (BadRequestException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e, HttpServletResponse.SC_BAD_REQUEST);\n        } catch (CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof BadRequestException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (InvalidParameterException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e, e.getErrorCode());\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime.add(time);\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "84afcbf511de37a063784443e0dc5d752d7e62fe": {
            "type": "Ybodychange",
            "commitMessage": "Use a 400 response for bad requests rather than a 500 response",
            "commitDate": "08/11/23 9:09 AM",
            "commitName": "84afcbf511de37a063784443e0dc5d752d7e62fe",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "08/11/23 8:59 AM",
            "commitNameOld": "c2b60ded7b961aa30201c32a11a9e7c4ee632302",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,171 +1,178 @@\n     public void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n         requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n-        } catch (BadRequestException | CloseNowException e) {\n+        } catch (BadRequestException e) {\n+            if (container.getLogger().isDebugEnabled()) {\n+                container.getLogger().debug(\n+                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n+            }\n+            throwable = e;\n+            exception(request, response, e, HttpServletResponse.SC_BAD_REQUEST);\n+        } catch (CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof BadRequestException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (InvalidParameterException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e, e.getErrorCode());\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n             processingTime.add(time);\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (BadRequestException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e, HttpServletResponse.SC_BAD_REQUEST);\n        } catch (CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof BadRequestException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (InvalidParameterException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e, e.getErrorCode());\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime.add(time);\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "c2b60ded7b961aa30201c32a11a9e7c4ee632302": {
            "type": "Ybodychange",
            "commitMessage": "Differentiate request cancellation from a bad request\n\nIntroduce BadRequestException as a sub-class of IOException and the\nsuper class of ClientAbortException. This allows Tomcat to differentiate\nbetween an invalid request (e.g. invalid HTTP headers) and a request\nthat the user cancelled before it completed.",
            "commitDate": "08/11/23 8:59 AM",
            "commitName": "c2b60ded7b961aa30201c32a11a9e7c4ee632302",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "22/08/23 1:13 PM",
            "commitNameOld": "6f181e1062a472bc5f0234980f66cbde42c1041b",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 77.87,
            "commitsBetweenForRepo": 302,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,171 +1,171 @@\n     public void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n         requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n-        } catch (ClientAbortException | CloseNowException e) {\n+        } catch (BadRequestException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n-            if (!(rootCause instanceof ClientAbortException)) {\n+            if (!(rootCause instanceof BadRequestException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (InvalidParameterException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e, e.getErrorCode());\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n             processingTime.add(time);\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (BadRequestException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof BadRequestException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (InvalidParameterException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e, e.getErrorCode());\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime.add(time);\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "6f181e1062a472bc5f0234980f66cbde42c1041b": {
            "type": "Ybodychange",
            "commitMessage": "Implement parameter error handling changes\n",
            "commitDate": "22/08/23 1:13 PM",
            "commitName": "6f181e1062a472bc5f0234980f66cbde42c1041b",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "14/08/23 11:48 AM",
            "commitNameOld": "0bb2b572b42a5d2740473e04d16d6c36aa92f0c8",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 8.06,
            "commitsBetweenForRepo": 10,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,164 +1,171 @@\n     public void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n         requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n+        } catch (InvalidParameterException e) {\n+            if (container.getLogger().isDebugEnabled()) {\n+                container.getLogger().debug(\n+                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n+            }\n+            throwable = e;\n+            exception(request, response, e, e.getErrorCode());\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n             processingTime.add(time);\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (InvalidParameterException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e, e.getErrorCode());\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime.add(time);\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "0bb2b572b42a5d2740473e04d16d6c36aa92f0c8": {
            "type": "Ybodychange",
            "commitMessage": "Use LongAdder for processing time - prompted by Coverity scan report",
            "commitDate": "14/08/23 11:48 AM",
            "commitName": "0bb2b572b42a5d2740473e04d16d6c36aa92f0c8",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "14/02/23 11:25 AM",
            "commitNameOld": "b3b1cd21c878d7528e38a3c58a77dc36fbc3d8b7",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 180.97,
            "commitsBetweenForRepo": 548,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,164 +1,164 @@\n     public void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n         requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n-            processingTime += time;\n+            processingTime.add(time);\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime.add(time);\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "b3b1cd21c878d7528e38a3c58a77dc36fbc3d8b7": {
            "type": "Ymodifierchange",
            "commitMessage": "Remove redundant modifiers\n\nIdentified by CheckStyle\n~80% fixed automatically by Eclipse\n~20% reviewed manually\n\nBased on PR #578 by Dimitrios Soumis",
            "commitDate": "14/02/23 11:25 AM",
            "commitName": "b3b1cd21c878d7528e38a3c58a77dc36fbc3d8b7",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "24/01/23 7:22 AM",
            "commitNameOld": "e329ceb5c7aa51c33f036b375e88d7e35cc50706",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 21.17,
            "commitsBetweenForRepo": 57,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,164 +1,164 @@\n-    public final void invoke(Request request, Response response) throws IOException, ServletException {\n+    public void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n         requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n             processingTime += time;\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime += time;\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {
                "oldValue": "[public, final]",
                "newValue": "[public]"
            }
        },
        "e329ceb5c7aa51c33f036b375e88d7e35cc50706": {
            "type": "Ybodychange",
            "commitMessage": "Switch to using LongAddr to track request/error count for servlets",
            "commitDate": "24/01/23 7:22 AM",
            "commitName": "e329ceb5c7aa51c33f036b375e88d7e35cc50706",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "24/01/23 7:06 AM",
            "commitNameOld": "40fcd5345826c51fd8272e4a90fdcf10c6547b18",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,164 +1,164 @@\n     public final void invoke(Request request, Response response) throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1 = System.currentTimeMillis();\n-        requestCount.incrementAndGet();\n+        requestCount.increment();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                     sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n             checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                     StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType() == DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(), response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter(request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(\n                         sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             wrapper.unavailable(e);\n             checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                         context.getName(), e.getMessage()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger()\n                     .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2 = System.currentTimeMillis();\n \n             long time = t2 - t1;\n             processingTime += time;\n             if (time > maxTime) {\n                 maxTime = time;\n             }\n             if (time < minTime) {\n                 minTime = time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response) throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1 = System.currentTimeMillis();\n        requestCount.increment();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                    sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\", wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()),\n                    StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\", wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType() == DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR, dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR, requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain = ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(), response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter(request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(\n                        sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceExceptionRoot\", wrapper.getName(),\n                        context.getName(), e.getMessage()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger()\n                    .error(sm.getString(\"standardWrapper.serviceException\", wrapper.getName(), context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) && (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\", wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2 = System.currentTimeMillis();\n\n            long time = t2 - t1;\n            processingTime += time;\n            if (time > maxTime) {\n                maxTime = time;\n            }\n            if (time < minTime) {\n                minTime = time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "523f9353cf849932dcba8f26cbfa9e886b87cad5": {
            "type": "Ybodychange",
            "commitMessage": "Refactor. Reduce duplicate code. No functional change.\n",
            "commitDate": "31/10/22 2:43 AM",
            "commitName": "523f9353cf849932dcba8f26cbfa9e886b87cad5",
            "commitAuthor": "lihan",
            "commitDateOld": "22/09/21 5:24 AM",
            "commitNameOld": "8dc018ffe0cdc8c7352a41dd24ddb5d072c3a6df",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 403.89,
            "commitsBetweenForRepo": 955,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,214 +1,182 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n-            long available = wrapper.getAvailable();\n-            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n-                response.setDateHeader(\"Retry-After\", available);\n-                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n-                        sm.getString(\"standardWrapper.isUnavailable\",\n-                                wrapper.getName()));\n-            } else if (available == Long.MAX_VALUE) {\n-                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n-                        sm.getString(\"standardWrapper.notFound\",\n-                                wrapper.getName()));\n-            }\n+            checkWrapperAvailable(response, wrapper);\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n-            long available = wrapper.getAvailable();\n-            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n-                response.setDateHeader(\"Retry-After\", available);\n-                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n-                           sm.getString(\"standardWrapper.isUnavailable\",\n-                                        wrapper.getName()));\n-            } else if (available == Long.MAX_VALUE) {\n-                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n-                           sm.getString(\"standardWrapper.notFound\",\n-                                        wrapper.getName()));\n-            }\n+            checkWrapperAvailable(response, wrapper);\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) {\n             dispatcherType = DispatcherType.ASYNC;\n         }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(sm.getString(\n                         \"standardWrapper.serviceException\", wrapper.getName(),\n                         context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n-            //            throwable = e;\n-            //            exception(request, response, e);\n             wrapper.unavailable(e);\n-            long available = wrapper.getAvailable();\n-            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n-                response.setDateHeader(\"Retry-After\", available);\n-                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n-                           sm.getString(\"standardWrapper.isUnavailable\",\n-                                        wrapper.getName()));\n-            } else if (available == Long.MAX_VALUE) {\n-                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n-                            sm.getString(\"standardWrapper.notFound\",\n-                                        wrapper.getName()));\n-            }\n+            checkWrapperAvailable(response, wrapper);\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                  wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) &&\n                     (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                  wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2=System.currentTimeMillis();\n \n             long time=t2-t1;\n             processingTime += time;\n             if( time > maxTime) {\n                 maxTime=time;\n             }\n             if( time < minTime) {\n                 minTime=time;\n             }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            checkWrapperAvailable(response, wrapper);\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            checkWrapperAvailable(response, wrapper);\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            wrapper.unavailable(e);\n            checkWrapperAvailable(response, wrapper);\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) &&\n                    (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2=System.currentTimeMillis();\n\n            long time=t2-t1;\n            processingTime += time;\n            if( time > maxTime) {\n                maxTime=time;\n            }\n            if( time < minTime) {\n                minTime=time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "513a158ee793b52cc1c0fac7780423760818b631": {
            "type": "Ybodychange",
            "commitMessage": "Code clean-up. Add braces for clarity.",
            "commitDate": "25/05/21 3:15 AM",
            "commitName": "513a158ee793b52cc1c0fac7780423760818b631",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "13/01/20 5:04 AM",
            "commitNameOld": "ab35110801998e4f2fa74c62263b0f8030f021d4",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 497.88,
            "commitsBetweenForRepo": 1490,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,208 +1,214 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n-        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n+        if (request.getDispatcherType()==DispatcherType.ASYNC) {\n+            dispatcherType = DispatcherType.ASYNC;\n+        }\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(sm.getString(\n                         \"standardWrapper.serviceException\", wrapper.getName(),\n                         context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                  wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) &&\n                     (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                  wrapper.getName()), e);\n                 if (throwable == null) {\n                     exception(request, response, e);\n                 }\n             }\n             long t2=System.currentTimeMillis();\n \n             long time=t2-t1;\n             processingTime += time;\n-            if( time > maxTime) maxTime=time;\n-            if( time < minTime) minTime=time;\n+            if( time > maxTime) {\n+                maxTime=time;\n+            }\n+            if( time < minTime) {\n+                minTime=time;\n+            }\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) {\n            dispatcherType = DispatcherType.ASYNC;\n        }\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) &&\n                    (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2=System.currentTimeMillis();\n\n            long time=t2-t1;\n            processingTime += time;\n            if( time > maxTime) {\n                maxTime=time;\n            }\n            if( time < minTime) {\n                minTime=time;\n            }\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "d3b4844d07b76fdf8cd2ff7d28a6f6fe21ea0596": {
            "type": "Ybodychange",
            "commitMessage": "Remove redundant method for clean",
            "commitDate": "06/11/19 7:03 AM",
            "commitName": "d3b4844d07b76fdf8cd2ff7d28a6f6fe21ea0596",
            "commitAuthor": "\u5eb7\u667a\u51ac",
            "commitDateOld": "13/05/19 2:10 PM",
            "commitNameOld": "a6cda982a6e7068ee7e824d40b8e23152202b1cf",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 176.75,
            "commitsBetweenForRepo": 573,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,209 +1,208 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(sm.getString(\n                         \"standardWrapper.serviceException\", wrapper.getName(),\n                         context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } finally {\n             // Release the filter chain (if any) for this request\n             if (filterChain != null) {\n                 filterChain.release();\n             }\n \n             // Deallocate the allocated servlet instance\n             try {\n                 if (servlet != null) {\n                     wrapper.deallocate(servlet);\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                  wrapper.getName()), e);\n                 if (throwable == null) {\n                     throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n \n             // If this servlet has been marked permanently unavailable,\n             // unload it and release this instance\n             try {\n                 if ((servlet != null) &&\n                     (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                     wrapper.unload();\n                 }\n             } catch (Throwable e) {\n                 ExceptionUtils.handleThrowable(e);\n                 container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                  wrapper.getName()), e);\n                 if (throwable == null) {\n-                    throwable = e;\n                     exception(request, response, e);\n                 }\n             }\n             long t2=System.currentTimeMillis();\n \n             long time=t2-t1;\n             processingTime += time;\n             if( time > maxTime) maxTime=time;\n             if( time < minTime) minTime=time;\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) &&\n                    (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    exception(request, response, e);\n                }\n            }\n            long t2=System.currentTimeMillis();\n\n            long time=t2-t1;\n            processingTime += time;\n            if( time > maxTime) maxTime=time;\n            if( time < minTime) minTime=time;\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "a6cda982a6e7068ee7e824d40b8e23152202b1cf": {
            "type": "Ybodychange",
            "commitMessage": "Improve clean-up after an OOME during request processing",
            "commitDate": "13/05/19 2:10 PM",
            "commitName": "a6cda982a6e7068ee7e824d40b8e23152202b1cf",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "13/05/19 2:43 AM",
            "commitNameOld": "f562edd3302866f34c0ca9fa97f6ff414450f1ae",
            "commitAuthorOld": "remm",
            "daysBetweenCommits": 0.48,
            "commitsBetweenForRepo": 12,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,210 +1,209 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(sm.getString(\n                         \"standardWrapper.serviceException\", wrapper.getName(),\n                         context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n-        }\n-\n-        // Release the filter chain (if any) for this request\n-        if (filterChain != null) {\n-            filterChain.release();\n-        }\n-\n-        // Deallocate the allocated servlet instance\n-        try {\n-            if (servlet != null) {\n-                wrapper.deallocate(servlet);\n+        } finally {\n+            // Release the filter chain (if any) for this request\n+            if (filterChain != null) {\n+                filterChain.release();\n             }\n-        } catch (Throwable e) {\n-            ExceptionUtils.handleThrowable(e);\n-            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n-                             wrapper.getName()), e);\n-            if (throwable == null) {\n-                throwable = e;\n-                exception(request, response, e);\n+\n+            // Deallocate the allocated servlet instance\n+            try {\n+                if (servlet != null) {\n+                    wrapper.deallocate(servlet);\n+                }\n+            } catch (Throwable e) {\n+                ExceptionUtils.handleThrowable(e);\n+                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n+                                 wrapper.getName()), e);\n+                if (throwable == null) {\n+                    throwable = e;\n+                    exception(request, response, e);\n+                }\n             }\n+\n+            // If this servlet has been marked permanently unavailable,\n+            // unload it and release this instance\n+            try {\n+                if ((servlet != null) &&\n+                    (wrapper.getAvailable() == Long.MAX_VALUE)) {\n+                    wrapper.unload();\n+                }\n+            } catch (Throwable e) {\n+                ExceptionUtils.handleThrowable(e);\n+                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n+                                 wrapper.getName()), e);\n+                if (throwable == null) {\n+                    throwable = e;\n+                    exception(request, response, e);\n+                }\n+            }\n+            long t2=System.currentTimeMillis();\n+\n+            long time=t2-t1;\n+            processingTime += time;\n+            if( time > maxTime) maxTime=time;\n+            if( time < minTime) minTime=time;\n         }\n-\n-        // If this servlet has been marked permanently unavailable,\n-        // unload it and release this instance\n-        try {\n-            if ((servlet != null) &&\n-                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n-                wrapper.unload();\n-            }\n-        } catch (Throwable e) {\n-            ExceptionUtils.handleThrowable(e);\n-            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n-                             wrapper.getName()), e);\n-            if (throwable == null) {\n-                throwable = e;\n-                exception(request, response, e);\n-            }\n-        }\n-        long t2=System.currentTimeMillis();\n-\n-        long time=t2-t1;\n-        processingTime += time;\n-        if( time > maxTime) maxTime=time;\n-        if( time < minTime) minTime=time;\n-\n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } finally {\n            // Release the filter chain (if any) for this request\n            if (filterChain != null) {\n                filterChain.release();\n            }\n\n            // Deallocate the allocated servlet instance\n            try {\n                if (servlet != null) {\n                    wrapper.deallocate(servlet);\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n\n            // If this servlet has been marked permanently unavailable,\n            // unload it and release this instance\n            try {\n                if ((servlet != null) &&\n                    (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                    wrapper.unload();\n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                                 wrapper.getName()), e);\n                if (throwable == null) {\n                    throwable = e;\n                    exception(request, response, e);\n                }\n            }\n            long t2=System.currentTimeMillis();\n\n            long time=t2-t1;\n            processingTime += time;\n            if( time > maxTime) maxTime=time;\n            if( time < minTime) minTime=time;\n        }\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "f562edd3302866f34c0ca9fa97f6ff414450f1ae": {
            "type": "Ybodychange",
            "commitMessage": "Avoid other cases of NPEs on stop\n\nAs found in the CI logs.",
            "commitDate": "13/05/19 2:43 AM",
            "commitName": "f562edd3302866f34c0ca9fa97f6ff414450f1ae",
            "commitAuthor": "remm",
            "commitDateOld": "01/02/19 4:28 AM",
            "commitNameOld": "2207733b82d85e354fa1a6fd114dae665816fdf9",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 100.89,
            "commitsBetweenForRepo": 441,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,209 +1,210 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n+        Container container = this.container;\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(sm.getString(\n                         \"standardWrapper.serviceException\", wrapper.getName(),\n                         context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             filterChain.release();\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        Container container = this.container;\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "2207733b82d85e354fa1a6fd114dae665816fdf9": {
            "type": "Ybodychange",
            "commitMessage": "Implement a write timeout for individual Streams\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1852699 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "01/02/19 4:28 AM",
            "commitName": "2207733b82d85e354fa1a6fd114dae665816fdf9",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "17/01/19 2:49 PM",
            "commitNameOld": "50e950765d6309fa1266dc8ff1c77d9db67d2758",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 14.57,
            "commitsBetweenForRepo": 60,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,209 +1,209 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n-        } catch (ClientAbortException e) {\n+        } catch (ClientAbortException | CloseNowException e) {\n             if (container.getLogger().isDebugEnabled()) {\n                 container.getLogger().debug(sm.getString(\n                         \"standardWrapper.serviceException\", wrapper.getName(),\n                         context.getName()), e);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             filterChain.release();\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException | CloseNowException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "50e950765d6309fa1266dc8ff1c77d9db67d2758": {
            "type": "Ybodychange",
            "commitMessage": "Add debug logging of ClientAbortExceptions\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1851582 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "17/01/19 2:49 PM",
            "commitName": "50e950765d6309fa1266dc8ff1c77d9db67d2758",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "07/04/16 11:19 AM",
            "commitNameOld": "b891b869613ef8dd9248bbdfcaafb16597d666bf",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 1015.19,
            "commitsBetweenForRepo": 3464,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,204 +1,209 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n+            if (container.getLogger().isDebugEnabled()) {\n+                container.getLogger().debug(sm.getString(\n+                        \"standardWrapper.serviceException\", wrapper.getName(),\n+                        context.getName()), e);\n+            }\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             filterChain.release();\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            if (container.getLogger().isDebugEnabled()) {\n                container.getLogger().debug(sm.getString(\n                        \"standardWrapper.serviceException\", wrapper.getName(),\n                        context.getName()), e);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "b891b869613ef8dd9248bbdfcaafb16597d666bf": {
            "type": "Ybodychange",
            "commitMessage": "Fix https://bz.apache.org/bugzilla/show_bug.cgi?id=59261\nServletRequest.getAsyncContext() now throws an IllegalStateException as required by the Servlet specification if the request is not in asynchronous mode when called.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1738149 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "07/04/16 11:19 AM",
            "commitName": "b891b869613ef8dd9248bbdfcaafb16597d666bf",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "13/09/15 11:57 AM",
            "commitNameOld": "6c995cd2856ea5f129763e5f6393158a5fb705c6",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 206.97,
            "commitsBetweenForRepo": 1343,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,204 +1,204 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterChain filterChain =\n                 ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n-                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n+                            request.getAsyncContextInternal().doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n-                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n+                        request.getAsyncContextInternal().doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             filterChain.release();\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            request.getAsyncContextInternal().doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        request.getAsyncContextInternal().doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "6c995cd2856ea5f129763e5f6393158a5fb705c6": {
            "type": "Ybodychange",
            "commitMessage": "Simplify ApplicationFilterFactory.\nIt is a utility class so use static methods rather than going via a getInstance() method.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1702795 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "13/09/15 11:57 AM",
            "commitName": "6c995cd2856ea5f129763e5f6393158a5fb705c6",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "05/12/14 5:58 PM",
            "commitNameOld": "07304aa93289d9f7328444c6d2e241a9607b21f3",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 281.71,
            "commitsBetweenForRepo": 1727,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,206 +1,204 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n-        ApplicationFilterFactory factory =\n-            ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n-            factory.createFilterChain(request, wrapper, servlet);\n+                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             filterChain.release();\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterChain filterChain =\n                ApplicationFilterFactory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "07304aa93289d9f7328444c6d2e241a9607b21f3": {
            "type": "Ybodychange",
            "commitMessage": "Revert r1643371 pending clarification from the Servlet EG re section 6.2.3 and threading requirements.\nDisable associated test.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1643474 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "05/12/14 5:58 PM",
            "commitName": "07304aa93289d9f7328444c6d2e241a9607b21f3",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "05/12/14 11:43 AM",
            "commitNameOld": "61c2757a882ac9fd2fe5ddfa73faa0c8bdeda924",
            "commitAuthorOld": "Mark Thomas",
            "daysBetweenCommits": 0.26,
            "commitsBetweenForRepo": 4,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,201 +1,206 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n+        // Release the filter chain (if any) for this request\n+        if (filterChain != null) {\n+            filterChain.release();\n+        }\n+\n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "61c2757a882ac9fd2fe5ddfa73faa0c8bdeda924": {
            "type": "Ybodychange",
            "commitMessage": "Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=57284\nEnable startAsync() to be called from a Filter and still be able to call\nthe remainder of the FilterChain\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1643371 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "05/12/14 11:43 AM",
            "commitName": "61c2757a882ac9fd2fe5ddfa73faa0c8bdeda924",
            "commitAuthor": "Mark Thomas",
            "commitDateOld": "04/11/14 5:54 AM",
            "commitNameOld": "376a308dbb1742f9fc88e693fb8100c44a8d7cf6",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 31.24,
            "commitsBetweenForRepo": 238,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,206 +1,201 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n-        // Release the filter chain (if any) for this request\n-        if (filterChain != null) {\n-            filterChain.release();\n-        }\n-\n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "376a308dbb1742f9fc88e693fb8100c44a8d7cf6": {
            "type": "Ybodychange",
            "commitMessage": "Remove Comet\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1636547 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "04/11/14 5:54 AM",
            "commitName": "376a308dbb1742f9fc88e693fb8100c44a8d7cf6",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "05/06/14 5:04 AM",
            "commitNameOld": "492a84e6254658ea210dbb9de041d229cdc34cf1",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 152.08,
            "commitsBetweenForRepo": 977,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,229 +1,206 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n-        // Identify if the request is Comet related now that the servlet has been allocated\n-        boolean comet = false;\n-        if (servlet instanceof CometProcessor && request.getAttribute(\n-                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n-            comet = true;\n-            request.setComet(true);\n-        }\n-\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n-        // Reset comet flag value after creating the filter chain\n-        request.setComet(false);\n-\n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n-                        } else if (comet) {\n-                            filterChain.doFilterEvent(request.getEvent());\n-                            request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n-                    } else if (comet) {\n-                        request.setComet(true);\n-                        filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n-            if (request.isComet()) {\n-                // If this is a Comet request, then the same chain will be used for the\n-                // processing of all subsequent events.\n-                filterChain.reuse();\n-            } else {\n-                filterChain.release();\n-            }\n+            filterChain.release();\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            filterChain.release();\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "d4608002d6b176cd02ee5ce1330fcd7a6d40c072": {
            "type": "Ybodychange",
            "commitMessage": "Remove completed TODOs\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1530172 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "08/10/13 2:19 AM",
            "commitName": "d4608002d6b176cd02ee5ce1330fcd7a6d40c072",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "27/09/12 3:20 AM",
            "commitNameOld": "300e8ceb97d40a2f1571f1312ba67d9b2bce20ae",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 375.96,
            "commitsBetweenForRepo": 2431,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,231 +1,229 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor && request.getAttribute(\n                 Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n-                            //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n-                        //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor && request.getAttribute(\n                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "300e8ceb97d40a2f1571f1312ba67d9b2bce20ae": {
            "type": "Ybodychange",
            "commitMessage": "Deprecate unnecessary code\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1390882 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "27/09/12 3:20 AM",
            "commitName": "300e8ceb97d40a2f1571f1312ba67d9b2bce20ae",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "12/08/12 12:41 PM",
            "commitNameOld": "321173bce4a5785875d942d8dd07eeb2ae22de12",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 45.61,
            "commitsBetweenForRepo": 216,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,231 +1,231 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n-        if (!context.getAvailable()) {\n+        if (!context.getState().isAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor && request.getAttribute(\n                 Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n         request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                 requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getState().isAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor && request.getAttribute(\n                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "321173bce4a5785875d942d8dd07eeb2ae22de12": {
            "type": "Ybodychange",
            "commitMessage": "Deprecate duplicated constants\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1372156 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "12/08/12 12:41 PM",
            "commitName": "321173bce4a5785875d942d8dd07eeb2ae22de12",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "12/07/12 4:10 PM",
            "commitNameOld": "560cd00890b3f6af2aca0c3a9d51a45f880692dd",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 30.86,
            "commitsBetweenForRepo": 166,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,234 +1,231 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor && request.getAttribute(\n                 Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n-        request.setAttribute\n-            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n-             dispatcherType);\n-        request.setAttribute\n-            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n-             requestPathMB);\n+        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n+        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n+                requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor && request.getAttribute(\n                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);\n        request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,\n                requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "560cd00890b3f6af2aca0c3a9d51a45f880692dd": {
            "type": "Ybodychange",
            "commitMessage": "Fix a FindBugs warning (increment of volatile not atomic)\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1360946 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "12/07/12 4:10 PM",
            "commitName": "560cd00890b3f6af2aca0c3a9d51a45f880692dd",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "12/07/12 4:06 PM",
            "commitNameOld": "08d01c4b7b1601fe767c7633aed5d4597694ab64",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,234 +1,234 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n-        requestCount++;\n+        requestCount.incrementAndGet();\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor && request.getAttribute(\n                 Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount.incrementAndGet();\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor && request.getAttribute(\n                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "f819212d99ac4b3659fef5a2c762271218bada41": {
            "type": "Ybodychange",
            "commitMessage": "Start to hook up unused constants\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1239285 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "01/02/12 1:44 PM",
            "commitName": "f819212d99ac4b3659fef5a2c762271218bada41",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "22/10/11 4:08 PM",
            "commitNameOld": "e913254c780fceaddaf278fe702fe4f658f2f1a9",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 101.94,
            "commitsBetweenForRepo": 473,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,234 +1,234 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n-        if (servlet instanceof CometProcessor\n-                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n+        if (servlet instanceof CometProcessor && request.getAttribute(\n+                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n \n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(),\n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n\n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor && request.getAttribute(\n                Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC;\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(),\n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "6dffc54a0d99c1482cb8e28edf2bb2d811e0d426": {
            "type": "Ybodychange",
            "commitMessage": "Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=51436\nSend 100 (Continue) response earlier to enable ServletRequestListener implementations to read the request body.\nBased on a patch by Simon Olofsson.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1140750 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "28/06/11 12:49 PM",
            "commitName": "6dffc54a0d99c1482cb8e28edf2bb2d811e0d426",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "10/12/10 6:28 AM",
            "commitNameOld": "4956bdbd217024d874b48e6140b788aed97784e7",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 200.22,
            "commitsBetweenForRepo": 1115,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,250 +1,234 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n-        // Acknowledge the request\n-        try {\n-            response.sendAcknowledgement();\n-        } catch (IOException e) {\n-            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n-                             wrapper.getName()), e);\n-            throwable = e;\n-            exception(request, response, e);\n-        } catch (Throwable e) {\n-            ExceptionUtils.handleThrowable(e);\n-            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n-                             wrapper.getName()), e);\n-            throwable = e;\n-            exception(request, response, e);\n-            servlet = null;\n-        }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n         } catch (ClientAbortException e) {\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {}
        },
        "029af406026b1380f553ade9f540edb3326741db": {
            "type": "Ybodychange",
            "commitMessage": "Fix https://issues.apache.org/bugzilla/show_bug.cgi?id=49916\nSwitch to using an initialisation parameter to pass JSP file information from Catalina to Jasper. This simplifies the Catalina code as well as making it easier for Geronimo and others to integrate Jasper.\nPatch provided by David Jencks.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1003589 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "01/10/10 12:29 PM",
            "commitName": "029af406026b1380f553ade9f540edb3326741db",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "29/09/10 5:07 AM",
            "commitNameOld": "132e68bf4076a254dd96af9d93897924485a984c",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 2.31,
            "commitsBetweenForRepo": 30,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,262 +1,250 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n-            String jspFile = wrapper.getJspFile();\n-            if (jspFile != null)\n-                request.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n-            else\n-                request.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n-            request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n        } catch (ClientAbortException e) {\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "857482be4b2074a4ab68810266ba796c3db3852e": {
            "type": "Ybodychange",
            "commitMessage": "Partial fix for https://issues.apache.org/bugzilla/show_bug.cgi?id=48644\nSome Throwables must always be re-thrown\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1001904 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "27/09/10 3:52 PM",
            "commitName": "857482be4b2074a4ab68810266ba796c3db3852e",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "22/08/10 10:34 AM",
            "commitNameOld": "406f681dffe02af464a5b34bbba69a4ca6c8292a",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 36.22,
            "commitsBetweenForRepo": 186,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,257 +1,262 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n             response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n+            ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n+            ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n                 request.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n                 request.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\n                         \"standardWrapper.serviceExceptionRoot\",\n                         wrapper.getName(), context.getName(), e.getMessage()),\n                         rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n+            ExceptionUtils.handleThrowable(e);\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\n                     \"standardWrapper.serviceException\", wrapper.getName(),\n                     context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n+            ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n+            ExceptionUtils.handleThrowable(e);\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n            response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n                request.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n                request.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            ExceptionUtils.handleThrowable(e);\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "15"
        },
        "16f9ca9b3528d764e7680a9606a99e40d9e650d6": {
            "type": "Ybodychange",
            "commitMessage": "Improve logging of unhandled servlet exceptions by including the context name. For JasperExceptions, the JSP snippet will be logged (if enabled). Previously this was not logged and only displayed in the error page seen by the user.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@961535 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "07/07/10 6:33 PM",
            "commitName": "16f9ca9b3528d764e7680a9606a99e40d9e650d6",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "04/05/10 5:59 AM",
            "commitNameOld": "2880cc44e16d1c3d47b74f6089cc9509d90a2b6d",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 64.52,
            "commitsBetweenForRepo": 332,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,252 +1,257 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n-            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n-                             wrapper.getName()), e);\n+            container.getLogger().error(sm.getString(\n+                    \"standardWrapper.serviceException\", wrapper.getName(),\n+                    context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n-            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n-                             wrapper.getName()), e);\n+            container.getLogger().error(sm.getString(\n+                    \"standardWrapper.serviceException\", wrapper.getName(),\n+                    context.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n-                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n-                                 wrapper.getName()), rootCause);\n+                container.getLogger().error(sm.getString(\n+                        \"standardWrapper.serviceExceptionRoot\",\n+                        wrapper.getName(), context.getName(), e.getMessage()),\n+                        rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n-            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n-                             wrapper.getName()), e);\n+            container.getLogger().error(sm.getString(\n+                    \"standardWrapper.serviceException\", wrapper.getName(),\n+                    context.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\n                        \"standardWrapper.serviceExceptionRoot\",\n                        wrapper.getName(), context.getName(), e.getMessage()),\n                        rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\n                    \"standardWrapper.serviceException\", wrapper.getName(),\n                    context.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "ee69bc0ee6b68c5ad89dc068a7ff304fae808633": {
            "type": "Ybodychange",
            "commitMessage": "Add in a slightly different behavior for dispatch.\ndispatch() will return immediately, according to spec. But if dispatch is called from the tomcat worker thread, then the dispatch will not happen until the worker thread has backed out of the call. This prevents multiple threads being launched into the same request/response and causing potential concurrency issues.\nThe Async state machine guarantees that multiple dispatch can not be called.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@927182 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "24/03/10 4:26 PM",
            "commitName": "ee69bc0ee6b68c5ad89dc068a7ff304fae808633",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "07/12/09 10:43 AM",
            "commitNameOld": "c4507ffb8a72219ba5d56df248ef29b13b7f4ef9",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 107.2,
            "commitsBetweenForRepo": 648,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,252 +1,252 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n-                        if (request.isAsyncStarted()) {\n+                        if (request.isAsyncDispatching()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n-                    if (request.isAsyncStarted()) {\n+                    if (request.isAsyncDispatching()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncDispatching()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncDispatching()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "c4507ffb8a72219ba5d56df248ef29b13b7f4ef9": {
            "type": "Ybodychange",
            "commitMessage": "Add support for WebFilter\nRemove wrappers to implement isAsyncSupported() having found the setAttribute() code\nIt is individual filters rather than the whole filter chain that need to be considered for isAsyncSupported\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@887992 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "07/12/09 10:43 AM",
            "commitName": "c4507ffb8a72219ba5d56df248ef29b13b7f4ef9",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "17/11/09 4:13 PM",
            "commitNameOld": "c52b1bada15a9f28fccf74364c61e43bec3d1ae7",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 19.77,
            "commitsBetweenForRepo": 129,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,256 +1,252 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n-        //check filters to see if we support async or not.\n-        if (filterChain != null && request.isAsyncSupported()) {\n-            request.setAsyncSupported(filterChain.isAsyncSupported());\n-        }\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncStarted()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncStarted()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "e16523c2f5a201e70406d54f2d3dba77f6eedc53": {
            "type": "Ybodychange",
            "commitMessage": "Just like filters, valves will have to be async aware in order for it to work properly. \n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@823710 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "09/10/09 4:52 PM",
            "commitName": "e16523c2f5a201e70406d54f2d3dba77f6eedc53",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "15/09/09 7:27 AM",
            "commitNameOld": "7c21d1fd8909169effd019a0d00ce662b3e8454a",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 24.39,
            "commitsBetweenForRepo": 57,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,256 +1,256 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n         //check filters to see if we support async or not.\n-        if (filterChain != null) {\n+        if (filterChain != null && request.isAsyncSupported()) {\n             request.setAsyncSupported(filterChain.isAsyncSupported());\n         }\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncStarted()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncStarted()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n        //check filters to see if we support async or not.\n        if (filterChain != null && request.isAsyncSupported()) {\n            request.setAsyncSupported(filterChain.isAsyncSupported());\n        }\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "8"
        },
        "7c21d1fd8909169effd019a0d00ce662b3e8454a": {
            "type": "Ybodychange",
            "commitMessage": "Fix NPE if no filters are configured.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@815290 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "15/09/09 7:27 AM",
            "commitName": "7c21d1fd8909169effd019a0d00ce662b3e8454a",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "07/08/09 9:49 AM",
            "commitNameOld": "f005cffc4e9558e5db7d520d093ebe82fc4c9208",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 38.9,
            "commitsBetweenForRepo": 99,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,254 +1,256 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n         //check filters to see if we support async or not.\n-        request.setAsyncSupported(filterChain.isAsyncSupported());\n+        if (filterChain != null) {\n+            request.setAsyncSupported(filterChain.isAsyncSupported());\n+        }\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncStarted()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncStarted()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n        //check filters to see if we support async or not.\n        if (filterChain != null) {\n            request.setAsyncSupported(filterChain.isAsyncSupported());\n        }\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "8008f3d25e02368349ab144f5425c7f9ac2fdfd6": {
            "type": "Ybodychange",
            "commitMessage": "One more use case\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@801789 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "06/08/09 2:34 PM",
            "commitName": "8008f3d25e02368349ab144f5425c7f9ac2fdfd6",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "17/07/09 5:37 PM",
            "commitNameOld": "27e9802b664669c7a0f37b6d075e1c8a3e12453f",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 19.87,
            "commitsBetweenForRepo": 78,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,251 +1,254 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         DispatcherType dispatcherType = DispatcherType.REQUEST;\n         if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n+        \n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n+        //check filters to see if we support async or not.\n+        request.setAsyncSupported(filterChain.isAsyncSupported());\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncStarted()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncStarted()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        \n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n        //check filters to see if we support async or not.\n        request.setAsyncSupported(filterChain.isAsyncSupported());\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "27e9802b664669c7a0f37b6d075e1c8a3e12453f": {
            "type": "Ybodychange",
            "commitMessage": "the dispatcher type should be ASYNC when we are doing a dispatch\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@795256 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "17/07/09 5:37 PM",
            "commitName": "27e9802b664669c7a0f37b6d075e1c8a3e12453f",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "17/07/09 4:54 PM",
            "commitNameOld": "d94be0ddf0f4d826a11827ef5f5181f645f973fb",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 0.03,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,249 +1,251 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n+        DispatcherType dispatcherType = DispatcherType.REQUEST;\n+        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n-             DispatcherType.REQUEST);\n+             dispatcherType);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncStarted()) {\n                             //TODO SERVLET3 - async\n                             ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncStarted()) {\n                         //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        DispatcherType dispatcherType = DispatcherType.REQUEST;\n        if (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; \n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             dispatcherType);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "d94be0ddf0f4d826a11827ef5f5181f645f973fb": {
            "type": "Ybodychange",
            "commitMessage": "Add notes\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@795241 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "17/07/09 4:54 PM",
            "commitName": "d94be0ddf0f4d826a11827ef5f5181f645f973fb",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "17/07/09 4:32 PM",
            "commitNameOld": "133fd16ac360cf5b8bb1ae710e69c8b514c8b87f",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 0.02,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,247 +1,249 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              DispatcherType.REQUEST);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isAsyncStarted()) {\n-                           ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n+                            //TODO SERVLET3 - async\n+                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                         } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isAsyncStarted()) {\n+                        //TODO SERVLET3 - async\n                         ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                     } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             DispatcherType.REQUEST);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                            //TODO SERVLET3 - async\n                            ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        //TODO SERVLET3 - async\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "133fd16ac360cf5b8bb1ae710e69c8b514c8b87f": {
            "type": "Ybodychange",
            "commitMessage": "Async patches phase 1 - Async means the container thread can back out. This means that valves need to be async aware. For example, access log valve, can no longer log upon exit of the method since the thread can back out based on async behavior.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@795231 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "17/07/09 4:32 PM",
            "commitName": "133fd16ac360cf5b8bb1ae710e69c8b514c8b87f",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "16/07/09 12:44 PM",
            "commitNameOld": "cc3afb2c7db1d18c0328dcb4b12cdc6127397ee5",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 1.16,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,243 +1,247 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              DispatcherType.REQUEST);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n-                        if (comet) {\n+                        if (request.isAsyncStarted()) {\n+                           ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n+                        } else if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n-                    if (comet) {\n+                    if (request.isAsyncStarted()) {\n+                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n+                    } else if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             DispatcherType.REQUEST);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isAsyncStarted()) {\n                           ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); \n                        } else if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isAsyncStarted()) {\n                        ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();\n                    } else if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "cc3afb2c7db1d18c0328dcb4b12cdc6127397ee5": {
            "type": "Ybodychange",
            "commitMessage": "Refactor the dispatcher types from int and Integer to the one supplied by the Servlet specification.\n\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@794766 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "16/07/09 12:44 PM",
            "commitName": "cc3afb2c7db1d18c0328dcb4b12cdc6127397ee5",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "13/07/09 5:03 PM",
            "commitNameOld": "b080a899b091be9b35b64681ed50e1ee4ca8f71c",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 2.82,
            "commitsBetweenForRepo": 27,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,243 +1,243 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = request.getRequestPathMB();\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n-             ApplicationFilterFactory.REQUEST_INTEGER);\n+             DispatcherType.REQUEST);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             DispatcherType.REQUEST);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "6"
        },
        "2732fb76bebdc4bc6cfe59e5a3e9dbad8cdea5da": {
            "type": "Ybodychange",
            "commitMessage": "Code clean up prompted by Eclipse:\n - mark unused parameters as unused\n - remove code that doesn't do anything\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@764898 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "14/04/09 12:46 PM",
            "commitName": "2732fb76bebdc4bc6cfe59e5a3e9dbad8cdea5da",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "15/11/07 9:09 AM",
            "commitNameOld": "1bb905c8cfd9287a366e495be7c11b2b1aca5497",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 516.11,
            "commitsBetweenForRepo": 1025,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,247 +1,243 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n-            servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n-        MessageBytes requestPathMB = null;\n-        if (request != null) {\n-            requestPathMB = request.getRequestPathMB();\n-        }\n+        MessageBytes requestPathMB = request.getRequestPathMB();\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (comet) {\n                         request.setComet(true);\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = request.getRequestPathMB();\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "1bb905c8cfd9287a366e495be7c11b2b1aca5497": {
            "type": "Ybodychange",
            "commitMessage": "Fix comet handling in case BEGIN event calls CometEvent.close\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@595328 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "15/11/07 9:09 AM",
            "commitName": "1bb905c8cfd9287a366e495be7c11b2b1aca5497",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "19/07/07 7:21 PM",
            "commitNameOld": "e9f1b47642d26a3cee5a520cc2dfbcbf427fdab1",
            "commitAuthorOld": "Filip Hanik",
            "daysBetweenCommits": 118.62,
            "commitsBetweenForRepo": 270,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,247 +1,247 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n             request.setComet(true);\n         }\n         \n         // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = null;\n         if (request != null) {\n             requestPathMB = request.getRequestPathMB();\n         }\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n         // Reset comet flag value after creating the filter chain\n         request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (comet) {\n-                        filterChain.doFilterEvent(request.getEvent());\n                         request.setComet(true);\n+                        filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (comet) {\n                        request.setComet(true);\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "e9f1b47642d26a3cee5a520cc2dfbcbf427fdab1": {
            "type": "Ybodychange",
            "commitMessage": "forward port from 6.0\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@557822 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "19/07/07 7:21 PM",
            "commitName": "e9f1b47642d26a3cee5a520cc2dfbcbf427fdab1",
            "commitAuthor": "Filip Hanik",
            "commitDateOld": "15/04/07 12:45 PM",
            "commitNameOld": "c3d2ce46de54d41f084210f60f9e80a57841ae43",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 95.27,
            "commitsBetweenForRepo": 200,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,244 +1,247 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             container.getLogger().error(\n                     sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n+            request.setComet(true);\n         }\n         \n-        // Acknowlege the request\n+        // Acknowledge the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = null;\n         if (request != null) {\n             requestPathMB = request.getRequestPathMB();\n         }\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n+        // Reset comet flag value after creating the filter chain\n+        request.setComet(false);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (comet) {\n                         filterChain.doFilterEvent(request.getEvent());\n                         request.setComet(true);\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n            request.setComet(true);\n        }\n        \n        // Acknowledge the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n        // Reset comet flag value after creating the filter chain\n        request.setComet(false);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (comet) {\n                        filterChain.doFilterEvent(request.getEvent());\n                        request.setComet(true);\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "c3d2ce46de54d41f084210f60f9e80a57841ae43": {
            "type": "Ybodychange",
            "commitMessage": "Fix bug 42039. Log a stack trace if a servlet throws an UnavailableException. Patch provided by Kawasima Kazuh\nRemove some unused code.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@529036 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "15/04/07 12:45 PM",
            "commitName": "c3d2ce46de54d41f084210f60f9e80a57841ae43",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "30/03/07 9:38 AM",
            "commitNameOld": "22c47be25fe7abd6f712b819e2f8416f873e07b1",
            "commitAuthorOld": "Remy Maucherat",
            "daysBetweenCommits": 16.13,
            "commitsBetweenForRepo": 60,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,241 +1,244 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n+            container.getLogger().error(\n+                    sm.getString(\"standardWrapper.allocateException\",\n+                            wrapper.getName()), e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             comet = true;\n         }\n         \n         // Acknowlege the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = null;\n         if (request != null) {\n             requestPathMB = request.getRequestPathMB();\n         }\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n                             request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (comet) {\n                         filterChain.doFilterEvent(request.getEvent());\n                         request.setComet(true);\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            container.getLogger().error(\n                    sm.getString(\"standardWrapper.allocateException\",\n                            wrapper.getName()), e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n        }\n        \n        // Acknowlege the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (comet) {\n                        filterChain.doFilterEvent(request.getEvent());\n                        request.setComet(true);\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "22c47be25fe7abd6f712b819e2f8416f873e07b1": {
            "type": "Ybodychange",
            "commitMessage": "- Adjustments to error processing with Comet during the begin event (exceptions not causing error reports).\n- Fix a probable bug when security was enabled (Comet would most likely not work).\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@524103 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "30/03/07 9:38 AM",
            "commitName": "22c47be25fe7abd6f712b819e2f8416f873e07b1",
            "commitAuthor": "Remy Maucherat",
            "commitDateOld": "15/02/07 9:09 PM",
            "commitNameOld": "8ba833433e36483b8c90a239ee94826c168fd93e",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 42.48,
            "commitsBetweenForRepo": 105,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,238 +1,241 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n+        boolean comet = false;\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n-            request.setComet(true);\n+            comet = true;\n         }\n         \n         // Acknowlege the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = null;\n         if (request != null) {\n             requestPathMB = request.getRequestPathMB();\n         }\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n-                        if (request.isComet()) {\n+                        if (comet) {\n                             filterChain.doFilterEvent(request.getEvent());\n+                            request.setComet(true);\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n-                    if (request.isComet()) {\n+                    if (comet) {\n                         filterChain.doFilterEvent(request.getEvent());\n+                        request.setComet(true);\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        boolean comet = false;\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            comet = true;\n        }\n        \n        // Acknowlege the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (comet) {\n                            filterChain.doFilterEvent(request.getEvent());\n                            request.setComet(true);\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (comet) {\n                        filterChain.doFilterEvent(request.getEvent());\n                        request.setComet(true);\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "8ba833433e36483b8c90a239ee94826c168fd93e": {
            "type": "Ybodychange",
            "commitMessage": "Port fix bug 41608. Make log levels consistent.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@508295 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "15/02/07 9:09 PM",
            "commitName": "8ba833433e36483b8c90a239ee94826c168fd93e",
            "commitAuthor": "Mark Emlyn David Thomas",
            "commitDateOld": "23/10/06 10:17 PM",
            "commitNameOld": "db5024a4f04a30a22f7ef50d3a5ed643d25117e8",
            "commitAuthorOld": "Mark Emlyn David Thomas",
            "daysBetweenCommits": 114.99,
            "commitsBetweenForRepo": 230,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,238 +1,238 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n         // Identify if the request is Comet related now that the servlet has been allocated\n         if (servlet instanceof CometProcessor \n                 && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n             request.setComet(true);\n         }\n         \n         // Acknowlege the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = null;\n         if (request != null) {\n             requestPathMB = request.getRequestPathMB();\n         }\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n                         if (request.isComet()) {\n                             filterChain.doFilterEvent(request.getEvent());\n                         } else {\n                             filterChain.doFilter(request.getRequest(), \n                                     response.getResponse());\n                         }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n                     if (request.isComet()) {\n                         filterChain.doFilterEvent(request.getEvent());\n                     } else {\n                         filterChain.doFilter\n                             (request.getRequest(), response.getResponse());\n                     }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n-            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n+            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n-            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n+            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n         if (filterChain != null) {\n             if (request.isComet()) {\n                 // If this is a Comet request, then the same chain will be used for the\n                 // processing of all subsequent events.\n                 filterChain.reuse();\n             } else {\n                 filterChain.release();\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            request.setComet(true);\n        }\n        \n        // Acknowlege the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isComet()) {\n                            filterChain.doFilterEvent(request.getEvent());\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isComet()) {\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "4d47722dda0aa131d8707efe0d3d9352fc2fa04e": {
            "type": "Ybodychange",
            "commitMessage": "- Redo Comet processing using events.\n- Add Valve.event (most regular valves do not do anything, but standard valves need to call the next pipeline).\n- Add a new Filter interface that filters can implement to intercept the events (I didn't test it yet).\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@442778 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "12/09/06 7:55 PM",
            "commitName": "4d47722dda0aa131d8707efe0d3d9352fc2fa04e",
            "commitAuthor": "Remy Maucherat",
            "commitDateOld": "20/07/06 7:50 AM",
            "commitNameOld": "eae54419c6e196933998f63358367040edaa4a8c",
            "commitAuthorOld": "Mladen Turk",
            "daysBetweenCommits": 54.5,
            "commitsBetweenForRepo": 86,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,227 +1,238 @@\n     public final void invoke(Request request, Response response)\n         throws IOException, ServletException {\n \n         // Initialize local variables we may need\n         boolean unavailable = false;\n         Throwable throwable = null;\n         // This should be a Request attribute...\n         long t1=System.currentTimeMillis();\n         requestCount++;\n         StandardWrapper wrapper = (StandardWrapper) getContainer();\n         Servlet servlet = null;\n         Context context = (Context) wrapper.getParent();\n         \n         // Check for the application being marked unavailable\n         if (!context.getAvailable()) {\n         \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardContext.isUnavailable\"));\n             unavailable = true;\n         }\n \n         // Check for the servlet being marked unavailable\n         if (!unavailable && wrapper.isUnavailable()) {\n             container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                     wrapper.getName()));\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                         sm.getString(\"standardWrapper.isUnavailable\",\n                                 wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n                 response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                         sm.getString(\"standardWrapper.notFound\",\n                                 wrapper.getName()));\n             }\n             unavailable = true;\n         }\n \n         // Allocate a servlet instance to process this request\n         try {\n             if (!unavailable) {\n                 servlet = wrapper.allocate();\n             }\n         } catch (UnavailableException e) {\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n             \tresponse.setDateHeader(\"Retry-After\", available);\n             \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n         } catch (ServletException e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), StandardWrapper.getRootCause(e));\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n \n+        // Identify if the request is Comet related now that the servlet has been allocated\n+        if (servlet instanceof CometProcessor \n+                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n+            request.setComet(true);\n+        }\n+        \n         // Acknowlege the request\n         try {\n             response.sendAcknowledgement();\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n             servlet = null;\n         }\n         MessageBytes requestPathMB = null;\n         if (request != null) {\n             requestPathMB = request.getRequestPathMB();\n         }\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n              ApplicationFilterFactory.REQUEST_INTEGER);\n         request.setAttribute\n             (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n              requestPathMB);\n         // Create the filter chain for this request\n         ApplicationFilterFactory factory =\n             ApplicationFilterFactory.getInstance();\n         ApplicationFilterChain filterChain =\n             factory.createFilterChain(request, wrapper, servlet);\n \n         // Call the filter chain for this request\n         // NOTE: This also calls the servlet's service() method\n         try {\n             String jspFile = wrapper.getJspFile();\n             if (jspFile != null)\n             \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n             else\n             \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             if ((servlet != null) && (filterChain != null)) {\n-\n                 // Swallow output if needed\n                 if (context.getSwallowOutput()) {\n                     try {\n                         SystemLogHandler.startCapture();\n-                        filterChain.doFilter(request.getRequest(), \n-                                response.getResponse());\n+                        if (request.isComet()) {\n+                            filterChain.doFilterEvent(request.getEvent());\n+                        } else {\n+                            filterChain.doFilter(request.getRequest(), \n+                                    response.getResponse());\n+                        }\n                     } finally {\n                         String log = SystemLogHandler.stopCapture();\n                         if (log != null && log.length() > 0) {\n                             context.getLogger().info(log);\n                         }\n                     }\n                 } else {\n-                    filterChain.doFilter\n-                        (request.getRequest(), response.getResponse());\n+                    if (request.isComet()) {\n+                        filterChain.doFilterEvent(request.getEvent());\n+                    } else {\n+                        filterChain.doFilter\n+                            (request.getRequest(), response.getResponse());\n+                    }\n                 }\n \n             }\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n         } catch (ClientAbortException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             throwable = e;\n             exception(request, response, e);\n         } catch (IOException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         } catch (UnavailableException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             //            throwable = e;\n             //            exception(request, response, e);\n             wrapper.unavailable(e);\n             long available = wrapper.getAvailable();\n             if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                 response.setDateHeader(\"Retry-After\", available);\n                 response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                            sm.getString(\"standardWrapper.isUnavailable\",\n                                         wrapper.getName()));\n             } else if (available == Long.MAX_VALUE) {\n             \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                             sm.getString(\"standardWrapper.notFound\",\n                                         wrapper.getName()));\n             }\n             // Do not save exception in 'throwable', because we\n             // do not want to do exception(request, response, e) processing\n         } catch (ServletException e) {\n         \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n             Throwable rootCause = StandardWrapper.getRootCause(e);\n             if (!(rootCause instanceof ClientAbortException)) {\n                 container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                  wrapper.getName()), rootCause);\n             }\n             throwable = e;\n             exception(request, response, e);\n         } catch (Throwable e) {\n             request.removeAttribute(Globals.JSP_FILE_ATTR);\n             container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                              wrapper.getName()), e);\n             throwable = e;\n             exception(request, response, e);\n         }\n \n         // Release the filter chain (if any) for this request\n-        try {\n-            if (filterChain != null)\n+        if (filterChain != null) {\n+            if (request.isComet()) {\n+                // If this is a Comet request, then the same chain will be used for the\n+                // processing of all subsequent events.\n+                filterChain.reuse();\n+            } else {\n                 filterChain.release();\n-        } catch (Throwable e) {\n-            container.getLogger().error(sm.getString(\"standardWrapper.releaseFilters\",\n-                             wrapper.getName()), e);\n-            if (throwable == null) {\n-                throwable = e;\n-                exception(request, response, e);\n             }\n         }\n \n         // Deallocate the allocated servlet instance\n         try {\n             if (servlet != null) {\n                 wrapper.deallocate(servlet);\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n \n         // If this servlet has been marked permanently unavailable,\n         // unload it and release this instance\n         try {\n             if ((servlet != null) &&\n                 (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                 wrapper.unload();\n             }\n         } catch (Throwable e) {\n             container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                              wrapper.getName()), e);\n             if (throwable == null) {\n                 throwable = e;\n                 exception(request, response, e);\n             }\n         }\n         long t2=System.currentTimeMillis();\n \n         long time=t2-t1;\n         processingTime += time;\n         if( time > maxTime) maxTime=time;\n         if( time < minTime) minTime=time;\n \n     }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Identify if the request is Comet related now that the servlet has been allocated\n        if (servlet instanceof CometProcessor \n                && request.getAttribute(\"org.apache.tomcat.comet.support\") == Boolean.TRUE) {\n            request.setComet(true);\n        }\n        \n        // Acknowlege the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        if (request.isComet()) {\n                            filterChain.doFilterEvent(request.getEvent());\n                        } else {\n                            filterChain.doFilter(request.getRequest(), \n                                    response.getResponse());\n                        }\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    if (request.isComet()) {\n                        filterChain.doFilterEvent(request.getEvent());\n                    } else {\n                        filterChain.doFilter\n                            (request.getRequest(), response.getResponse());\n                    }\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        if (filterChain != null) {\n            if (request.isComet()) {\n                // If this is a Comet request, then the same chain will be used for the\n                // processing of all subsequent events.\n                filterChain.reuse();\n            } else {\n                filterChain.release();\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "a84fabcbc6fee8a69253ad92a304b4718e96a7c9": {
            "type": "Yintroduced",
            "commitMessage": "- Attempt to create a new repository according to the earlier thread.\n- No modules right now.\n- Dependencies on c-logging, c-modeler (which I think I will merge/simplify to util, as done with \n  digester earlier), Ant, JDT, PureTLS and JavaMail. Maybe it is possible to add dummy sources\n  for JavaMail to build without having to get the JAR, don't know about PureTLS.\n- Will require Java 5.\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/tc6.0.x/trunk@389146 13f79535-47bb-0310-9956-ffa450edef68\n",
            "commitDate": "27/03/06 7:53 AM",
            "commitName": "a84fabcbc6fee8a69253ad92a304b4718e96a7c9",
            "commitAuthor": "Remy Maucherat",
            "diff": "@@ -0,0 +1,227 @@\n+    public final void invoke(Request request, Response response)\n+        throws IOException, ServletException {\n+\n+        // Initialize local variables we may need\n+        boolean unavailable = false;\n+        Throwable throwable = null;\n+        // This should be a Request attribute...\n+        long t1=System.currentTimeMillis();\n+        requestCount++;\n+        StandardWrapper wrapper = (StandardWrapper) getContainer();\n+        Servlet servlet = null;\n+        Context context = (Context) wrapper.getParent();\n+        \n+        // Check for the application being marked unavailable\n+        if (!context.getAvailable()) {\n+        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n+                           sm.getString(\"standardContext.isUnavailable\"));\n+            unavailable = true;\n+        }\n+\n+        // Check for the servlet being marked unavailable\n+        if (!unavailable && wrapper.isUnavailable()) {\n+            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n+                    wrapper.getName()));\n+            long available = wrapper.getAvailable();\n+            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n+                response.setDateHeader(\"Retry-After\", available);\n+                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n+                        sm.getString(\"standardWrapper.isUnavailable\",\n+                                wrapper.getName()));\n+            } else if (available == Long.MAX_VALUE) {\n+                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n+                        sm.getString(\"standardWrapper.notFound\",\n+                                wrapper.getName()));\n+            }\n+            unavailable = true;\n+        }\n+\n+        // Allocate a servlet instance to process this request\n+        try {\n+            if (!unavailable) {\n+                servlet = wrapper.allocate();\n+            }\n+        } catch (UnavailableException e) {\n+            long available = wrapper.getAvailable();\n+            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n+            \tresponse.setDateHeader(\"Retry-After\", available);\n+            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n+                           sm.getString(\"standardWrapper.isUnavailable\",\n+                                        wrapper.getName()));\n+            } else if (available == Long.MAX_VALUE) {\n+            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n+                           sm.getString(\"standardWrapper.notFound\",\n+                                        wrapper.getName()));\n+            }\n+        } catch (ServletException e) {\n+            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n+                             wrapper.getName()), StandardWrapper.getRootCause(e));\n+            throwable = e;\n+            exception(request, response, e);\n+            servlet = null;\n+        } catch (Throwable e) {\n+            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n+                             wrapper.getName()), e);\n+            throwable = e;\n+            exception(request, response, e);\n+            servlet = null;\n+        }\n+\n+        // Acknowlege the request\n+        try {\n+            response.sendAcknowledgement();\n+        } catch (IOException e) {\n+        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n+            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n+                             wrapper.getName()), e);\n+            throwable = e;\n+            exception(request, response, e);\n+        } catch (Throwable e) {\n+            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n+                             wrapper.getName()), e);\n+            throwable = e;\n+            exception(request, response, e);\n+            servlet = null;\n+        }\n+        MessageBytes requestPathMB = null;\n+        if (request != null) {\n+            requestPathMB = request.getRequestPathMB();\n+        }\n+        request.setAttribute\n+            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n+             ApplicationFilterFactory.REQUEST_INTEGER);\n+        request.setAttribute\n+            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n+             requestPathMB);\n+        // Create the filter chain for this request\n+        ApplicationFilterFactory factory =\n+            ApplicationFilterFactory.getInstance();\n+        ApplicationFilterChain filterChain =\n+            factory.createFilterChain(request, wrapper, servlet);\n+\n+        // Call the filter chain for this request\n+        // NOTE: This also calls the servlet's service() method\n+        try {\n+            String jspFile = wrapper.getJspFile();\n+            if (jspFile != null)\n+            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n+            else\n+            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n+            if ((servlet != null) && (filterChain != null)) {\n+\n+                // Swallow output if needed\n+                if (context.getSwallowOutput()) {\n+                    try {\n+                        SystemLogHandler.startCapture();\n+                        filterChain.doFilter(request.getRequest(), \n+                                response.getResponse());\n+                    } finally {\n+                        String log = SystemLogHandler.stopCapture();\n+                        if (log != null && log.length() > 0) {\n+                            context.getLogger().info(log);\n+                        }\n+                    }\n+                } else {\n+                    filterChain.doFilter\n+                        (request.getRequest(), response.getResponse());\n+                }\n+\n+            }\n+            request.removeAttribute(Globals.JSP_FILE_ATTR);\n+        } catch (ClientAbortException e) {\n+        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n+            throwable = e;\n+            exception(request, response, e);\n+        } catch (IOException e) {\n+        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n+            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n+                             wrapper.getName()), e);\n+            throwable = e;\n+            exception(request, response, e);\n+        } catch (UnavailableException e) {\n+        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n+            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n+                             wrapper.getName()), e);\n+            //            throwable = e;\n+            //            exception(request, response, e);\n+            wrapper.unavailable(e);\n+            long available = wrapper.getAvailable();\n+            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n+                response.setDateHeader(\"Retry-After\", available);\n+                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n+                           sm.getString(\"standardWrapper.isUnavailable\",\n+                                        wrapper.getName()));\n+            } else if (available == Long.MAX_VALUE) {\n+            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n+                            sm.getString(\"standardWrapper.notFound\",\n+                                        wrapper.getName()));\n+            }\n+            // Do not save exception in 'throwable', because we\n+            // do not want to do exception(request, response, e) processing\n+        } catch (ServletException e) {\n+        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n+            Throwable rootCause = StandardWrapper.getRootCause(e);\n+            if (!(rootCause instanceof ClientAbortException)) {\n+                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n+                                 wrapper.getName()), rootCause);\n+            }\n+            throwable = e;\n+            exception(request, response, e);\n+        } catch (Throwable e) {\n+            request.removeAttribute(Globals.JSP_FILE_ATTR);\n+            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n+                             wrapper.getName()), e);\n+            throwable = e;\n+            exception(request, response, e);\n+        }\n+\n+        // Release the filter chain (if any) for this request\n+        try {\n+            if (filterChain != null)\n+                filterChain.release();\n+        } catch (Throwable e) {\n+            container.getLogger().error(sm.getString(\"standardWrapper.releaseFilters\",\n+                             wrapper.getName()), e);\n+            if (throwable == null) {\n+                throwable = e;\n+                exception(request, response, e);\n+            }\n+        }\n+\n+        // Deallocate the allocated servlet instance\n+        try {\n+            if (servlet != null) {\n+                wrapper.deallocate(servlet);\n+            }\n+        } catch (Throwable e) {\n+            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n+                             wrapper.getName()), e);\n+            if (throwable == null) {\n+                throwable = e;\n+                exception(request, response, e);\n+            }\n+        }\n+\n+        // If this servlet has been marked permanently unavailable,\n+        // unload it and release this instance\n+        try {\n+            if ((servlet != null) &&\n+                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n+                wrapper.unload();\n+            }\n+        } catch (Throwable e) {\n+            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n+                             wrapper.getName()), e);\n+            if (throwable == null) {\n+                throwable = e;\n+                exception(request, response, e);\n+            }\n+        }\n+        long t2=System.currentTimeMillis();\n+\n+        long time=t2-t1;\n+        processingTime += time;\n+        if( time > maxTime) maxTime=time;\n+        if( time < minTime) minTime=time;\n+\n+    }\n\\ No newline at end of file\n",
            "actualSource": "    public final void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        // Initialize local variables we may need\n        boolean unavailable = false;\n        Throwable throwable = null;\n        // This should be a Request attribute...\n        long t1=System.currentTimeMillis();\n        requestCount++;\n        StandardWrapper wrapper = (StandardWrapper) getContainer();\n        Servlet servlet = null;\n        Context context = (Context) wrapper.getParent();\n        \n        // Check for the application being marked unavailable\n        if (!context.getAvailable()) {\n        \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardContext.isUnavailable\"));\n            unavailable = true;\n        }\n\n        // Check for the servlet being marked unavailable\n        if (!unavailable && wrapper.isUnavailable()) {\n            container.getLogger().info(sm.getString(\"standardWrapper.isUnavailable\",\n                    wrapper.getName()));\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                        sm.getString(\"standardWrapper.isUnavailable\",\n                                wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n                response.sendError(HttpServletResponse.SC_NOT_FOUND,\n                        sm.getString(\"standardWrapper.notFound\",\n                                wrapper.getName()));\n            }\n            unavailable = true;\n        }\n\n        // Allocate a servlet instance to process this request\n        try {\n            if (!unavailable) {\n                servlet = wrapper.allocate();\n            }\n        } catch (UnavailableException e) {\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n            \tresponse.setDateHeader(\"Retry-After\", available);\n            \tresponse.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                           sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n        } catch (ServletException e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), StandardWrapper.getRootCause(e));\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.allocateException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n\n        // Acknowlege the request\n        try {\n            response.sendAcknowledgement();\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.acknowledgeException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n            servlet = null;\n        }\n        MessageBytes requestPathMB = null;\n        if (request != null) {\n            requestPathMB = request.getRequestPathMB();\n        }\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_TYPE_ATTR,\n             ApplicationFilterFactory.REQUEST_INTEGER);\n        request.setAttribute\n            (ApplicationFilterFactory.DISPATCHER_REQUEST_PATH_ATTR,\n             requestPathMB);\n        // Create the filter chain for this request\n        ApplicationFilterFactory factory =\n            ApplicationFilterFactory.getInstance();\n        ApplicationFilterChain filterChain =\n            factory.createFilterChain(request, wrapper, servlet);\n\n        // Call the filter chain for this request\n        // NOTE: This also calls the servlet's service() method\n        try {\n            String jspFile = wrapper.getJspFile();\n            if (jspFile != null)\n            \trequest.setAttribute(Globals.JSP_FILE_ATTR, jspFile);\n            else\n            \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            if ((servlet != null) && (filterChain != null)) {\n\n                // Swallow output if needed\n                if (context.getSwallowOutput()) {\n                    try {\n                        SystemLogHandler.startCapture();\n                        filterChain.doFilter(request.getRequest(), \n                                response.getResponse());\n                    } finally {\n                        String log = SystemLogHandler.stopCapture();\n                        if (log != null && log.length() > 0) {\n                            context.getLogger().info(log);\n                        }\n                    }\n                } else {\n                    filterChain.doFilter\n                        (request.getRequest(), response.getResponse());\n                }\n\n            }\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n        } catch (ClientAbortException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            throwable = e;\n            exception(request, response, e);\n        } catch (IOException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        } catch (UnavailableException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().warn(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            //            throwable = e;\n            //            exception(request, response, e);\n            wrapper.unavailable(e);\n            long available = wrapper.getAvailable();\n            if ((available > 0L) && (available < Long.MAX_VALUE)) {\n                response.setDateHeader(\"Retry-After\", available);\n                response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,\n                           sm.getString(\"standardWrapper.isUnavailable\",\n                                        wrapper.getName()));\n            } else if (available == Long.MAX_VALUE) {\n            \tresponse.sendError(HttpServletResponse.SC_NOT_FOUND,\n                            sm.getString(\"standardWrapper.notFound\",\n                                        wrapper.getName()));\n            }\n            // Do not save exception in 'throwable', because we\n            // do not want to do exception(request, response, e) processing\n        } catch (ServletException e) {\n        \trequest.removeAttribute(Globals.JSP_FILE_ATTR);\n            Throwable rootCause = StandardWrapper.getRootCause(e);\n            if (!(rootCause instanceof ClientAbortException)) {\n                container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                                 wrapper.getName()), rootCause);\n            }\n            throwable = e;\n            exception(request, response, e);\n        } catch (Throwable e) {\n            request.removeAttribute(Globals.JSP_FILE_ATTR);\n            container.getLogger().error(sm.getString(\"standardWrapper.serviceException\",\n                             wrapper.getName()), e);\n            throwable = e;\n            exception(request, response, e);\n        }\n\n        // Release the filter chain (if any) for this request\n        try {\n            if (filterChain != null)\n                filterChain.release();\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.releaseFilters\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // Deallocate the allocated servlet instance\n        try {\n            if (servlet != null) {\n                wrapper.deallocate(servlet);\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.deallocateException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n\n        // If this servlet has been marked permanently unavailable,\n        // unload it and release this instance\n        try {\n            if ((servlet != null) &&\n                (wrapper.getAvailable() == Long.MAX_VALUE)) {\n                wrapper.unload();\n            }\n        } catch (Throwable e) {\n            container.getLogger().error(sm.getString(\"standardWrapper.unloadException\",\n                             wrapper.getName()), e);\n            if (throwable == null) {\n                throwable = e;\n                exception(request, response, e);\n            }\n        }\n        long t2=System.currentTimeMillis();\n\n        long time=t2-t1;\n        processingTime += time;\n        if( time > maxTime) maxTime=time;\n        if( time < minTime) minTime=time;\n\n    }",
            "path": "java/org/apache/catalina/core/StandardWrapperValve.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "8205.json"
}