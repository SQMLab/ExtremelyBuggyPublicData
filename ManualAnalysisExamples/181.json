{
    "origin": "codeshovel",
    "repositoryName": "weka",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/weka/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "RegressionByDiscretization.java",
    "functionName": "buildClassifier",
    "functionId": "buildClassifier___instances-Instances",
    "sourceFilePath": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
    "functionStartLine": 252,
    "functionEndLine": 360,
    "numCommitsSeen": 60,
    "timeTaken": 2651,
    "changeHistory": [
        "adcb488b1d5d2db27298ccb0a5c98ccc557dc1d6",
        "2157c7bc9096d5a5c02a15f546fdb2ea40c7f762",
        "33dac0966616a2f57b29232f9835a2c5d228903a",
        "124fb5972b704980c4298eab13e65bf99bd867b2",
        "311bf9c87488d5536f0235cf533039a0d3dc9433",
        "34b8a8b0794ac96c787851cefaf9bfa932eb0607",
        "8f9b5d2f48c45f66fc316152559439232c60b7ad",
        "723f7909e93c644ee69ae3fced786882ebe97f47",
        "d1882963ebce8357f47695933e9914db82de48b6",
        "11aade601b83c87db1e0a1a91604bc70c0714b79",
        "1fa4acbce12c0397b4f4976f7e4b0ff5b10ea294",
        "6aca274366c867c500a2245c768f51084d9f5510",
        "fae478f6f46df9cf27f2506e9af99854c8e25657",
        "5c8ef050d2807d7ce0ba4d0ea768581a98d0f028",
        "568592a70070b68dddbddc4113086fbe51c732f5",
        "a39d73ed80041530b22fb162803294c6574eb4e8",
        "61fa15857450b34e83066b4ec86a510daaa10200",
        "b11d054b0b797f18cc9d94fb0101df1cd54dfbbf",
        "b436fbd2e07c809bb5d4e8a2cf9b48225509e206",
        "e19ef6ed34cd66b4086b301a1b302f63bc70b5ad",
        "0498e42c237b727f03b7e3d2fa0e0491ddd819df",
        "6e4338d940b0fee60289e5f1ef2711641c999311",
        "144f22cd4d5c4c206bc1b3abcc94fdff1998fa86",
        "64d11bb34d0a837d2ec462410b1cb1040435a1a3",
        "4ecff779cbcaaf78ce6eaaec80f57166c5220775"
    ],
    "changeHistoryShort": {
        "4ecff779cbcaaf78ce6eaaec80f57166c5220775": "Ybodychange",
        "64d11bb34d0a837d2ec462410b1cb1040435a1a3": "Ybodychange",
        "144f22cd4d5c4c206bc1b3abcc94fdff1998fa86": "Yfilerename",
        "6e4338d940b0fee60289e5f1ef2711641c999311": "Yfilerename",
        "0498e42c237b727f03b7e3d2fa0e0491ddd819df": "Ybodychange",
        "e19ef6ed34cd66b4086b301a1b302f63bc70b5ad": "Ybodychange",
        "b436fbd2e07c809bb5d4e8a2cf9b48225509e206": "Yfilerename",
        "b11d054b0b797f18cc9d94fb0101df1cd54dfbbf": "Ybodychange",
        "61fa15857450b34e83066b4ec86a510daaa10200": "Yfilerename",
        "a39d73ed80041530b22fb162803294c6574eb4e8": "Ybodychange",
        "568592a70070b68dddbddc4113086fbe51c732f5": "Ybodychange",
        "5c8ef050d2807d7ce0ba4d0ea768581a98d0f028": "Ybodychange",
        "fae478f6f46df9cf27f2506e9af99854c8e25657": "Ybodychange",
        "6aca274366c867c500a2245c768f51084d9f5510": "Ybodychange",
        "1fa4acbce12c0397b4f4976f7e4b0ff5b10ea294": "Ybodychange",
        "11aade601b83c87db1e0a1a91604bc70c0714b79": "Ybodychange",
        "d1882963ebce8357f47695933e9914db82de48b6": "Ybodychange",
        "723f7909e93c644ee69ae3fced786882ebe97f47": "Ybodychange",
        "8f9b5d2f48c45f66fc316152559439232c60b7ad": "Ybodychange",
        "34b8a8b0794ac96c787851cefaf9bfa932eb0607": "Ybodychange",
        "311bf9c87488d5536f0235cf533039a0d3dc9433": "Ybodychange",
        "124fb5972b704980c4298eab13e65bf99bd867b2": "Ybodychange",
        "33dac0966616a2f57b29232f9835a2c5d228903a": "Ybodychange",
        "2157c7bc9096d5a5c02a15f546fdb2ea40c7f762": "Ybodychange",
        "adcb488b1d5d2db27298ccb0a5c98ccc557dc1d6": "Yintroduced"
    },
    "changeHistoryDetails": {
        "4ecff779cbcaaf78ce6eaaec80f57166c5220775": {
            "type": "Ybodychange",
            "commitMessage": "Fixed many setOptions(), listOptions(), and getOptions() methods to call super class methods. Also, added check for remaining options in setOptions() whereever necessary. More command-line help now output for FilteredClassifiers and AttributeSelectedClassifier.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@10141 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "11/11/13 8:08 PM",
            "commitName": "4ecff779cbcaaf78ce6eaaec80f57166c5220775",
            "commitAuthor": "eibe",
            "commitDateOld": "14/02/12 5:12 PM",
            "commitNameOld": "12ec9a03c8ee092c55491694e0dfba623bc2de6b",
            "commitAuthorOld": "fracpete",
            "daysBetweenCommits": 636.12,
            "commitsBetweenForRepo": 1230,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,109 +1,109 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     // can classifier handle the data?\n     getCapabilities().testWithFail(instances);\n \n     // remove instances with missing class\n     instances = new Instances(instances);\n     instances.deleteWithMissingClass();\n     \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     // Should empty bins be deleted?\n     m_OldIndexToNewIndex = null;\n     if (m_DeleteEmptyBins) {\n \n       // Figure out which classes are empty after discretization\n       int numNonEmptyClasses = 0;\n       boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n           numNonEmptyClasses++;\n           notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n         }\n       }\n       \n       // Compute new list of non-empty classes and mapping of indices\n-      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n+      ArrayList<String> newClassVals = new ArrayList<String>(numNonEmptyClasses);\n       m_OldIndexToNewIndex = new int[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numClasses(); i++) {\n         if (notEmptyClass[i]) {\n          m_OldIndexToNewIndex[i] = newClassVals.size();\n-          newClassVals.addElement(newTrain.classAttribute().value(i));\n+          newClassVals.add(newTrain.classAttribute().value(i));\n         }\n       }\n       \n       // Compute new header information\n       Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                          newClassVals);\n-      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n+      ArrayList<Attribute> newAttributes = new ArrayList<Attribute>(newTrain.numAttributes());\n       for (int i = 0; i < newTrain.numAttributes(); i++) {\n         if (i != newTrain.classIndex()) {\n-          newAttributes.addElement(newTrain.attribute(i).copy());\n+          newAttributes.add((Attribute)newTrain.attribute(i).copy());\n         } else {\n-          newAttributes.addElement(newClass);\n+          newAttributes.add(newClass);\n         }\n       }\n       \n       // Create new header and modify instances\n       Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                     newAttributes,\n                                                     newTrain.numInstances());\n       newTrainTransformed.setClassIndex(newTrain.classIndex());\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         Instance inst = newTrain.instance(i);\n         newTrainTransformed.add(inst);\n         newTrainTransformed.lastInstance().\n           setClassValue(m_OldIndexToNewIndex[(int)inst.classValue()]);\n       }\n       newTrain = newTrainTransformed;\n     }\n \n     // Store target values, in case a prediction interval or computation of median is required\n     m_OriginalTargetValues = new double[instances.numInstances()];\n     m_NewTargetValues = new int[instances.numInstances()];\n     for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n       m_OriginalTargetValues[i] = instances.instance(i).classValue();\n       m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n     }\n \n     m_DiscretizedHeader = new Instances(newTrain, 0);\n \n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     m_ClassCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tm_ClassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (m_ClassCounts[i] > 0) {\n \tm_ClassMeans[i] /= m_ClassCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    m_OldIndexToNewIndex = null;\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      ArrayList<String> newClassVals = new ArrayList<String>(numNonEmptyClasses);\n      m_OldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n         m_OldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.add(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      ArrayList<Attribute> newAttributes = new ArrayList<Attribute>(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.add((Attribute)newTrain.attribute(i).copy());\n        } else {\n          newAttributes.add(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(m_OldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n\n    // Store target values, in case a prediction interval or computation of median is required\n    m_OriginalTargetValues = new double[instances.numInstances()];\n    m_NewTargetValues = new int[instances.numInstances()];\n    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n    }\n\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    m_ClassCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tm_ClassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (m_ClassCounts[i] > 0) {\n\tm_ClassMeans[i] /= m_ClassCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {}
        },
        "64d11bb34d0a837d2ec462410b1cb1040435a1a3": {
            "type": "Ybodychange",
            "commitMessage": "Bug fix: classifyInstance and logDensityForInstance in RegressionByDiscretization did not work if class value was not set to be missing *and* the base learner tried to convert this class value somehow (e.g. as OrdinalClassClassifier does).\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@7920 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "01/12/11 2:03 PM",
            "commitName": "64d11bb34d0a837d2ec462410b1cb1040435a1a3",
            "commitAuthor": "eibe",
            "commitDateOld": "30/11/10 6:21 PM",
            "commitNameOld": "144f22cd4d5c4c206bc1b3abcc94fdff1998fa86",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 365.82,
            "commitsBetweenForRepo": 439,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,108 +1,109 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     // can classifier handle the data?\n     getCapabilities().testWithFail(instances);\n \n     // remove instances with missing class\n     instances = new Instances(instances);\n     instances.deleteWithMissingClass();\n     \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     // Should empty bins be deleted?\n+    m_OldIndexToNewIndex = null;\n     if (m_DeleteEmptyBins) {\n \n       // Figure out which classes are empty after discretization\n       int numNonEmptyClasses = 0;\n       boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n           numNonEmptyClasses++;\n           notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n         }\n       }\n       \n       // Compute new list of non-empty classes and mapping of indices\n       FastVector newClassVals = new FastVector(numNonEmptyClasses);\n-      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n+      m_OldIndexToNewIndex = new int[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numClasses(); i++) {\n         if (notEmptyClass[i]) {\n-         oldIndexToNewIndex[i] = newClassVals.size();\n+         m_OldIndexToNewIndex[i] = newClassVals.size();\n           newClassVals.addElement(newTrain.classAttribute().value(i));\n         }\n       }\n       \n       // Compute new header information\n       Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                          newClassVals);\n       FastVector newAttributes = new FastVector(newTrain.numAttributes());\n       for (int i = 0; i < newTrain.numAttributes(); i++) {\n         if (i != newTrain.classIndex()) {\n           newAttributes.addElement(newTrain.attribute(i).copy());\n         } else {\n           newAttributes.addElement(newClass);\n         }\n       }\n       \n       // Create new header and modify instances\n       Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                     newAttributes,\n                                                     newTrain.numInstances());\n       newTrainTransformed.setClassIndex(newTrain.classIndex());\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         Instance inst = newTrain.instance(i);\n         newTrainTransformed.add(inst);\n         newTrainTransformed.lastInstance().\n-          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n+          setClassValue(m_OldIndexToNewIndex[(int)inst.classValue()]);\n       }\n       newTrain = newTrainTransformed;\n     }\n \n     // Store target values, in case a prediction interval or computation of median is required\n     m_OriginalTargetValues = new double[instances.numInstances()];\n     m_NewTargetValues = new int[instances.numInstances()];\n     for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n       m_OriginalTargetValues[i] = instances.instance(i).classValue();\n       m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n     }\n \n     m_DiscretizedHeader = new Instances(newTrain, 0);\n \n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     m_ClassCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tm_ClassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (m_ClassCounts[i] > 0) {\n \tm_ClassMeans[i] /= m_ClassCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    m_OldIndexToNewIndex = null;\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      m_OldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n         m_OldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(m_OldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n\n    // Store target values, in case a prediction interval or computation of median is required\n    m_OriginalTargetValues = new double[instances.numInstances()];\n    m_NewTargetValues = new int[instances.numInstances()];\n    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n    }\n\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    m_ClassCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tm_ClassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (m_ClassCounts[i] > 0) {\n\tm_ClassMeans[i] /= m_ClassCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {}
        },
        "144f22cd4d5c4c206bc1b3abcc94fdff1998fa86": {
            "type": "Yfilerename",
            "commitMessage": "RegressionByDiscretization moves back into the core weka distribution\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@6987 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "30/11/10 6:21 PM",
            "commitName": "144f22cd4d5c4c206bc1b3abcc94fdff1998fa86",
            "commitAuthor": "mhall",
            "commitDateOld": "30/11/10 6:20 PM",
            "commitNameOld": "6005f344a40320d9cdf086792982798153d0fa11",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n         oldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n\n    // Store target values, in case a prediction interval or computation of median is required\n    m_OriginalTargetValues = new double[instances.numInstances()];\n    m_NewTargetValues = new int[instances.numInstances()];\n    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n    }\n\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    m_ClassCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tm_ClassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (m_ClassCounts[i] > 0) {\n\tm_ClassMeans[i] /= m_ClassCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {
                "oldPath": "packages/internal/regressionByDiscretization/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
                "newPath": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java"
            }
        },
        "6e4338d940b0fee60289e5f1ef2711641c999311": {
            "type": "Yfilerename",
            "commitMessage": "Moved out of main weka source tree to trunk/packages.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@6637 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "06/07/10 9:17 PM",
            "commitName": "6e4338d940b0fee60289e5f1ef2711641c999311",
            "commitAuthor": "mhall",
            "commitDateOld": "05/07/10 2:49 PM",
            "commitNameOld": "c805cbbca47919b0df0da33b6e8b46d1f72d223c",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 1.27,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n         oldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n\n    // Store target values, in case a prediction interval or computation of median is required\n    m_OriginalTargetValues = new double[instances.numInstances()];\n    m_NewTargetValues = new int[instances.numInstances()];\n    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n    }\n\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    m_ClassCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tm_ClassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (m_ClassCounts[i] > 0) {\n\tm_ClassMeans[i] /= m_ClassCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "packages/internal/regressionByDiscretization/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {
                "oldPath": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
                "newPath": "packages/internal/regressionByDiscretization/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java"
            }
        },
        "0498e42c237b727f03b7e3d2fa0e0491ddd819df": {
            "type": "Ybodychange",
            "commitMessage": "Added technical information and updated global info. Can now also attempt to minimize absolute error based on conditional density estimate.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@5925 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "01/09/09 4:54 PM",
            "commitName": "0498e42c237b727f03b7e3d2fa0e0491ddd819df",
            "commitAuthor": "eibe",
            "commitDateOld": "10/08/09 10:16 PM",
            "commitNameOld": "084571cab8ab8aa900731d281b117b46029f7da0",
            "commitAuthorOld": "fracpete",
            "daysBetweenCommits": 21.78,
            "commitsBetweenForRepo": 28,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,108 +1,108 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     // can classifier handle the data?\n     getCapabilities().testWithFail(instances);\n \n     // remove instances with missing class\n     instances = new Instances(instances);\n     instances.deleteWithMissingClass();\n     \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     // Should empty bins be deleted?\n     if (m_DeleteEmptyBins) {\n \n       // Figure out which classes are empty after discretization\n       int numNonEmptyClasses = 0;\n       boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n           numNonEmptyClasses++;\n           notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n         }\n       }\n       \n       // Compute new list of non-empty classes and mapping of indices\n       FastVector newClassVals = new FastVector(numNonEmptyClasses);\n       int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numClasses(); i++) {\n         if (notEmptyClass[i]) {\n          oldIndexToNewIndex[i] = newClassVals.size();\n           newClassVals.addElement(newTrain.classAttribute().value(i));\n         }\n       }\n       \n       // Compute new header information\n       Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                          newClassVals);\n       FastVector newAttributes = new FastVector(newTrain.numAttributes());\n       for (int i = 0; i < newTrain.numAttributes(); i++) {\n         if (i != newTrain.classIndex()) {\n           newAttributes.addElement(newTrain.attribute(i).copy());\n         } else {\n           newAttributes.addElement(newClass);\n         }\n       }\n       \n       // Create new header and modify instances\n       Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                     newAttributes,\n                                                     newTrain.numInstances());\n       newTrainTransformed.setClassIndex(newTrain.classIndex());\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         Instance inst = newTrain.instance(i);\n         newTrainTransformed.add(inst);\n         newTrainTransformed.lastInstance().\n           setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n       }\n       newTrain = newTrainTransformed;\n     }\n \n-    // Store target values, in case a prediction interval is required\n+    // Store target values, in case a prediction interval or computation of median is required\n     m_OriginalTargetValues = new double[instances.numInstances()];\n     m_NewTargetValues = new int[instances.numInstances()];\n     for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n       m_OriginalTargetValues[i] = instances.instance(i).classValue();\n       m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n     }\n \n     m_DiscretizedHeader = new Instances(newTrain, 0);\n \n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     m_ClassCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tm_ClassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (m_ClassCounts[i] > 0) {\n \tm_ClassMeans[i] /= m_ClassCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n         oldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n\n    // Store target values, in case a prediction interval or computation of median is required\n    m_OriginalTargetValues = new double[instances.numInstances()];\n    m_NewTargetValues = new int[instances.numInstances()];\n    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n    }\n\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    m_ClassCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tm_ClassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (m_ClassCounts[i] > 0) {\n\tm_ClassMeans[i] /= m_ClassCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {}
        },
        "e19ef6ed34cd66b4086b301a1b302f63bc70b5ad": {
            "type": "Ybodychange",
            "commitMessage": "Can now do conditional density estimation and interval estimation by fitting univariate density estimator to weighted target values.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@5679 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "24/06/09 8:43 PM",
            "commitName": "e19ef6ed34cd66b4086b301a1b302f63bc70b5ad",
            "commitAuthor": "eibe",
            "commitDateOld": "25/12/08 5:09 PM",
            "commitNameOld": "59222d49425ed847dd9beec8e786018bfbd1cd90",
            "commitAuthorOld": "fracpete",
            "daysBetweenCommits": 181.11,
            "commitsBetweenForRepo": 362,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,99 +1,108 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     // can classifier handle the data?\n     getCapabilities().testWithFail(instances);\n \n     // remove instances with missing class\n     instances = new Instances(instances);\n     instances.deleteWithMissingClass();\n     \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     // Should empty bins be deleted?\n     if (m_DeleteEmptyBins) {\n \n       // Figure out which classes are empty after discretization\n       int numNonEmptyClasses = 0;\n       boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n           numNonEmptyClasses++;\n           notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n         }\n       }\n       \n       // Compute new list of non-empty classes and mapping of indices\n       FastVector newClassVals = new FastVector(numNonEmptyClasses);\n       int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n       for (int i = 0; i < newTrain.numClasses(); i++) {\n         if (notEmptyClass[i]) {\n-          oldIndexToNewIndex[i] = newClassVals.size();\n+         oldIndexToNewIndex[i] = newClassVals.size();\n           newClassVals.addElement(newTrain.classAttribute().value(i));\n         }\n       }\n       \n       // Compute new header information\n       Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                          newClassVals);\n       FastVector newAttributes = new FastVector(newTrain.numAttributes());\n       for (int i = 0; i < newTrain.numAttributes(); i++) {\n         if (i != newTrain.classIndex()) {\n           newAttributes.addElement(newTrain.attribute(i).copy());\n         } else {\n           newAttributes.addElement(newClass);\n         }\n       }\n       \n       // Create new header and modify instances\n       Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                     newAttributes,\n                                                     newTrain.numInstances());\n       newTrainTransformed.setClassIndex(newTrain.classIndex());\n       for (int i = 0; i < newTrain.numInstances(); i++) {\n         Instance inst = newTrain.instance(i);\n         newTrainTransformed.add(inst);\n         newTrainTransformed.lastInstance().\n           setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n       }\n       newTrain = newTrainTransformed;\n     }\n+\n+    // Store target values, in case a prediction interval is required\n+    m_OriginalTargetValues = new double[instances.numInstances()];\n+    m_NewTargetValues = new int[instances.numInstances()];\n+    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n+      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n+      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n+    }\n+\n     m_DiscretizedHeader = new Instances(newTrain, 0);\n \n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n-    int [] classCounts = new int [numClasses];\n+    m_ClassCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n-\tclassCounts[classVal]++;\n+\tm_ClassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n-      if (classCounts[i] > 0) {\n-\tm_ClassMeans[i] /= classCounts[i];\n+      if (m_ClassCounts[i] > 0) {\n+\tm_ClassMeans[i] /= m_ClassCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n         oldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n\n    // Store target values, in case a prediction interval is required\n    m_OriginalTargetValues = new double[instances.numInstances()];\n    m_NewTargetValues = new int[instances.numInstances()];\n    for (int i = 0; i < m_OriginalTargetValues.length; i++) {\n      m_OriginalTargetValues[i] = instances.instance(i).classValue();\n      m_NewTargetValues[i] = (int)newTrain.instance(i).classValue();\n    }\n\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    m_ClassCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tm_ClassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (m_ClassCounts[i] > 0) {\n\tm_ClassMeans[i] /= m_ClassCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {}
        },
        "b436fbd2e07c809bb5d4e8a2cf9b48225509e206": {
            "type": "Yfilerename",
            "commitMessage": "Move out of top level\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@4698 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "13/11/08 2:39 PM",
            "commitName": "b436fbd2e07c809bb5d4e8a2cf9b48225509e206",
            "commitAuthor": "mhall",
            "commitDateOld": "13/11/08 2:38 PM",
            "commitNameOld": "f200e45530b3f65a829297fea7955d3f0a98ce39",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n          oldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {
                "oldPath": "src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
                "newPath": "weka/src/main/java/weka/classifiers/meta/RegressionByDiscretization.java"
            }
        },
        "b11d054b0b797f18cc9d94fb0101df1cd54dfbbf": {
            "type": "Ybodychange",
            "commitMessage": "Now has an option to eliminate empty bins and an option to turn on equal frequency discretization. Removed unnecessary capabilities resriction\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@4670 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "12/11/08 7:21 PM",
            "commitName": "b11d054b0b797f18cc9d94fb0101df1cd54dfbbf",
            "commitAuthor": "mhall",
            "commitDateOld": "12/11/08 5:55 PM",
            "commitNameOld": "61fa15857450b34e83066b4ec86a510daaa10200",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 0.06,
            "commitsBetweenForRepo": 8,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,48 +1,99 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     // can classifier handle the data?\n     getCapabilities().testWithFail(instances);\n \n     // remove instances with missing class\n     instances = new Instances(instances);\n     instances.deleteWithMissingClass();\n     \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n+    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n+    // Should empty bins be deleted?\n+    if (m_DeleteEmptyBins) {\n+\n+      // Figure out which classes are empty after discretization\n+      int numNonEmptyClasses = 0;\n+      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n+      for (int i = 0; i < newTrain.numInstances(); i++) {\n+        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n+          numNonEmptyClasses++;\n+          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n+        }\n+      }\n+      \n+      // Compute new list of non-empty classes and mapping of indices\n+      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n+      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n+      for (int i = 0; i < newTrain.numClasses(); i++) {\n+        if (notEmptyClass[i]) {\n+          oldIndexToNewIndex[i] = newClassVals.size();\n+          newClassVals.addElement(newTrain.classAttribute().value(i));\n+        }\n+      }\n+      \n+      // Compute new header information\n+      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n+                                         newClassVals);\n+      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n+      for (int i = 0; i < newTrain.numAttributes(); i++) {\n+        if (i != newTrain.classIndex()) {\n+          newAttributes.addElement(newTrain.attribute(i).copy());\n+        } else {\n+          newAttributes.addElement(newClass);\n+        }\n+      }\n+      \n+      // Create new header and modify instances\n+      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n+                                                    newAttributes,\n+                                                    newTrain.numInstances());\n+      newTrainTransformed.setClassIndex(newTrain.classIndex());\n+      for (int i = 0; i < newTrain.numInstances(); i++) {\n+        Instance inst = newTrain.instance(i);\n+        newTrainTransformed.add(inst);\n+        newTrainTransformed.lastInstance().\n+          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n+      }\n+      newTrain = newTrainTransformed;\n+    }\n+    m_DiscretizedHeader = new Instances(newTrain, 0);\n+\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tclassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setUseEqualFrequency(getUseEqualFrequency());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    // Should empty bins be deleted?\n    if (m_DeleteEmptyBins) {\n\n      // Figure out which classes are empty after discretization\n      int numNonEmptyClasses = 0;\n      boolean[] notEmptyClass = new boolean[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        if (!notEmptyClass[(int)newTrain.instance(i).classValue()]) {\n          numNonEmptyClasses++;\n          notEmptyClass[(int)newTrain.instance(i).classValue()] = true;\n        }\n      }\n      \n      // Compute new list of non-empty classes and mapping of indices\n      FastVector newClassVals = new FastVector(numNonEmptyClasses);\n      int[] oldIndexToNewIndex = new int[newTrain.numClasses()];\n      for (int i = 0; i < newTrain.numClasses(); i++) {\n        if (notEmptyClass[i]) {\n          oldIndexToNewIndex[i] = newClassVals.size();\n          newClassVals.addElement(newTrain.classAttribute().value(i));\n        }\n      }\n      \n      // Compute new header information\n      Attribute newClass = new Attribute(newTrain.classAttribute().name(), \n                                         newClassVals);\n      FastVector newAttributes = new FastVector(newTrain.numAttributes());\n      for (int i = 0; i < newTrain.numAttributes(); i++) {\n        if (i != newTrain.classIndex()) {\n          newAttributes.addElement(newTrain.attribute(i).copy());\n        } else {\n          newAttributes.addElement(newClass);\n        }\n      }\n      \n      // Create new header and modify instances\n      Instances newTrainTransformed = new Instances(newTrain.relationName(), \n                                                    newAttributes,\n                                                    newTrain.numInstances());\n      newTrainTransformed.setClassIndex(newTrain.classIndex());\n      for (int i = 0; i < newTrain.numInstances(); i++) {\n        Instance inst = newTrain.instance(i);\n        newTrainTransformed.add(inst);\n        newTrainTransformed.lastInstance().\n          setClassValue(oldIndexToNewIndex[(int)inst.classValue()]);\n      }\n      newTrain = newTrainTransformed;\n    }\n    m_DiscretizedHeader = new Instances(newTrain, 0);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {}
        },
        "61fa15857450b34e83066b4ec86a510daaa10200": {
            "type": "Yfilerename",
            "commitMessage": "Moving to new structure\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@4662 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "12/11/08 5:55 PM",
            "commitName": "61fa15857450b34e83066b4ec86a510daaa10200",
            "commitAuthor": "mhall",
            "commitDateOld": "12/11/08 5:52 PM",
            "commitNameOld": "7f21de32ad92e5fb05489b565baf3c37ae52e86e",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "src/main/java/weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {
                "oldPath": "weka/classifiers/meta/RegressionByDiscretization.java",
                "newPath": "src/main/java/weka/classifiers/meta/RegressionByDiscretization.java"
            }
        },
        "a39d73ed80041530b22fb162803294c6574eb4e8": {
            "type": "Ybodychange",
            "commitMessage": "added serialVersionUID\nadded customized getCapabilities method\nupdated buildClassifier method\ncleaned up imports\nremoved obsolete variables\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@2930 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "19/02/06 2:07 PM",
            "commitName": "a39d73ed80041530b22fb162803294c6574eb4e8",
            "commitAuthor": "fracpete",
            "commitDateOld": "11/11/04 1:44 PM",
            "commitNameOld": "1fb90461720d04eb7404f74c71ff4942fb2c5c83",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 465.02,
            "commitsBetweenForRepo": 537,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,45 +1,48 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n-    if (!instances.classAttribute().isNumeric()) {\n-      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n-    }\n+    // can classifier handle the data?\n+    getCapabilities().testWithFail(instances);\n \n+    // remove instances with missing class\n+    instances = new Instances(instances);\n+    instances.deleteWithMissingClass();\n+    \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tclassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    // can classifier handle the data?\n    getCapabilities().testWithFail(instances);\n\n    // remove instances with missing class\n    instances = new Instances(instances);\n    instances.deleteWithMissingClass();\n    \n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {}
        },
        "568592a70070b68dddbddc4113086fbe51c732f5": {
            "type": "Ybodychange",
            "commitMessage": "Fixed small bugs.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1905 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "18/01/04 7:20 PM",
            "commitName": "568592a70070b68dddbddc4113086fbe51c732f5",
            "commitAuthor": "eibe",
            "commitDateOld": "17/01/04 2:18 PM",
            "commitNameOld": "71d08ab70d5a530d5ea38ee0176a23c7d07a1269",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 1.21,
            "commitsBetweenForRepo": 11,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,45 +1,45 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n-    m_Discretizer.setAttributeIndices(\"\" + instances.classIndex() + 1);\n+    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n     m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tclassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + (instances.classIndex() + 1));\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "5c8ef050d2807d7ce0ba4d0ea768581a98d0f028": {
            "type": "Ybodychange",
            "commitMessage": "More changes related to option handling, tool tips, etc. Small bug fix in SMO (initizliation wasn't correct in special case). Changed RegressionByDiscretization back to old behaviour.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1893 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "17/01/04 1:40 PM",
            "commitName": "5c8ef050d2807d7ce0ba4d0ea768581a98d0f028",
            "commitAuthor": "eibe",
            "commitDateOld": "16/01/04 6:56 PM",
            "commitNameOld": "a2a4517a9e97c19b48375d4f173d68917fc72cbf",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 0.78,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,47 +1,45 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n+    m_Discretizer.setAttributeIndices(\"\" + instances.classIndex() + 1);\n+    m_Discretizer.setBins(getNumBins());\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n-    if (!newTrain.classAttribute().isNominal()) {\n-      throw new UnsupportedClassTypeException (\"Class attribute has to be nominal \" +\n-\t\t\t\t\t       \"after discretization\");\n-    }\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       Instance inst = newTrain.instance(i);\n       if (!inst.classIsMissing()) {\n \tint classVal = (int) inst.classValue();\n \tclassCounts[classVal]++;\n \tm_ClassMeans[classVal] += instances.instance(i).classValue();\n       }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setAttributeIndices(\"\" + instances.classIndex() + 1);\n    m_Discretizer.setBins(getNumBins());\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "45"
        },
        "fae478f6f46df9cf27f2506e9af99854c8e25657": {
            "type": "Ybodychange",
            "commitMessage": "Fixed bug: didn't use to work for datasets with missing class values\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1833 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "19/11/03 2:15 PM",
            "commitName": "fae478f6f46df9cf27f2506e9af99854c8e25657",
            "commitAuthor": "eibe",
            "commitDateOld": "18/11/03 5:03 PM",
            "commitNameOld": "cfa46fea514b8d7fa1d7a15469e89f011a4dea40",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 0.88,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,44 +1,47 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n \n     if (!newTrain.classAttribute().isNominal()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be nominal \" +\n \t\t\t\t\t       \"after discretization\");\n     }\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n-      int classVal = (int) newTrain.instance(i).classValue();\n-      classCounts[classVal]++;\n-      m_ClassMeans[classVal] += instances.instance(i).classValue();\n+      Instance inst = newTrain.instance(i);\n+      if (!inst.classIsMissing()) {\n+\tint classVal = (int) inst.classValue();\n+\tclassCounts[classVal]++;\n+\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n+      }\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Bin Means\");\n       System.out.println(\"==========\");\n       for (int i = 0; i < m_ClassMeans.length; i++) {\n \tSystem.out.println(m_ClassMeans[i]);\n       }\n       System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    if (!newTrain.classAttribute().isNominal()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be nominal \" +\n\t\t\t\t\t       \"after discretization\");\n    }\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      Instance inst = newTrain.instance(i);\n      if (!inst.classIsMissing()) {\n\tint classVal = (int) inst.classValue();\n\tclassCounts[classVal]++;\n\tm_ClassMeans[classVal] += instances.instance(i).classValue();\n      }\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "6aca274366c867c500a2245c768f51084d9f5510": {
            "type": "Ybodychange",
            "commitMessage": "Made it possible for some unsupervised attribute filters to ignore class (or not).\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1830 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "17/11/03 8:45 PM",
            "commitName": "6aca274366c867c500a2245c768f51084d9f5510",
            "commitAuthor": "eibe",
            "commitDateOld": "09/11/03 9:13 PM",
            "commitNameOld": "1fa4acbce12c0397b4f4976f7e4b0ff5b10ea294",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 7.98,
            "commitsBetweenForRepo": 22,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,57 +1,44 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n-    m_Discretizer = new Discretize();\n-    m_Discretizer.setBins(m_NumBins);\n-    if (m_OptimizeBins) {\n-      m_Discretizer.setFindNumBins(true);\n-    }\n-    int classIndex = instances.classIndex();\n-    instances.setClassIndex(-1);\n-    m_Discretizer.setAttributeIndices(\"\"+ (classIndex + 1));\n+    m_Discretizer.setIgnoreClass(true);\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n-    newTrain.setClassIndex(classIndex);\n-    instances.setClassIndex(classIndex);\n+\n+    if (!newTrain.classAttribute().isNominal()) {\n+      throw new UnsupportedClassTypeException (\"Class attribute has to be nominal \" +\n+\t\t\t\t\t       \"after discretization\");\n+    }\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n-      System.out.println(\"Boundaries    Bin Mean\");\n-      System.out.println(\"======================\");\n-      System.out.println(\"-infinity\");\n-      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n-      if (cutPoints != null) {\n-\tfor (int i = 0; i < cutPoints.length; i++) {\n-\t  System.out.println(\"              \" + m_ClassMeans[i]);\n-\t  System.out.println(\"\" + cutPoints[i]);\n-\t}\n-      } else {\n-\tSystem.out.println(\"The class has been discretized into one interval.\");\n+      System.out.println(\"Bin Means\");\n+      System.out.println(\"==========\");\n+      for (int i = 0; i < m_ClassMeans.length; i++) {\n+\tSystem.out.println(m_ClassMeans[i]);\n       }\n-      System.out.println(\"              \" \n-\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n-      System.out.println(\"infinity\");\n+      System.out.println();\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer.setIgnoreClass(true);\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n\n    if (!newTrain.classAttribute().isNominal()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be nominal \" +\n\t\t\t\t\t       \"after discretization\");\n    }\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Bin Means\");\n      System.out.println(\"==========\");\n      for (int i = 0; i < m_ClassMeans.length; i++) {\n\tSystem.out.println(m_ClassMeans[i]);\n      }\n      System.out.println();\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "24"
        },
        "1fa4acbce12c0397b4f4976f7e4b0ff5b10ea294": {
            "type": "Ybodychange",
            "commitMessage": "Fixed a couple of bugs.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1807 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "09/11/03 9:13 PM",
            "commitName": "1fa4acbce12c0397b4f4976f7e4b0ff5b10ea294",
            "commitAuthor": "eibe",
            "commitDateOld": "09/11/03 6:20 PM",
            "commitNameOld": "45f53f0cf34cc36b27f77ca7bb4b768bcd228e29",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 0.12,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,53 +1,57 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer = new Discretize();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n-    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n+    int classIndex = instances.classIndex();\n+    instances.setClassIndex(-1);\n+    m_Discretizer.setAttributeIndices(\"\"+ (classIndex + 1));\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n+    newTrain.setClassIndex(classIndex);\n+    instances.setClassIndex(classIndex);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       } else {\n \tSystem.out.println(\"The class has been discretized into one interval.\");\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer = new Discretize();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    int classIndex = instances.classIndex();\n    instances.setClassIndex(-1);\n    m_Discretizer.setAttributeIndices(\"\"+ (classIndex + 1));\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    newTrain.setClassIndex(classIndex);\n    instances.setClassIndex(classIndex);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      } else {\n\tSystem.out.println(\"The class has been discretized into one interval.\");\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "11aade601b83c87db1e0a1a91604bc70c0714b79": {
            "type": "Ybodychange",
            "commitMessage": "Discretize should skip class if set. Bug fix in debug output for RegressionViaDiscretization.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1789 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "06/11/03 5:40 PM",
            "commitName": "11aade601b83c87db1e0a1a91604bc70c0714b79",
            "commitAuthor": "eibe",
            "commitDateOld": "14/06/02 4:14 AM",
            "commitNameOld": "d1882963ebce8357f47695933e9914db82de48b6",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 510.6,
            "commitsBetweenForRepo": 456,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,51 +1,53 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer = new Discretize();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n+      } else {\n+\tSystem.out.println(\"The class has been discretized into one interval.\");\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer = new Discretize();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      } else {\n\tSystem.out.println(\"The class has been discretized into one interval.\");\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "d1882963ebce8357f47695933e9914db82de48b6": {
            "type": "Ybodychange",
            "commitMessage": "Made changes reflecting new structure of filters package.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1329 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "14/06/02 4:14 AM",
            "commitName": "d1882963ebce8357f47695933e9914db82de48b6",
            "commitAuthor": "eibe",
            "commitDateOld": "10/06/02 9:42 PM",
            "commitNameOld": "723f7909e93c644ee69ae3fced786882ebe97f47",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 3.27,
            "commitsBetweenForRepo": 50,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,52 +1,51 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n-    m_Discretizer = new DiscretizeFilter();\n+    m_Discretizer = new Discretize();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n-    m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer = new Discretize();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "46"
        },
        "723f7909e93c644ee69ae3fced786882ebe97f47": {
            "type": "Ybodychange",
            "commitMessage": "Changes relating to unit tests.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1279 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "10/06/02 9:42 PM",
            "commitName": "723f7909e93c644ee69ae3fced786882ebe97f47",
            "commitAuthor": "eibe",
            "commitDateOld": "06/11/01 8:29 PM",
            "commitNameOld": "fc1c5cb8e72b3d271c46056d48d77f9373a273a7",
            "commitAuthorOld": "rkirkby",
            "daysBetweenCommits": 216.01,
            "commitsBetweenForRepo": 179,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,52 +1,52 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n-      throw new Exception (\"Class attribute has to be numeric\");\n+      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new UnsupportedClassTypeException (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "37"
        },
        "8f9b5d2f48c45f66fc316152559439232c60b7ad": {
            "type": "Ybodychange",
            "commitMessage": "Changed filter use to no longer use deprecated methods\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@942 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "07/02/01 4:10 PM",
            "commitName": "8f9b5d2f48c45f66fc316152559439232c60b7ad",
            "commitAuthor": "trigg",
            "commitDateOld": "11/12/00 7:03 PM",
            "commitNameOld": "34b8a8b0794ac96c787851cefaf9bfa932eb0607",
            "commitAuthorOld": "trigg",
            "daysBetweenCommits": 57.88,
            "commitsBetweenForRepo": 78,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,52 +1,52 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new Exception (\"Class attribute has to be numeric\");\n     }\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n-    m_Discretizer.inputFormat(instances);\n+    m_Discretizer.setInputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new Exception (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.setInputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "36"
        },
        "34b8a8b0794ac96c787851cefaf9bfa932eb0607": {
            "type": "Ybodychange",
            "commitMessage": "Took bodgy pseudo-WeightedInstancesHandler out of these meta classifiers.\nThe right way to do this is to write a WeightedInstancesMetaClassifier and\ngive the user the choice between resampling with/without replacement and\nwith varying sizes of post-resampling data.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@862 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "11/12/00 7:03 PM",
            "commitName": "34b8a8b0794ac96c787851cefaf9bfa932eb0607",
            "commitAuthor": "trigg",
            "commitDateOld": "09/12/00 7:16 PM",
            "commitNameOld": "9810f2803c8cb63a32b90ab900df7dfbb9ad4e4b",
            "commitAuthorOld": "trigg",
            "daysBetweenCommits": 1.99,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,58 +1,52 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new Exception (\"Class attribute has to be numeric\");\n     }\n-    if (m_Classifier instanceof WeightedInstancesHandler) {\n-      instances = new Instances(instances);\n-    } else {\n-      instances = instances.resampleWithWeights(new Random(42));\n-    }\n-    instances.deleteWithMissingClass();\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.inputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new Exception (\"Class attribute has to be numeric\");\n    }\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.inputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "311bf9c87488d5536f0235cf533039a0d3dc9433": {
            "type": "Ybodychange",
            "commitMessage": "Factored out some shared code for resampling with weights defined by the\ninstance weights.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@709 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "18/07/00 10:26 PM",
            "commitName": "311bf9c87488d5536f0235cf533039a0d3dc9433",
            "commitAuthor": "trigg",
            "commitDateOld": "20/01/00 1:11 PM",
            "commitNameOld": "124fb5972b704980c4298eab13e65bf99bd867b2",
            "commitAuthorOld": "trigg",
            "daysBetweenCommits": 180.34,
            "commitsBetweenForRepo": 284,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,58 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new Exception (\"Class attribute has to be numeric\");\n     }\n     if (m_Classifier instanceof WeightedInstancesHandler) {\n       instances = new Instances(instances);\n     } else {\n-      double[] weights = new double[instances.numInstances()];\n-      boolean foundOne = false;\n-      for (int i = 0; i < weights.length; i++) {\n-\tweights[i] = instances.instance(i).weight();\n-\tif (!Utils.eq(weights[i], weights[0])) {\n-\t  foundOne = true;\n-\t}\n-      }\n-      if (foundOne) {\n-\tinstances = instances.resampleWithWeights(new Random(42), weights);\n-      }\n+      instances = instances.resampleWithWeights(new Random(42));\n     }\n     instances.deleteWithMissingClass();\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n       m_Discretizer.setFindNumBins(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.inputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new Exception (\"Class attribute has to be numeric\");\n    }\n    if (m_Classifier instanceof WeightedInstancesHandler) {\n      instances = new Instances(instances);\n    } else {\n      instances = instances.resampleWithWeights(new Random(42));\n    }\n    instances.deleteWithMissingClass();\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.inputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "124fb5972b704980c4298eab13e65bf99bd867b2": {
            "type": "Ybodychange",
            "commitMessage": "- Fixed compilation bug that referenced a removed method of DiscretizationFilter\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@418 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "20/01/00 1:11 PM",
            "commitName": "124fb5972b704980c4298eab13e65bf99bd867b2",
            "commitAuthor": "trigg",
            "commitDateOld": "30/06/99 7:32 PM",
            "commitNameOld": "9bbe8d92f8e5b22b1795aa51190bf1f3ad06699f",
            "commitAuthorOld": "trigg",
            "daysBetweenCommits": 203.78,
            "commitsBetweenForRepo": 273,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,68 +1,68 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new Exception (\"Class attribute has to be numeric\");\n     }\n     if (m_Classifier instanceof WeightedInstancesHandler) {\n       instances = new Instances(instances);\n     } else {\n       double[] weights = new double[instances.numInstances()];\n       boolean foundOne = false;\n       for (int i = 0; i < weights.length; i++) {\n \tweights[i] = instances.instance(i).weight();\n \tif (!Utils.eq(weights[i], weights[0])) {\n \t  foundOne = true;\n \t}\n       }\n       if (foundOne) {\n \tinstances = instances.resampleWithWeights(new Random(42), weights);\n       }\n     }\n     instances.deleteWithMissingClass();\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n     if (m_OptimizeBins) {\n-      m_Discretizer.setOptimizeBinning(true);\n+      m_Discretizer.setFindNumBins(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.inputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new Exception (\"Class attribute has to be numeric\");\n    }\n    if (m_Classifier instanceof WeightedInstancesHandler) {\n      instances = new Instances(instances);\n    } else {\n      double[] weights = new double[instances.numInstances()];\n      boolean foundOne = false;\n      for (int i = 0; i < weights.length; i++) {\n\tweights[i] = instances.instance(i).weight();\n\tif (!Utils.eq(weights[i], weights[0])) {\n\t  foundOne = true;\n\t}\n      }\n      if (foundOne) {\n\tinstances = instances.resampleWithWeights(new Random(42), weights);\n      }\n    }\n    instances.deleteWithMissingClass();\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setFindNumBins(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.inputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "33dac0966616a2f57b29232f9835a2c5d228903a": {
            "type": "Ybodychange",
            "commitMessage": "Cleaned-up decision table and fixed minor bugs.\nUnclassified instances are not printed by Evaluation if zero.\nAdapted MultiClassClassifier to new index-handling in Filters.\nFixed minor bugs in RegressionByDiscretization and Stacking.\nSlightly changed formatting in OneR.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@53 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "28/04/99 9:04 PM",
            "commitName": "33dac0966616a2f57b29232f9835a2c5d228903a",
            "commitAuthor": "eibe",
            "commitDateOld": "19/04/99 11:57 PM",
            "commitNameOld": "2157c7bc9096d5a5c02a15f546fdb2ea40c7f762",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 8.88,
            "commitsBetweenForRepo": 43,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,69 +1,68 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n     if (!instances.classAttribute().isNumeric()) {\n       throw new Exception (\"Class attribute has to be numeric\");\n     }\n-    \n     if (m_Classifier instanceof WeightedInstancesHandler) {\n       instances = new Instances(instances);\n     } else {\n       double[] weights = new double[instances.numInstances()];\n       boolean foundOne = false;\n       for (int i = 0; i < weights.length; i++) {\n \tweights[i] = instances.instance(i).weight();\n \tif (!Utils.eq(weights[i], weights[0])) {\n \t  foundOne = true;\n \t}\n       }\n       if (foundOne) {\n \tinstances = instances.resampleWithWeights(new Random(42), weights);\n       }\n     }\n     instances.deleteWithMissingClass();\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n-    if (b_OptimizeBins) {\n+    if (m_OptimizeBins) {\n       m_Discretizer.setOptimizeBinning(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.inputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n-    if (b_Debug) {\n+    if (m_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new Exception (\"Class attribute has to be numeric\");\n    }\n    if (m_Classifier instanceof WeightedInstancesHandler) {\n      instances = new Instances(instances);\n    } else {\n      double[] weights = new double[instances.numInstances()];\n      boolean foundOne = false;\n      for (int i = 0; i < weights.length; i++) {\n\tweights[i] = instances.instance(i).weight();\n\tif (!Utils.eq(weights[i], weights[0])) {\n\t  foundOne = true;\n\t}\n      }\n      if (foundOne) {\n\tinstances = instances.resampleWithWeights(new Random(42), weights);\n      }\n    }\n    instances.deleteWithMissingClass();\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (m_OptimizeBins) {\n      m_Discretizer.setOptimizeBinning(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.inputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (m_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "24"
        },
        "2157c7bc9096d5a5c02a15f546fdb2ea40c7f762": {
            "type": "Ybodychange",
            "commitMessage": "Handling of string attributes.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@9 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "19/04/99 11:57 PM",
            "commitName": "2157c7bc9096d5a5c02a15f546fdb2ea40c7f762",
            "commitAuthor": "eibe",
            "commitDateOld": "19/04/99 9:31 PM",
            "commitNameOld": "adcb488b1d5d2db27298ccb0a5c98ccc557dc1d6",
            "commitAuthorOld": "ml",
            "daysBetweenCommits": 0.1,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,63 +1,69 @@\n   public void buildClassifier(Instances instances) throws Exception {\n \n-    if (instances.numClasses() < 0) {\n-      throw new Exception (\"Dataset has no class attribute\");\n+    if (!instances.classAttribute().isNumeric()) {\n+      throw new Exception (\"Class attribute has to be numeric\");\n     }\n     \n     if (m_Classifier instanceof WeightedInstancesHandler) {\n       instances = new Instances(instances);\n     } else {\n       double[] weights = new double[instances.numInstances()];\n+      boolean foundOne = false;\n       for (int i = 0; i < weights.length; i++) {\n \tweights[i] = instances.instance(i).weight();\n+\tif (!Utils.eq(weights[i], weights[0])) {\n+\t  foundOne = true;\n+\t}\n       }\n-      instances = instances.resampleWithWeights(new Random(42), weights);\n+      if (foundOne) {\n+\tinstances = instances.resampleWithWeights(new Random(42), weights);\n+      }\n     }\n     instances.deleteWithMissingClass();\n \n     // Discretize the training data\n     m_Discretizer = new DiscretizeFilter();\n     m_Discretizer.setBins(m_NumBins);\n     if (b_OptimizeBins) {\n       m_Discretizer.setOptimizeBinning(true);\n     }\n     m_Discretizer.setUseMDL(false);\n     m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n     m_Discretizer.inputFormat(instances);\n     Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n     int numClasses = newTrain.numClasses();\n \n     // Calculate the mean value for each bin of the new class attribute\n     m_ClassMeans = new double [numClasses];\n     int [] classCounts = new int [numClasses];\n     for (int i = 0; i < instances.numInstances(); i++) {\n       int classVal = (int) newTrain.instance(i).classValue();\n       classCounts[classVal]++;\n       m_ClassMeans[classVal] += instances.instance(i).classValue();\n     }\n \n     for (int i = 0; i < numClasses; i++) {\n       if (classCounts[i] > 0) {\n \tm_ClassMeans[i] /= classCounts[i];\n       }\n     }\n \n     if (b_Debug) {\n       System.out.println(\"Boundaries    Bin Mean\");\n       System.out.println(\"======================\");\n       System.out.println(\"-infinity\");\n       double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n       if (cutPoints != null) {\n \tfor (int i = 0; i < cutPoints.length; i++) {\n \t  System.out.println(\"              \" + m_ClassMeans[i]);\n \t  System.out.println(\"\" + cutPoints[i]);\n \t}\n       }\n       System.out.println(\"              \" \n \t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n       System.out.println(\"infinity\");\n     }\n \n     // Train the sub-classifier\n     m_Classifier.buildClassifier(newTrain);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (!instances.classAttribute().isNumeric()) {\n      throw new Exception (\"Class attribute has to be numeric\");\n    }\n    \n    if (m_Classifier instanceof WeightedInstancesHandler) {\n      instances = new Instances(instances);\n    } else {\n      double[] weights = new double[instances.numInstances()];\n      boolean foundOne = false;\n      for (int i = 0; i < weights.length; i++) {\n\tweights[i] = instances.instance(i).weight();\n\tif (!Utils.eq(weights[i], weights[0])) {\n\t  foundOne = true;\n\t}\n      }\n      if (foundOne) {\n\tinstances = instances.resampleWithWeights(new Random(42), weights);\n      }\n    }\n    instances.deleteWithMissingClass();\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (b_OptimizeBins) {\n      m_Discretizer.setOptimizeBinning(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.inputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (b_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "34"
        },
        "adcb488b1d5d2db27298ccb0a5c98ccc557dc1d6": {
            "type": "Yintroduced",
            "commitMessage": "This commit was generated by cvs2svn to compensate for changes in r4,\nwhich included commits to RCS files with non-trunk default branches.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@5 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "19/04/99 9:31 PM",
            "commitName": "adcb488b1d5d2db27298ccb0a5c98ccc557dc1d6",
            "commitAuthor": "ml",
            "diff": "@@ -0,0 +1,63 @@\n+  public void buildClassifier(Instances instances) throws Exception {\n+\n+    if (instances.numClasses() < 0) {\n+      throw new Exception (\"Dataset has no class attribute\");\n+    }\n+    \n+    if (m_Classifier instanceof WeightedInstancesHandler) {\n+      instances = new Instances(instances);\n+    } else {\n+      double[] weights = new double[instances.numInstances()];\n+      for (int i = 0; i < weights.length; i++) {\n+\tweights[i] = instances.instance(i).weight();\n+      }\n+      instances = instances.resampleWithWeights(new Random(42), weights);\n+    }\n+    instances.deleteWithMissingClass();\n+\n+    // Discretize the training data\n+    m_Discretizer = new DiscretizeFilter();\n+    m_Discretizer.setBins(m_NumBins);\n+    if (b_OptimizeBins) {\n+      m_Discretizer.setOptimizeBinning(true);\n+    }\n+    m_Discretizer.setUseMDL(false);\n+    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n+    m_Discretizer.inputFormat(instances);\n+    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n+    int numClasses = newTrain.numClasses();\n+\n+    // Calculate the mean value for each bin of the new class attribute\n+    m_ClassMeans = new double [numClasses];\n+    int [] classCounts = new int [numClasses];\n+    for (int i = 0; i < instances.numInstances(); i++) {\n+      int classVal = (int) newTrain.instance(i).classValue();\n+      classCounts[classVal]++;\n+      m_ClassMeans[classVal] += instances.instance(i).classValue();\n+    }\n+\n+    for (int i = 0; i < numClasses; i++) {\n+      if (classCounts[i] > 0) {\n+\tm_ClassMeans[i] /= classCounts[i];\n+      }\n+    }\n+\n+    if (b_Debug) {\n+      System.out.println(\"Boundaries    Bin Mean\");\n+      System.out.println(\"======================\");\n+      System.out.println(\"-infinity\");\n+      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n+      if (cutPoints != null) {\n+\tfor (int i = 0; i < cutPoints.length; i++) {\n+\t  System.out.println(\"              \" + m_ClassMeans[i]);\n+\t  System.out.println(\"\" + cutPoints[i]);\n+\t}\n+      }\n+      System.out.println(\"              \" \n+\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n+      System.out.println(\"infinity\");\n+    }\n+\n+    // Train the sub-classifier\n+    m_Classifier.buildClassifier(newTrain);\n+  }\n\\ No newline at end of file\n",
            "actualSource": "  public void buildClassifier(Instances instances) throws Exception {\n\n    if (instances.numClasses() < 0) {\n      throw new Exception (\"Dataset has no class attribute\");\n    }\n    \n    if (m_Classifier instanceof WeightedInstancesHandler) {\n      instances = new Instances(instances);\n    } else {\n      double[] weights = new double[instances.numInstances()];\n      for (int i = 0; i < weights.length; i++) {\n\tweights[i] = instances.instance(i).weight();\n      }\n      instances = instances.resampleWithWeights(new Random(42), weights);\n    }\n    instances.deleteWithMissingClass();\n\n    // Discretize the training data\n    m_Discretizer = new DiscretizeFilter();\n    m_Discretizer.setBins(m_NumBins);\n    if (b_OptimizeBins) {\n      m_Discretizer.setOptimizeBinning(true);\n    }\n    m_Discretizer.setUseMDL(false);\n    m_Discretizer.setAttributeIndices(\"\"+ (instances.classIndex() + 1));\n    m_Discretizer.inputFormat(instances);\n    Instances newTrain = Filter.useFilter(instances, m_Discretizer);\n    int numClasses = newTrain.numClasses();\n\n    // Calculate the mean value for each bin of the new class attribute\n    m_ClassMeans = new double [numClasses];\n    int [] classCounts = new int [numClasses];\n    for (int i = 0; i < instances.numInstances(); i++) {\n      int classVal = (int) newTrain.instance(i).classValue();\n      classCounts[classVal]++;\n      m_ClassMeans[classVal] += instances.instance(i).classValue();\n    }\n\n    for (int i = 0; i < numClasses; i++) {\n      if (classCounts[i] > 0) {\n\tm_ClassMeans[i] /= classCounts[i];\n      }\n    }\n\n    if (b_Debug) {\n      System.out.println(\"Boundaries    Bin Mean\");\n      System.out.println(\"======================\");\n      System.out.println(\"-infinity\");\n      double [] cutPoints = m_Discretizer.getCutPoints(instances.classIndex());\n      if (cutPoints != null) {\n\tfor (int i = 0; i < cutPoints.length; i++) {\n\t  System.out.println(\"              \" + m_ClassMeans[i]);\n\t  System.out.println(\"\" + cutPoints[i]);\n\t}\n      }\n      System.out.println(\"              \" \n\t\t\t + m_ClassMeans[m_ClassMeans.length - 1]);\n      System.out.println(\"infinity\");\n    }\n\n    // Train the sub-classifier\n    m_Classifier.buildClassifier(newTrain);\n  }",
            "path": "weka/classifiers/meta/RegressionByDiscretization.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "29140.json"
}