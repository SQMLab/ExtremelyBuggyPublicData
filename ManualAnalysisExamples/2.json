{
    "origin": "codeshovel",
    "repositoryName": "weka",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/weka/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "GreedyStepwise.java",
    "functionName": "search",
    "functionId": "search___ASEval-ASEvaluation__data-Instances",
    "sourceFilePath": "weka/src/main/java/weka/attributeSelection/GreedyStepwise.java",
    "functionStartLine": 732,
    "functionEndLine": 938,
    "numCommitsSeen": 18,
    "timeTaken": 1448,
    "changeHistory": [
        "4928ba5ed3325319a802283ef1cc3ac9b7a4c5fd",
        "cc0615a3932a7fa5eacda9e6ceb32ed7d250e3a6",
        "21159d08f834ee2be66225f7dca42325816ab1a0",
        "386afb5805cd5e1a7392d165e9df25976b7f338b",
        "14ce15d0aff347f01bf59614f20bb4490cc8314e",
        "61fa15857450b34e83066b4ec86a510daaa10200",
        "b436fbd2e07c809bb5d4e8a2cf9b48225509e206",
        "dc751b322597afdd67ad28acbbce74759c6e6bec",
        "6b84b2c0f478354852f98dafb14888911a9a7653",
        "8a4355b90d29aafc5418f896448a019b142febcc"
    ],
    "changeHistoryShort": {
        "8a4355b90d29aafc5418f896448a019b142febcc": "Ybodychange",
        "6b84b2c0f478354852f98dafb14888911a9a7653": "Ybodychange",
        "dc751b322597afdd67ad28acbbce74759c6e6bec": "Ybodychange",
        "b436fbd2e07c809bb5d4e8a2cf9b48225509e206": "Yfilerename",
        "61fa15857450b34e83066b4ec86a510daaa10200": "Yfilerename",
        "14ce15d0aff347f01bf59614f20bb4490cc8314e": "Ybodychange",
        "386afb5805cd5e1a7392d165e9df25976b7f338b": "Ybodychange",
        "21159d08f834ee2be66225f7dca42325816ab1a0": "Ybodychange",
        "cc0615a3932a7fa5eacda9e6ceb32ed7d250e3a6": "Ybodychange",
        "4928ba5ed3325319a802283ef1cc3ac9b7a4c5fd": "Yintroduced"
    },
    "changeHistoryDetails": {
        "8a4355b90d29aafc5418f896448a019b142febcc": {
            "type": "Ybodychange",
            "commitMessage": "Was holding a reference to the training data - fixed.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@11227 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "16/10/14 1:43 PM",
            "commitName": "8a4355b90d29aafc5418f896448a019b142febcc",
            "commitAuthor": "mhall",
            "commitDateOld": "14/11/13 7:31 PM",
            "commitNameOld": "fae17590e64d424f98574c0756ea5ea31037b076",
            "commitAuthorOld": "eibe",
            "daysBetweenCommits": 335.72,
            "commitsBetweenForRepo": 668,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,206 +1,207 @@\n   public int[] search(ASEvaluation ASEval, Instances data) throws Exception {\n \n     int i;\n     double best_merit = -Double.MAX_VALUE;\n     double temp_best, temp_merit;\n     int temp_index = 0;\n     BitSet temp_group;\n     boolean parallel = (m_poolSize > 1);\n     if (parallel) {\n       m_pool = Executors.newFixedThreadPool(m_poolSize);\n     }\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n-      m_Instances = data;\n+      m_Instances = new Instances(data, 0);\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n       throw new Exception(m_ASEval.getClass().getName() + \" is not a \"\n         + \"Subset evaluator!\");\n     }\n \n     m_startRange.setUpper(m_numAttribs - 1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n     } else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n     final SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n     if (m_starting != null && m_rankedSoFar <= 0) {\n       for (i = 0; i < m_starting.length; i++) {\n         if ((m_starting[i]) != m_classIndex) {\n           m_best_group.set(m_starting[i]);\n         }\n       }\n     } else {\n       if (m_backward && m_rankedSoFar <= 0) {\n         for (i = 0; i < m_numAttribs; i++) {\n           if (i != m_classIndex) {\n             m_best_group.set(i);\n           }\n         }\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n \n     if (m_debug && parallel) {\n       System.err.println(\"Evaluating subsets in parallel...\");\n     }\n     while (!done) {\n       List<Future<Double[]>> results = new ArrayList<Future<Double[]>>();\n       temp_group = (BitSet) m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n         temp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n       for (i = 0; i < m_numAttribs; i++) {\n         if (m_backward) {\n           z = ((i != m_classIndex) && (temp_group.get(i)));\n         } else {\n           z = ((i != m_classIndex) && (!temp_group.get(i)));\n         }\n         if (z) {\n           // set/unset the bit\n           if (m_backward) {\n             temp_group.clear(i);\n           } else {\n             temp_group.set(i);\n           }\n \n           if (parallel) {\n             final BitSet tempCopy = (BitSet) temp_group.clone();\n             final int attBeingEvaluated = i;\n \n             // make a copy if the evaluator is not thread safe\n-            final SubsetEvaluator theEvaluator = (ASEvaluator instanceof weka.core.ThreadSafe) ? ASEvaluator\n-              : (SubsetEvaluator) ASEvaluation.makeCopies(m_ASEval, 1)[0];\n+            final SubsetEvaluator theEvaluator =\n+              (ASEvaluator instanceof weka.core.ThreadSafe) ? ASEvaluator\n+                : (SubsetEvaluator) ASEvaluation.makeCopies(m_ASEval, 1)[0];\n \n             Future<Double[]> future = m_pool.submit(new Callable<Double[]>() {\n               @Override\n               public Double[] call() throws Exception {\n                 Double[] r = new Double[2];\n                 double e = theEvaluator.evaluateSubset(tempCopy);\n                 r[0] = new Double(attBeingEvaluated);\n                 r[1] = e;\n                 return r;\n               }\n             });\n \n             results.add(future);\n           } else {\n             temp_merit = ASEvaluator.evaluateSubset(temp_group);\n             if (m_backward) {\n               z = (temp_merit >= temp_best);\n             } else {\n               if (m_conservativeSelection) {\n                 z = (temp_merit >= temp_best);\n               } else {\n                 z = (temp_merit > temp_best);\n               }\n             }\n \n             if (z) {\n               temp_best = temp_merit;\n               temp_index = i;\n               addone = true;\n               done = false;\n             }\n           }\n \n           // unset this addition/deletion\n           if (m_backward) {\n             temp_group.set(i);\n           } else {\n             temp_group.clear(i);\n           }\n           if (m_doRank) {\n             done = false;\n           }\n         }\n       }\n \n       if (parallel) {\n         for (int j = 0; j < results.size(); j++) {\n           Future<Double[]> f = results.get(j);\n \n           int index = f.get()[0].intValue();\n           temp_merit = f.get()[1].doubleValue();\n \n           if (m_backward) {\n             z = (temp_merit >= temp_best);\n           } else {\n             if (m_conservativeSelection) {\n               z = (temp_merit >= temp_best);\n             } else {\n               z = (temp_merit > temp_best);\n             }\n           }\n \n           if (z) {\n             temp_best = temp_merit;\n             temp_index = index;\n             addone = true;\n             done = false;\n           }\n         }\n       }\n \n       if (addone) {\n         if (m_backward) {\n           m_best_group.clear(temp_index);\n         } else {\n           m_best_group.set(temp_index);\n         }\n         best_merit = temp_best;\n         if (m_debug) {\n           System.err.print(\"Best subset found so far: \");\n           int[] atts = attributeList(m_best_group);\n           for (int a : atts) {\n             System.err.print(\"\" + (a + 1) + \" \");\n           }\n           System.err.println(\"\\nMerit: \" + best_merit);\n         }\n         m_rankedAtts[m_rankedSoFar][0] = temp_index;\n         m_rankedAtts[m_rankedSoFar][1] = best_merit;\n         m_rankedSoFar++;\n       }\n     }\n \n     if (parallel) {\n       m_pool.shutdown();\n     }\n \n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search(ASEvaluation ASEval, Instances data) throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best, temp_merit;\n    int temp_index = 0;\n    BitSet temp_group;\n    boolean parallel = (m_poolSize > 1);\n    if (parallel) {\n      m_pool = Executors.newFixedThreadPool(m_poolSize);\n    }\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = new Instances(data, 0);\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw new Exception(m_ASEval.getClass().getName() + \" is not a \"\n        + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs - 1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    } else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    final SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null && m_rankedSoFar <= 0) {\n      for (i = 0; i < m_starting.length; i++) {\n        if ((m_starting[i]) != m_classIndex) {\n          m_best_group.set(m_starting[i]);\n        }\n      }\n    } else {\n      if (m_backward && m_rankedSoFar <= 0) {\n        for (i = 0; i < m_numAttribs; i++) {\n          if (i != m_classIndex) {\n            m_best_group.set(i);\n          }\n        }\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n\n    if (m_debug && parallel) {\n      System.err.println(\"Evaluating subsets in parallel...\");\n    }\n    while (!done) {\n      List<Future<Double[]>> results = new ArrayList<Future<Double[]>>();\n      temp_group = (BitSet) m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n        temp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i = 0; i < m_numAttribs; i++) {\n        if (m_backward) {\n          z = ((i != m_classIndex) && (temp_group.get(i)));\n        } else {\n          z = ((i != m_classIndex) && (!temp_group.get(i)));\n        }\n        if (z) {\n          // set/unset the bit\n          if (m_backward) {\n            temp_group.clear(i);\n          } else {\n            temp_group.set(i);\n          }\n\n          if (parallel) {\n            final BitSet tempCopy = (BitSet) temp_group.clone();\n            final int attBeingEvaluated = i;\n\n            // make a copy if the evaluator is not thread safe\n            final SubsetEvaluator theEvaluator =\n              (ASEvaluator instanceof weka.core.ThreadSafe) ? ASEvaluator\n                : (SubsetEvaluator) ASEvaluation.makeCopies(m_ASEval, 1)[0];\n\n            Future<Double[]> future = m_pool.submit(new Callable<Double[]>() {\n              @Override\n              public Double[] call() throws Exception {\n                Double[] r = new Double[2];\n                double e = theEvaluator.evaluateSubset(tempCopy);\n                r[0] = new Double(attBeingEvaluated);\n                r[1] = e;\n                return r;\n              }\n            });\n\n            results.add(future);\n          } else {\n            temp_merit = ASEvaluator.evaluateSubset(temp_group);\n            if (m_backward) {\n              z = (temp_merit >= temp_best);\n            } else {\n              if (m_conservativeSelection) {\n                z = (temp_merit >= temp_best);\n              } else {\n                z = (temp_merit > temp_best);\n              }\n            }\n\n            if (z) {\n              temp_best = temp_merit;\n              temp_index = i;\n              addone = true;\n              done = false;\n            }\n          }\n\n          // unset this addition/deletion\n          if (m_backward) {\n            temp_group.set(i);\n          } else {\n            temp_group.clear(i);\n          }\n          if (m_doRank) {\n            done = false;\n          }\n        }\n      }\n\n      if (parallel) {\n        for (int j = 0; j < results.size(); j++) {\n          Future<Double[]> f = results.get(j);\n\n          int index = f.get()[0].intValue();\n          temp_merit = f.get()[1].doubleValue();\n\n          if (m_backward) {\n            z = (temp_merit >= temp_best);\n          } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n          }\n\n          if (z) {\n            temp_best = temp_merit;\n            temp_index = index;\n            addone = true;\n            done = false;\n          }\n        }\n      }\n\n      if (addone) {\n        if (m_backward) {\n          m_best_group.clear(temp_index);\n        } else {\n          m_best_group.set(temp_index);\n        }\n        best_merit = temp_best;\n        if (m_debug) {\n          System.err.print(\"Best subset found so far: \");\n          int[] atts = attributeList(m_best_group);\n          for (int a : atts) {\n            System.err.print(\"\" + (a + 1) + \" \");\n          }\n          System.err.println(\"\\nMerit: \" + best_merit);\n        }\n        m_rankedAtts[m_rankedSoFar][0] = temp_index;\n        m_rankedAtts[m_rankedSoFar][1] = best_merit;\n        m_rankedSoFar++;\n      }\n    }\n\n    if (parallel) {\n      m_pool.shutdown();\n    }\n\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/src/main/java/weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {}
        },
        "6b84b2c0f478354852f98dafb14888911a9a7653": {
            "type": "Ybodychange",
            "commitMessage": "Added options to allow subsets to be evaluated in parallel during the search.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@9848 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "02/07/13 7:47 PM",
            "commitName": "6b84b2c0f478354852f98dafb14888911a9a7653",
            "commitAuthor": "mhall",
            "commitDateOld": "19/06/13 7:37 PM",
            "commitNameOld": "dc751b322597afdd67ad28acbbce74759c6e6bec",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 13.01,
            "commitsBetweenForRepo": 53,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,142 +1,206 @@\n   public int[] search(ASEvaluation ASEval, Instances data) throws Exception {\n \n     int i;\n     double best_merit = -Double.MAX_VALUE;\n     double temp_best, temp_merit;\n     int temp_index = 0;\n     BitSet temp_group;\n+    boolean parallel = (m_poolSize > 1);\n+    if (parallel) {\n+      m_pool = Executors.newFixedThreadPool(m_poolSize);\n+    }\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n       m_Instances = data;\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n       throw new Exception(m_ASEval.getClass().getName() + \" is not a \"\n           + \"Subset evaluator!\");\n     }\n \n     m_startRange.setUpper(m_numAttribs - 1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n     } else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n-    SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n+    final SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n     if (m_starting != null && m_rankedSoFar <= 0) {\n       for (i = 0; i < m_starting.length; i++) {\n         if ((m_starting[i]) != m_classIndex) {\n           m_best_group.set(m_starting[i]);\n         }\n       }\n     } else {\n       if (m_backward && m_rankedSoFar <= 0) {\n         for (i = 0; i < m_numAttribs; i++) {\n           if (i != m_classIndex) {\n             m_best_group.set(i);\n           }\n         }\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n+\n+    if (m_debug && parallel) {\n+      System.err.println(\"Evaluating subsets in parallel...\");\n+    }\n     while (!done) {\n+      List<Future<Double[]>> results = new ArrayList<Future<Double[]>>();\n       temp_group = (BitSet) m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n         temp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n       for (i = 0; i < m_numAttribs; i++) {\n         if (m_backward) {\n           z = ((i != m_classIndex) && (temp_group.get(i)));\n         } else {\n           z = ((i != m_classIndex) && (!temp_group.get(i)));\n         }\n         if (z) {\n           // set/unset the bit\n           if (m_backward) {\n             temp_group.clear(i);\n           } else {\n             temp_group.set(i);\n           }\n-          temp_merit = ASEvaluator.evaluateSubset(temp_group);\n-          if (m_backward) {\n-            z = (temp_merit >= temp_best);\n+\n+          if (parallel) {\n+            final BitSet tempCopy = (BitSet) temp_group.clone();\n+            final int attBeingEvaluated = i;\n+\n+            // make a copy if the evaluator is not thread safe\n+            final SubsetEvaluator theEvaluator = (ASEvaluator instanceof weka.core.ThreadSafe) ? ASEvaluator\n+                : (SubsetEvaluator) ASEvaluation.makeCopies(m_ASEval, 1)[0];\n+\n+            Future<Double[]> future = m_pool.submit(new Callable<Double[]>() {\n+              @Override\n+              public Double[] call() throws Exception {\n+                Double[] r = new Double[2];\n+                double e = theEvaluator.evaluateSubset(tempCopy);\n+                r[0] = new Double(attBeingEvaluated);\n+                r[1] = e;\n+                return r;\n+              }\n+            });\n+\n+            results.add(future);\n           } else {\n-            if (m_conservativeSelection) {\n+            temp_merit = ASEvaluator.evaluateSubset(temp_group);\n+            if (m_backward) {\n               z = (temp_merit >= temp_best);\n             } else {\n-              z = (temp_merit > temp_best);\n+              if (m_conservativeSelection) {\n+                z = (temp_merit >= temp_best);\n+              } else {\n+                z = (temp_merit > temp_best);\n+              }\n             }\n-          }\n \n-          if (z) {\n-            temp_best = temp_merit;\n-            temp_index = i;\n-            addone = true;\n-            done = false;\n+            if (z) {\n+              temp_best = temp_merit;\n+              temp_index = i;\n+              addone = true;\n+              done = false;\n+            }\n           }\n \n           // unset this addition/deletion\n           if (m_backward) {\n             temp_group.set(i);\n           } else {\n             temp_group.clear(i);\n           }\n           if (m_doRank) {\n             done = false;\n           }\n         }\n       }\n+\n+      if (parallel) {\n+        for (int j = 0; j < results.size(); j++) {\n+          Future<Double[]> f = results.get(j);\n+\n+          int index = f.get()[0].intValue();\n+          temp_merit = f.get()[1].doubleValue();\n+\n+          if (m_backward) {\n+            z = (temp_merit >= temp_best);\n+          } else {\n+            if (m_conservativeSelection) {\n+              z = (temp_merit >= temp_best);\n+            } else {\n+              z = (temp_merit > temp_best);\n+            }\n+          }\n+\n+          if (z) {\n+            temp_best = temp_merit;\n+            temp_index = index;\n+            addone = true;\n+            done = false;\n+          }\n+        }\n+      }\n+\n       if (addone) {\n         if (m_backward) {\n           m_best_group.clear(temp_index);\n         } else {\n           m_best_group.set(temp_index);\n         }\n         best_merit = temp_best;\n         if (m_debug) {\n           System.err.print(\"Best subset found so far: \");\n           int[] atts = attributeList(m_best_group);\n           for (int a : atts) {\n             System.err.print(\"\" + (a + 1) + \" \");\n           }\n           System.err.println(\"\\nMerit: \" + best_merit);\n         }\n         m_rankedAtts[m_rankedSoFar][0] = temp_index;\n         m_rankedAtts[m_rankedSoFar][1] = best_merit;\n         m_rankedSoFar++;\n       }\n     }\n+\n+    if (parallel) {\n+      m_pool.shutdown();\n+    }\n+\n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search(ASEvaluation ASEval, Instances data) throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best, temp_merit;\n    int temp_index = 0;\n    BitSet temp_group;\n    boolean parallel = (m_poolSize > 1);\n    if (parallel) {\n      m_pool = Executors.newFixedThreadPool(m_poolSize);\n    }\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw new Exception(m_ASEval.getClass().getName() + \" is not a \"\n          + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs - 1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    } else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    final SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null && m_rankedSoFar <= 0) {\n      for (i = 0; i < m_starting.length; i++) {\n        if ((m_starting[i]) != m_classIndex) {\n          m_best_group.set(m_starting[i]);\n        }\n      }\n    } else {\n      if (m_backward && m_rankedSoFar <= 0) {\n        for (i = 0; i < m_numAttribs; i++) {\n          if (i != m_classIndex) {\n            m_best_group.set(i);\n          }\n        }\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n\n    if (m_debug && parallel) {\n      System.err.println(\"Evaluating subsets in parallel...\");\n    }\n    while (!done) {\n      List<Future<Double[]>> results = new ArrayList<Future<Double[]>>();\n      temp_group = (BitSet) m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n        temp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i = 0; i < m_numAttribs; i++) {\n        if (m_backward) {\n          z = ((i != m_classIndex) && (temp_group.get(i)));\n        } else {\n          z = ((i != m_classIndex) && (!temp_group.get(i)));\n        }\n        if (z) {\n          // set/unset the bit\n          if (m_backward) {\n            temp_group.clear(i);\n          } else {\n            temp_group.set(i);\n          }\n\n          if (parallel) {\n            final BitSet tempCopy = (BitSet) temp_group.clone();\n            final int attBeingEvaluated = i;\n\n            // make a copy if the evaluator is not thread safe\n            final SubsetEvaluator theEvaluator = (ASEvaluator instanceof weka.core.ThreadSafe) ? ASEvaluator\n                : (SubsetEvaluator) ASEvaluation.makeCopies(m_ASEval, 1)[0];\n\n            Future<Double[]> future = m_pool.submit(new Callable<Double[]>() {\n              @Override\n              public Double[] call() throws Exception {\n                Double[] r = new Double[2];\n                double e = theEvaluator.evaluateSubset(tempCopy);\n                r[0] = new Double(attBeingEvaluated);\n                r[1] = e;\n                return r;\n              }\n            });\n\n            results.add(future);\n          } else {\n            temp_merit = ASEvaluator.evaluateSubset(temp_group);\n            if (m_backward) {\n              z = (temp_merit >= temp_best);\n            } else {\n              if (m_conservativeSelection) {\n                z = (temp_merit >= temp_best);\n              } else {\n                z = (temp_merit > temp_best);\n              }\n            }\n\n            if (z) {\n              temp_best = temp_merit;\n              temp_index = i;\n              addone = true;\n              done = false;\n            }\n          }\n\n          // unset this addition/deletion\n          if (m_backward) {\n            temp_group.set(i);\n          } else {\n            temp_group.clear(i);\n          }\n          if (m_doRank) {\n            done = false;\n          }\n        }\n      }\n\n      if (parallel) {\n        for (int j = 0; j < results.size(); j++) {\n          Future<Double[]> f = results.get(j);\n\n          int index = f.get()[0].intValue();\n          temp_merit = f.get()[1].doubleValue();\n\n          if (m_backward) {\n            z = (temp_merit >= temp_best);\n          } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n          }\n\n          if (z) {\n            temp_best = temp_merit;\n            temp_index = index;\n            addone = true;\n            done = false;\n          }\n        }\n      }\n\n      if (addone) {\n        if (m_backward) {\n          m_best_group.clear(temp_index);\n        } else {\n          m_best_group.set(temp_index);\n        }\n        best_merit = temp_best;\n        if (m_debug) {\n          System.err.print(\"Best subset found so far: \");\n          int[] atts = attributeList(m_best_group);\n          for (int a : atts) {\n            System.err.print(\"\" + (a + 1) + \" \");\n          }\n          System.err.println(\"\\nMerit: \" + best_merit);\n        }\n        m_rankedAtts[m_rankedSoFar][0] = temp_index;\n        m_rankedAtts[m_rankedSoFar][1] = best_merit;\n        m_rankedSoFar++;\n      }\n    }\n\n    if (parallel) {\n      m_pool.shutdown();\n    }\n\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/src/main/java/weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {}
        },
        "dc751b322597afdd67ad28acbbce74759c6e6bec": {
            "type": "Ybodychange",
            "commitMessage": "Added an option to output debugging info to the console - basically progress info.\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@9773 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "19/06/13 7:37 PM",
            "commitName": "dc751b322597afdd67ad28acbbce74759c6e6bec",
            "commitAuthor": "mhall",
            "commitDateOld": "14/02/12 5:12 PM",
            "commitNameOld": "12ec9a03c8ee092c55491694e0dfba623bc2de6b",
            "commitAuthorOld": "fracpete",
            "daysBetweenCommits": 491.06,
            "commitsBetweenForRepo": 1016,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,137 +1,142 @@\n-  public int[] search (ASEvaluation ASEval, Instances data)\n-    throws Exception {\n+  public int[] search(ASEvaluation ASEval, Instances data) throws Exception {\n \n     int i;\n     double best_merit = -Double.MAX_VALUE;\n-    double temp_best,temp_merit;\n-    int temp_index=0;\n+    double temp_best, temp_merit;\n+    int temp_index = 0;\n     BitSet temp_group;\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n       m_Instances = data;\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n-      throw  new Exception(m_ASEval.getClass().getName() \n-\t\t\t   + \" is not a \" \n-\t\t\t   + \"Subset evaluator!\");\n+      throw new Exception(m_ASEval.getClass().getName() + \" is not a \"\n+          + \"Subset evaluator!\");\n     }\n \n-    m_startRange.setUpper(m_numAttribs-1);\n+    m_startRange.setUpper(m_numAttribs - 1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n-    }\n-    else {\n+    } else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n-    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n+    SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n     if (m_starting != null && m_rankedSoFar <= 0) {\n       for (i = 0; i < m_starting.length; i++) {\n-\tif ((m_starting[i]) != m_classIndex) {\n-\t  m_best_group.set(m_starting[i]);\n-\t}\n+        if ((m_starting[i]) != m_classIndex) {\n+          m_best_group.set(m_starting[i]);\n+        }\n       }\n     } else {\n       if (m_backward && m_rankedSoFar <= 0) {\n-\tfor (i = 0; i < m_numAttribs; i++) {\n-\t  if (i != m_classIndex) {\n-\t    m_best_group.set(i);\n-\t  }\n-\t}\n+        for (i = 0; i < m_numAttribs; i++) {\n+          if (i != m_classIndex) {\n+            m_best_group.set(i);\n+          }\n+        }\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n     while (!done) {\n-      temp_group = (BitSet)m_best_group.clone();\n+      temp_group = (BitSet) m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n-\ttemp_best = -Double.MAX_VALUE;\n+        temp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n-      for (i=0;i<m_numAttribs;i++) {\n-\tif (m_backward) {\n-\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n-\t} else {\n-\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n-\t}\n-\tif (z) {\n-\t  // set/unset the bit\n-\t  if (m_backward) {\n-\t    temp_group.clear(i);\n-\t  } else {\n-\t    temp_group.set(i);\n-\t  }\n-\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n-\t  if (m_backward) {\n-\t    z = (temp_merit >= temp_best);\n-\t  } else {\n+      for (i = 0; i < m_numAttribs; i++) {\n+        if (m_backward) {\n+          z = ((i != m_classIndex) && (temp_group.get(i)));\n+        } else {\n+          z = ((i != m_classIndex) && (!temp_group.get(i)));\n+        }\n+        if (z) {\n+          // set/unset the bit\n+          if (m_backward) {\n+            temp_group.clear(i);\n+          } else {\n+            temp_group.set(i);\n+          }\n+          temp_merit = ASEvaluator.evaluateSubset(temp_group);\n+          if (m_backward) {\n+            z = (temp_merit >= temp_best);\n+          } else {\n             if (m_conservativeSelection) {\n               z = (temp_merit >= temp_best);\n             } else {\n               z = (temp_merit > temp_best);\n             }\n-\t  }\n+          }\n \n-\t  if (z) {\n+          if (z) {\n             temp_best = temp_merit;\n             temp_index = i;\n             addone = true;\n             done = false;\n-\t  }\n+          }\n \n-\t  // unset this addition/deletion\n-\t  if (m_backward) {\n-\t    temp_group.set(i);\n-\t  } else {\n-\t    temp_group.clear(i);\n-\t  }\n-\t  if (m_doRank) {\n-\t    done = false;\n-\t  }\n-\t}\n+          // unset this addition/deletion\n+          if (m_backward) {\n+            temp_group.set(i);\n+          } else {\n+            temp_group.clear(i);\n+          }\n+          if (m_doRank) {\n+            done = false;\n+          }\n+        }\n       }\n       if (addone) {\n-\tif (m_backward) {\n-\t  m_best_group.clear(temp_index);\n-\t} else {\n-\t  m_best_group.set(temp_index);\n-\t}\n-\tbest_merit = temp_best;\n-\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n-\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n-\tm_rankedSoFar++;\n+        if (m_backward) {\n+          m_best_group.clear(temp_index);\n+        } else {\n+          m_best_group.set(temp_index);\n+        }\n+        best_merit = temp_best;\n+        if (m_debug) {\n+          System.err.print(\"Best subset found so far: \");\n+          int[] atts = attributeList(m_best_group);\n+          for (int a : atts) {\n+            System.err.print(\"\" + (a + 1) + \" \");\n+          }\n+          System.err.println(\"\\nMerit: \" + best_merit);\n+        }\n+        m_rankedAtts[m_rankedSoFar][0] = temp_index;\n+        m_rankedAtts[m_rankedSoFar][1] = best_merit;\n+        m_rankedSoFar++;\n       }\n     }\n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search(ASEvaluation ASEval, Instances data) throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best, temp_merit;\n    int temp_index = 0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw new Exception(m_ASEval.getClass().getName() + \" is not a \"\n          + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs - 1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    } else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator) m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null && m_rankedSoFar <= 0) {\n      for (i = 0; i < m_starting.length; i++) {\n        if ((m_starting[i]) != m_classIndex) {\n          m_best_group.set(m_starting[i]);\n        }\n      }\n    } else {\n      if (m_backward && m_rankedSoFar <= 0) {\n        for (i = 0; i < m_numAttribs; i++) {\n          if (i != m_classIndex) {\n            m_best_group.set(i);\n          }\n        }\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet) m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n        temp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i = 0; i < m_numAttribs; i++) {\n        if (m_backward) {\n          z = ((i != m_classIndex) && (temp_group.get(i)));\n        } else {\n          z = ((i != m_classIndex) && (!temp_group.get(i)));\n        }\n        if (z) {\n          // set/unset the bit\n          if (m_backward) {\n            temp_group.clear(i);\n          } else {\n            temp_group.set(i);\n          }\n          temp_merit = ASEvaluator.evaluateSubset(temp_group);\n          if (m_backward) {\n            z = (temp_merit >= temp_best);\n          } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n          }\n\n          if (z) {\n            temp_best = temp_merit;\n            temp_index = i;\n            addone = true;\n            done = false;\n          }\n\n          // unset this addition/deletion\n          if (m_backward) {\n            temp_group.set(i);\n          } else {\n            temp_group.clear(i);\n          }\n          if (m_doRank) {\n            done = false;\n          }\n        }\n      }\n      if (addone) {\n        if (m_backward) {\n          m_best_group.clear(temp_index);\n        } else {\n          m_best_group.set(temp_index);\n        }\n        best_merit = temp_best;\n        if (m_debug) {\n          System.err.print(\"Best subset found so far: \");\n          int[] atts = attributeList(m_best_group);\n          for (int a : atts) {\n            System.err.print(\"\" + (a + 1) + \" \");\n          }\n          System.err.println(\"\\nMerit: \" + best_merit);\n        }\n        m_rankedAtts[m_rankedSoFar][0] = temp_index;\n        m_rankedAtts[m_rankedSoFar][1] = best_merit;\n        m_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/src/main/java/weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {}
        },
        "b436fbd2e07c809bb5d4e8a2cf9b48225509e206": {
            "type": "Yfilerename",
            "commitMessage": "Move out of top level\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@4698 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "13/11/08 2:39 PM",
            "commitName": "b436fbd2e07c809bb5d4e8a2cf9b48225509e206",
            "commitAuthor": "mhall",
            "commitDateOld": "13/11/08 2:38 PM",
            "commitNameOld": "f200e45530b3f65a829297fea7955d3f0a98ce39",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null && m_rankedSoFar <= 0) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward && m_rankedSoFar <= 0) {\n\tfor (i = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n\t  }\n\n\t  if (z) {\n            temp_best = temp_merit;\n            temp_index = i;\n            addone = true;\n            done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/src/main/java/weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {
                "oldPath": "src/main/java/weka/attributeSelection/GreedyStepwise.java",
                "newPath": "weka/src/main/java/weka/attributeSelection/GreedyStepwise.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        },
        "61fa15857450b34e83066b4ec86a510daaa10200": {
            "type": "Yfilerename",
            "commitMessage": "Moving to new structure\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@4662 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "12/11/08 5:55 PM",
            "commitName": "61fa15857450b34e83066b4ec86a510daaa10200",
            "commitAuthor": "mhall",
            "commitDateOld": "12/11/08 5:52 PM",
            "commitNameOld": "7f21de32ad92e5fb05489b565baf3c37ae52e86e",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null && m_rankedSoFar <= 0) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward && m_rankedSoFar <= 0) {\n\tfor (i = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n\t  }\n\n\t  if (z) {\n            temp_best = temp_merit;\n            temp_index = i;\n            addone = true;\n            done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "src/main/java/weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {
                "oldPath": "weka/attributeSelection/GreedyStepwise.java",
                "newPath": "src/main/java/weka/attributeSelection/GreedyStepwise.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        },
        "14ce15d0aff347f01bf59614f20bb4490cc8314e": {
            "type": "Ybodychange",
            "commitMessage": "Fixed bug that caused array out of bounds when producing a ranked list of attributes from a backwards search.\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@3639 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "23/11/06 4:41 PM",
            "commitName": "14ce15d0aff347f01bf59614f20bb4490cc8314e",
            "commitAuthor": "mhall",
            "commitDateOld": "02/03/06 5:31 PM",
            "commitNameOld": "386afb5805cd5e1a7392d165e9df25976b7f338b",
            "commitAuthorOld": "fracpete",
            "daysBetweenCommits": 265.97,
            "commitsBetweenForRepo": 577,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,136 +1,137 @@\n   public int[] search (ASEvaluation ASEval, Instances data)\n     throws Exception {\n \n     int i;\n     double best_merit = -Double.MAX_VALUE;\n     double temp_best,temp_merit;\n     int temp_index=0;\n     BitSet temp_group;\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n       m_Instances = data;\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n       throw  new Exception(m_ASEval.getClass().getName() \n \t\t\t   + \" is not a \" \n \t\t\t   + \"Subset evaluator!\");\n     }\n \n     m_startRange.setUpper(m_numAttribs-1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n     }\n     else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n     SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n-    if (m_starting != null) {\n+    if (m_starting != null && m_rankedSoFar <= 0) {\n       for (i = 0; i < m_starting.length; i++) {\n \tif ((m_starting[i]) != m_classIndex) {\n \t  m_best_group.set(m_starting[i]);\n \t}\n       }\n     } else {\n-      if (m_backward) {\n+      if (m_backward && m_rankedSoFar <= 0) {\n \tfor (i = 0; i < m_numAttribs; i++) {\n \t  if (i != m_classIndex) {\n \t    m_best_group.set(i);\n \t  }\n \t}\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n     while (!done) {\n       temp_group = (BitSet)m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n \ttemp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n       for (i=0;i<m_numAttribs;i++) {\n \tif (m_backward) {\n \t  z = ((i != m_classIndex) && (temp_group.get(i)));\n \t} else {\n \t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n \t}\n \tif (z) {\n \t  // set/unset the bit\n \t  if (m_backward) {\n \t    temp_group.clear(i);\n \t  } else {\n \t    temp_group.set(i);\n \t  }\n \t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n \t  if (m_backward) {\n \t    z = (temp_merit >= temp_best);\n \t  } else {\n             if (m_conservativeSelection) {\n               z = (temp_merit >= temp_best);\n             } else {\n               z = (temp_merit > temp_best);\n             }\n \t  }\n+\n \t  if (z) {\n             temp_best = temp_merit;\n             temp_index = i;\n             addone = true;\n             done = false;\n \t  }\n \n \t  // unset this addition/deletion\n \t  if (m_backward) {\n \t    temp_group.set(i);\n \t  } else {\n \t    temp_group.clear(i);\n \t  }\n \t  if (m_doRank) {\n \t    done = false;\n \t  }\n \t}\n       }\n       if (addone) {\n \tif (m_backward) {\n \t  m_best_group.clear(temp_index);\n \t} else {\n \t  m_best_group.set(temp_index);\n \t}\n \tbest_merit = temp_best;\n \tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n \tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n \tm_rankedSoFar++;\n       }\n     }\n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null && m_rankedSoFar <= 0) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward && m_rankedSoFar <= 0) {\n\tfor (i = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n\t  }\n\n\t  if (z) {\n            temp_best = temp_merit;\n            temp_index = i;\n            addone = true;\n            done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "386afb5805cd5e1a7392d165e9df25976b7f338b": {
            "type": "Ybodychange",
            "commitMessage": "automated Javadoc generation (globalInfo, options)\nadded TechnicalInformation-handling where possible\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@3003 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "02/03/06 5:31 PM",
            "commitName": "386afb5805cd5e1a7392d165e9df25976b7f338b",
            "commitAuthor": "fracpete",
            "commitDateOld": "06/12/05 7:50 PM",
            "commitNameOld": "21159d08f834ee2be66225f7dca42325816ab1a0",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 85.9,
            "commitsBetweenForRepo": 151,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,136 +1,136 @@\n   public int[] search (ASEvaluation ASEval, Instances data)\n     throws Exception {\n \n-    int i, j;\n+    int i;\n     double best_merit = -Double.MAX_VALUE;\n     double temp_best,temp_merit;\n     int temp_index=0;\n     BitSet temp_group;\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n       m_Instances = data;\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n       throw  new Exception(m_ASEval.getClass().getName() \n \t\t\t   + \" is not a \" \n \t\t\t   + \"Subset evaluator!\");\n     }\n \n     m_startRange.setUpper(m_numAttribs-1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n     }\n     else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n     SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n     if (m_starting != null) {\n       for (i = 0; i < m_starting.length; i++) {\n \tif ((m_starting[i]) != m_classIndex) {\n \t  m_best_group.set(m_starting[i]);\n \t}\n       }\n     } else {\n       if (m_backward) {\n-\tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n+\tfor (i = 0; i < m_numAttribs; i++) {\n \t  if (i != m_classIndex) {\n \t    m_best_group.set(i);\n \t  }\n \t}\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n     while (!done) {\n       temp_group = (BitSet)m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n \ttemp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n       for (i=0;i<m_numAttribs;i++) {\n \tif (m_backward) {\n \t  z = ((i != m_classIndex) && (temp_group.get(i)));\n \t} else {\n \t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n \t}\n \tif (z) {\n \t  // set/unset the bit\n \t  if (m_backward) {\n \t    temp_group.clear(i);\n \t  } else {\n \t    temp_group.set(i);\n \t  }\n \t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n \t  if (m_backward) {\n \t    z = (temp_merit >= temp_best);\n \t  } else {\n             if (m_conservativeSelection) {\n               z = (temp_merit >= temp_best);\n             } else {\n               z = (temp_merit > temp_best);\n             }\n \t  }\n \t  if (z) {\n             temp_best = temp_merit;\n             temp_index = i;\n             addone = true;\n             done = false;\n \t  }\n \n \t  // unset this addition/deletion\n \t  if (m_backward) {\n \t    temp_group.set(i);\n \t  } else {\n \t    temp_group.clear(i);\n \t  }\n \t  if (m_doRank) {\n \t    done = false;\n \t  }\n \t}\n       }\n       if (addone) {\n \tif (m_backward) {\n \t  m_best_group.clear(temp_index);\n \t} else {\n \t  m_best_group.set(temp_index);\n \t}\n \tbest_merit = temp_best;\n \tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n \tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n \tm_rankedSoFar++;\n       }\n     }\n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward) {\n\tfor (i = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n\t  }\n\t  if (z) {\n            temp_best = temp_merit;\n            temp_index = i;\n            addone = true;\n            done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "28"
        },
        "21159d08f834ee2be66225f7dca42325816ab1a0": {
            "type": "Ybodychange",
            "commitMessage": "Now includes an option for conservative selection in forward mode (i.e. will continue to add attributes as long as the merit does not decrease).\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@2839 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "06/12/05 7:50 PM",
            "commitName": "21159d08f834ee2be66225f7dca42325816ab1a0",
            "commitAuthor": "mhall",
            "commitDateOld": "07/06/05 6:35 PM",
            "commitNameOld": "0030bb44fecac7efa4d630e1c7218a57a649399f",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 182.09,
            "commitsBetweenForRepo": 289,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,132 +1,136 @@\n   public int[] search (ASEvaluation ASEval, Instances data)\n     throws Exception {\n \n     int i, j;\n     double best_merit = -Double.MAX_VALUE;\n     double temp_best,temp_merit;\n     int temp_index=0;\n     BitSet temp_group;\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n       m_Instances = data;\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n       throw  new Exception(m_ASEval.getClass().getName() \n \t\t\t   + \" is not a \" \n \t\t\t   + \"Subset evaluator!\");\n     }\n \n     m_startRange.setUpper(m_numAttribs-1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n     }\n     else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n     SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n     if (m_starting != null) {\n       for (i = 0; i < m_starting.length; i++) {\n \tif ((m_starting[i]) != m_classIndex) {\n \t  m_best_group.set(m_starting[i]);\n \t}\n       }\n     } else {\n       if (m_backward) {\n \tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n \t  if (i != m_classIndex) {\n \t    m_best_group.set(i);\n \t  }\n \t}\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n     while (!done) {\n       temp_group = (BitSet)m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n \ttemp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n       for (i=0;i<m_numAttribs;i++) {\n \tif (m_backward) {\n \t  z = ((i != m_classIndex) && (temp_group.get(i)));\n \t} else {\n \t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n \t}\n \tif (z) {\n \t  // set/unset the bit\n \t  if (m_backward) {\n \t    temp_group.clear(i);\n \t  } else {\n \t    temp_group.set(i);\n \t  }\n \t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n \t  if (m_backward) {\n \t    z = (temp_merit >= temp_best);\n \t  } else {\n-\t    z = (temp_merit > temp_best);\n+            if (m_conservativeSelection) {\n+              z = (temp_merit >= temp_best);\n+            } else {\n+              z = (temp_merit > temp_best);\n+            }\n \t  }\n \t  if (z) {\n-\t    temp_best = temp_merit;\n-\t    temp_index = i;\n-\t    addone = true;\n-\t    done = false;\n+            temp_best = temp_merit;\n+            temp_index = i;\n+            addone = true;\n+            done = false;\n \t  }\n \n \t  // unset this addition/deletion\n \t  if (m_backward) {\n \t    temp_group.set(i);\n \t  } else {\n \t    temp_group.clear(i);\n \t  }\n \t  if (m_doRank) {\n \t    done = false;\n \t  }\n \t}\n       }\n       if (addone) {\n \tif (m_backward) {\n \t  m_best_group.clear(temp_index);\n \t} else {\n \t  m_best_group.set(temp_index);\n \t}\n \tbest_merit = temp_best;\n \tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n \tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n \tm_rankedSoFar++;\n       }\n     }\n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i, j;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward) {\n\tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n            if (m_conservativeSelection) {\n              z = (temp_merit >= temp_best);\n            } else {\n              z = (temp_merit > temp_best);\n            }\n\t  }\n\t  if (z) {\n            temp_best = temp_merit;\n            temp_index = i;\n            addone = true;\n            done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "7"
        },
        "cc0615a3932a7fa5eacda9e6ceb32ed7d250e3a6": {
            "type": "Ybodychange",
            "commitMessage": "Fixed bug with start set\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@2002 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "06/04/04 4:21 PM",
            "commitName": "cc0615a3932a7fa5eacda9e6ceb32ed7d250e3a6",
            "commitAuthor": "mhall",
            "commitDateOld": "04/04/04 8:24 PM",
            "commitNameOld": "67c6d4eb6e75650a49ad43c9017983201a5ac45a",
            "commitAuthorOld": "mhall",
            "daysBetweenCommits": 1.83,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,136 +1,132 @@\n   public int[] search (ASEvaluation ASEval, Instances data)\n     throws Exception {\n \n     int i, j;\n     double best_merit = -Double.MAX_VALUE;\n     double temp_best,temp_merit;\n     int temp_index=0;\n     BitSet temp_group;\n \n     if (data != null) { // this is a fresh run so reset\n       resetOptions();\n       m_Instances = data;\n     }\n     m_ASEval = ASEval;\n \n     m_numAttribs = m_Instances.numAttributes();\n \n     if (m_best_group == null) {\n       m_best_group = new BitSet(m_numAttribs);\n     }\n \n     if (!(m_ASEval instanceof SubsetEvaluator)) {\n       throw  new Exception(m_ASEval.getClass().getName() \n \t\t\t   + \" is not a \" \n \t\t\t   + \"Subset evaluator!\");\n     }\n \n     m_startRange.setUpper(m_numAttribs-1);\n     if (!(getStartSet().equals(\"\"))) {\n       m_starting = m_startRange.getSelection();\n     }\n \n     if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n       m_hasClass = false;\n       m_classIndex = -1;\n     }\n     else {\n       m_hasClass = true;\n       m_classIndex = m_Instances.classIndex();\n     }\n \n     SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n \n     if (m_rankedAtts == null) {\n       m_rankedAtts = new double[m_numAttribs][2];\n       m_rankedSoFar = 0;\n     }\n \n     // If a starting subset has been supplied, then initialise the bitset\n     if (m_starting != null) {\n       for (i = 0; i < m_starting.length; i++) {\n \tif ((m_starting[i]) != m_classIndex) {\n \t  m_best_group.set(m_starting[i]);\n \t}\n       }\n     } else {\n       if (m_backward) {\n-\tsetStartSet(\"1-last\");\n-\tm_starting = new int[m_numAttribs];\n-\n \tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n \t  if (i != m_classIndex) {\n \t    m_best_group.set(i);\n-\t    m_starting[j++] = i;\n \t  }\n \t}\n       }\n     }\n \n     // Evaluate the initial subset\n     best_merit = ASEvaluator.evaluateSubset(m_best_group);\n \n     // main search loop\n     boolean done = false;\n     boolean addone = false;\n     boolean z;\n     while (!done) {\n       temp_group = (BitSet)m_best_group.clone();\n       temp_best = best_merit;\n       if (m_doRank) {\n \ttemp_best = -Double.MAX_VALUE;\n       }\n       done = true;\n       addone = false;\n       for (i=0;i<m_numAttribs;i++) {\n \tif (m_backward) {\n \t  z = ((i != m_classIndex) && (temp_group.get(i)));\n \t} else {\n \t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n \t}\n \tif (z) {\n \t  // set/unset the bit\n \t  if (m_backward) {\n \t    temp_group.clear(i);\n \t  } else {\n \t    temp_group.set(i);\n \t  }\n \t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n \t  if (m_backward) {\n \t    z = (temp_merit >= temp_best);\n \t  } else {\n \t    z = (temp_merit > temp_best);\n \t  }\n \t  if (z) {\n \t    temp_best = temp_merit;\n \t    temp_index = i;\n \t    addone = true;\n \t    done = false;\n \t  }\n \n \t  // unset this addition/deletion\n \t  if (m_backward) {\n \t    temp_group.set(i);\n \t  } else {\n \t    temp_group.clear(i);\n \t  }\n \t  if (m_doRank) {\n \t    done = false;\n \t  }\n \t}\n       }\n       if (addone) {\n \tif (m_backward) {\n \t  m_best_group.clear(temp_index);\n \t} else {\n \t  m_best_group.set(temp_index);\n \t}\n \tbest_merit = temp_best;\n \tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n \tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n \tm_rankedSoFar++;\n       }\n     }\n     m_bestMerit = best_merit;\n     return attributeList(m_best_group);\n   }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i, j;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward) {\n\tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n\t    z = (temp_merit > temp_best);\n\t  }\n\t  if (z) {\n\t    temp_best = temp_merit;\n\t    temp_index = i;\n\t    addone = true;\n\t    done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/attributeSelection/GreedyStepwise.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "4928ba5ed3325319a802283ef1cc3ac9b7a4c5fd": {
            "type": "Yintroduced",
            "commitMessage": "Initial import\n\n\ngit-svn-id: https://svn.cms.waikato.ac.nz/svn/weka/trunk@1989 e0a1b77d-ad91-4216-81b1-defd5f83fa92\n",
            "commitDate": "01/04/04 9:01 PM",
            "commitName": "4928ba5ed3325319a802283ef1cc3ac9b7a4c5fd",
            "commitAuthor": "mhall",
            "diff": "@@ -0,0 +1,136 @@\n+  public int[] search (ASEvaluation ASEval, Instances data)\n+    throws Exception {\n+\n+    int i, j;\n+    double best_merit = -Double.MAX_VALUE;\n+    double temp_best,temp_merit;\n+    int temp_index=0;\n+    BitSet temp_group;\n+\n+    if (data != null) { // this is a fresh run so reset\n+      resetOptions();\n+      m_Instances = data;\n+    }\n+    m_ASEval = ASEval;\n+\n+    m_numAttribs = m_Instances.numAttributes();\n+\n+    if (m_best_group == null) {\n+      m_best_group = new BitSet(m_numAttribs);\n+    }\n+\n+    if (!(m_ASEval instanceof SubsetEvaluator)) {\n+      throw  new Exception(m_ASEval.getClass().getName() \n+\t\t\t   + \" is not a \" \n+\t\t\t   + \"Subset evaluator!\");\n+    }\n+\n+    m_startRange.setUpper(m_numAttribs-1);\n+    if (!(getStartSet().equals(\"\"))) {\n+      m_starting = m_startRange.getSelection();\n+    }\n+\n+    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n+      m_hasClass = false;\n+      m_classIndex = -1;\n+    }\n+    else {\n+      m_hasClass = true;\n+      m_classIndex = m_Instances.classIndex();\n+    }\n+\n+    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n+\n+    if (m_rankedAtts == null) {\n+      m_rankedAtts = new double[m_numAttribs][2];\n+      m_rankedSoFar = 0;\n+    }\n+\n+    // If a starting subset has been supplied, then initialise the bitset\n+    if (m_starting != null) {\n+      for (i = 0; i < m_starting.length; i++) {\n+\tif ((m_starting[i]) != m_classIndex) {\n+\t  m_best_group.set(m_starting[i]);\n+\t}\n+      }\n+    } else {\n+      if (m_backward) {\n+\tsetStartSet(\"1-last\");\n+\tm_starting = new int[m_numAttribs];\n+\n+\tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n+\t  if (i != m_classIndex) {\n+\t    m_best_group.set(i);\n+\t    m_starting[j++] = i;\n+\t  }\n+\t}\n+      }\n+    }\n+\n+    // Evaluate the initial subset\n+    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n+\n+    // main search loop\n+    boolean done = false;\n+    boolean addone = false;\n+    boolean z;\n+    while (!done) {\n+      temp_group = (BitSet)m_best_group.clone();\n+      temp_best = best_merit;\n+      if (m_doRank) {\n+\ttemp_best = -Double.MAX_VALUE;\n+      }\n+      done = true;\n+      addone = false;\n+      for (i=0;i<m_numAttribs;i++) {\n+\tif (m_backward) {\n+\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n+\t} else {\n+\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n+\t}\n+\tif (z) {\n+\t  // set/unset the bit\n+\t  if (m_backward) {\n+\t    temp_group.clear(i);\n+\t  } else {\n+\t    temp_group.set(i);\n+\t  }\n+\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n+\t  if (m_backward) {\n+\t    z = (temp_merit >= temp_best);\n+\t  } else {\n+\t    z = (temp_merit > temp_best);\n+\t  }\n+\t  if (z) {\n+\t    temp_best = temp_merit;\n+\t    temp_index = i;\n+\t    addone = true;\n+\t    done = false;\n+\t  }\n+\n+\t  // unset this addition/deletion\n+\t  if (m_backward) {\n+\t    temp_group.set(i);\n+\t  } else {\n+\t    temp_group.clear(i);\n+\t  }\n+\t  if (m_doRank) {\n+\t    done = false;\n+\t  }\n+\t}\n+      }\n+      if (addone) {\n+\tif (m_backward) {\n+\t  m_best_group.clear(temp_index);\n+\t} else {\n+\t  m_best_group.set(temp_index);\n+\t}\n+\tbest_merit = temp_best;\n+\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n+\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n+\tm_rankedSoFar++;\n+      }\n+    }\n+    m_bestMerit = best_merit;\n+    return attributeList(m_best_group);\n+  }\n\\ No newline at end of file\n",
            "actualSource": "  public int[] search (ASEvaluation ASEval, Instances data)\n    throws Exception {\n\n    int i, j;\n    double best_merit = -Double.MAX_VALUE;\n    double temp_best,temp_merit;\n    int temp_index=0;\n    BitSet temp_group;\n\n    if (data != null) { // this is a fresh run so reset\n      resetOptions();\n      m_Instances = data;\n    }\n    m_ASEval = ASEval;\n\n    m_numAttribs = m_Instances.numAttributes();\n\n    if (m_best_group == null) {\n      m_best_group = new BitSet(m_numAttribs);\n    }\n\n    if (!(m_ASEval instanceof SubsetEvaluator)) {\n      throw  new Exception(m_ASEval.getClass().getName() \n\t\t\t   + \" is not a \" \n\t\t\t   + \"Subset evaluator!\");\n    }\n\n    m_startRange.setUpper(m_numAttribs-1);\n    if (!(getStartSet().equals(\"\"))) {\n      m_starting = m_startRange.getSelection();\n    }\n\n    if (m_ASEval instanceof UnsupervisedSubsetEvaluator) {\n      m_hasClass = false;\n      m_classIndex = -1;\n    }\n    else {\n      m_hasClass = true;\n      m_classIndex = m_Instances.classIndex();\n    }\n\n    SubsetEvaluator ASEvaluator = (SubsetEvaluator)m_ASEval;\n\n    if (m_rankedAtts == null) {\n      m_rankedAtts = new double[m_numAttribs][2];\n      m_rankedSoFar = 0;\n    }\n\n    // If a starting subset has been supplied, then initialise the bitset\n    if (m_starting != null) {\n      for (i = 0; i < m_starting.length; i++) {\n\tif ((m_starting[i]) != m_classIndex) {\n\t  m_best_group.set(m_starting[i]);\n\t}\n      }\n    } else {\n      if (m_backward) {\n\tsetStartSet(\"1-last\");\n\tm_starting = new int[m_numAttribs];\n\n\tfor (i = 0, j = 0; i < m_numAttribs; i++) {\n\t  if (i != m_classIndex) {\n\t    m_best_group.set(i);\n\t    m_starting[j++] = i;\n\t  }\n\t}\n      }\n    }\n\n    // Evaluate the initial subset\n    best_merit = ASEvaluator.evaluateSubset(m_best_group);\n\n    // main search loop\n    boolean done = false;\n    boolean addone = false;\n    boolean z;\n    while (!done) {\n      temp_group = (BitSet)m_best_group.clone();\n      temp_best = best_merit;\n      if (m_doRank) {\n\ttemp_best = -Double.MAX_VALUE;\n      }\n      done = true;\n      addone = false;\n      for (i=0;i<m_numAttribs;i++) {\n\tif (m_backward) {\n\t  z = ((i != m_classIndex) && (temp_group.get(i)));\n\t} else {\n\t  z = ((i != m_classIndex) && (!temp_group.get(i)));\n\t}\n\tif (z) {\n\t  // set/unset the bit\n\t  if (m_backward) {\n\t    temp_group.clear(i);\n\t  } else {\n\t    temp_group.set(i);\n\t  }\n\t  temp_merit = ASEvaluator.evaluateSubset(temp_group);\n\t  if (m_backward) {\n\t    z = (temp_merit >= temp_best);\n\t  } else {\n\t    z = (temp_merit > temp_best);\n\t  }\n\t  if (z) {\n\t    temp_best = temp_merit;\n\t    temp_index = i;\n\t    addone = true;\n\t    done = false;\n\t  }\n\n\t  // unset this addition/deletion\n\t  if (m_backward) {\n\t    temp_group.set(i);\n\t  } else {\n\t    temp_group.clear(i);\n\t  }\n\t  if (m_doRank) {\n\t    done = false;\n\t  }\n\t}\n      }\n      if (addone) {\n\tif (m_backward) {\n\t  m_best_group.clear(temp_index);\n\t} else {\n\t  m_best_group.set(temp_index);\n\t}\n\tbest_merit = temp_best;\n\tm_rankedAtts[m_rankedSoFar][0] = temp_index;\n\tm_rankedAtts[m_rankedSoFar][1] = best_merit;\n\tm_rankedSoFar++;\n      }\n    }\n    m_bestMerit = best_merit;\n    return attributeList(m_best_group);\n  }",
            "path": "weka/attributeSelection/GreedyStepwise.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "14683.json"
}