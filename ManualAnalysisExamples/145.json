{
    "origin": "codeshovel",
    "repositoryName": "netty",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/netty/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "HttpObjectDecoder.java",
    "functionName": "readHeaders",
    "functionId": "readHeaders___buffer-ByteBuf",
    "sourceFilePath": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
    "functionStartLine": 557,
    "functionEndLine": 633,
    "numCommitsSeen": 203,
    "timeTaken": 5341,
    "changeHistory": [
        "4ac032c65752d1822ab8e15551a032f05286aece",
        "d4348ab4d75c2db7befbe59b050a98f8a70a27fd",
        "a30c36d8e2ae7ad3ea5d7577c2c1e806e24ad560",
        "df2f9d9d50510eeffdc1e29fce74172edd2beef5",
        "32738273e07e56d755334adaf91795f83474a2d1",
        "2d682dc2a3ecd32a179d4455c1b7a0e675768945",
        "4979cb6a219abc529850c1b451c0b0e221574b1d",
        "4a72aafd567489304824b89d8ab3e0765b76a4d8",
        "c6b707c442b9116b26a99fac16cd067c27628ae2",
        "a979433f918f569a13890bd9f2485385c29690e2",
        "f059f91ff4b6f4f5e556a09dbb41426969da82fb",
        "12acb2cf093c7fde7afcf3297735084628f3574c",
        "aeb7903be8f287e8096d5221092a126019748855",
        "bda2f0a852f01a25211fc3837dcfbd28d4639224",
        "40597002e9d4a3e53f8e19df712a9e5652281ddb",
        "8c39e2823ecdc3c423132971269315e5a73158dd",
        "d0e886c344cb4c5b6f4e05bf0b85d911b371b2e6",
        "1c6813a06d85178c56bae1894a76199b49b3e8a3",
        "7518e9852501ed5cda45f88ce0d3671eeb866631",
        "8663716d38040537f6660cf2b81ee74549e0ab6d",
        "5164d91255a5cd68bcd1fade07e6ef4fdb3c7646",
        "602f976e4111d66b807f9b2c1cbf09a8f245cd01",
        "bbcb035246423895b5ae73c323434784ac7b5245",
        "27dc582e2bb4888f082806756e2181bd463c8db4",
        "d6a0fe54fd866917d2fd7d13894cb7527563f467",
        "b7de868003691e9c72e8995273dfcd20245f680a",
        "34820511ff677667d46c0447f72527a7842dfa42",
        "3b79008eda1315e7515aadaeac7224b4cda073ad",
        "acb28e3ac8d04feffa15cdceaeda1284b3338b7e",
        "05c10fae051163b3b3925ac1bd9b179fc3e3bb00",
        "0052d83db18ce710be65d8a6732c994227bf31fe",
        "faf8becf2e12fdb46ba256c39eedab501ed3cdcb",
        "cf4c464d99f0723d908151c2b4a2b9d2b203061c",
        "a653a8ecf44adb06ec899c5648ead7b01cdc8c42",
        "4ce994dd4fe58a03fa25b0911e5b3a2079b33692",
        "fda8808210c4f4f092a93da5929df43062c3aa6c",
        "35db3c671070aaf5ee8f5cc0e026d3a3574f7f1b",
        "b6a4f5de9d213cdbe32ff7772be4bcf6a1ba9094",
        "506f0d8f8c10e1b24924f7d992a726d7bdd2e486",
        "81f9434ec70136ac2c7277937c3c837cbd7c80d2",
        "85fcf4e58164806645b79239d0e6bf00287e26dc",
        "8494b046ec7e4f28dbd44bc699cc4c4c92251729",
        "629034624626b722128e0fcc6b3ec9d406cb3706"
    ],
    "changeHistoryShort": {
        "629034624626b722128e0fcc6b3ec9d406cb3706": "Ybodychange",
        "8494b046ec7e4f28dbd44bc699cc4c4c92251729": "Ybodychange",
        "85fcf4e58164806645b79239d0e6bf00287e26dc": "Ybodychange",
        "81f9434ec70136ac2c7277937c3c837cbd7c80d2": "Ybodychange",
        "506f0d8f8c10e1b24924f7d992a726d7bdd2e486": "Ybodychange",
        "b6a4f5de9d213cdbe32ff7772be4bcf6a1ba9094": "Ybodychange",
        "35db3c671070aaf5ee8f5cc0e026d3a3574f7f1b": "Ybodychange",
        "fda8808210c4f4f092a93da5929df43062c3aa6c": "Ybodychange",
        "4ce994dd4fe58a03fa25b0911e5b3a2079b33692": "Ybodychange",
        "a653a8ecf44adb06ec899c5648ead7b01cdc8c42": "Ybodychange",
        "cf4c464d99f0723d908151c2b4a2b9d2b203061c": "Ybodychange",
        "faf8becf2e12fdb46ba256c39eedab501ed3cdcb": "Ybodychange",
        "0052d83db18ce710be65d8a6732c994227bf31fe": "Ybodychange",
        "05c10fae051163b3b3925ac1bd9b179fc3e3bb00": "Ybodychange",
        "acb28e3ac8d04feffa15cdceaeda1284b3338b7e": "Ybodychange",
        "3b79008eda1315e7515aadaeac7224b4cda073ad": "Ybodychange",
        "34820511ff677667d46c0447f72527a7842dfa42": "Ybodychange",
        "b7de868003691e9c72e8995273dfcd20245f680a": "Ymultichange(Yfilerename,Ybodychange)",
        "d6a0fe54fd866917d2fd7d13894cb7527563f467": "Yexceptionschange",
        "27dc582e2bb4888f082806756e2181bd463c8db4": "Ybodychange",
        "bbcb035246423895b5ae73c323434784ac7b5245": "Ybodychange",
        "602f976e4111d66b807f9b2c1cbf09a8f245cd01": "Ybodychange",
        "5164d91255a5cd68bcd1fade07e6ef4fdb3c7646": "Yparameterchange",
        "8663716d38040537f6660cf2b81ee74549e0ab6d": "Yfilerename",
        "7518e9852501ed5cda45f88ce0d3671eeb866631": "Yfilerename",
        "1c6813a06d85178c56bae1894a76199b49b3e8a3": "Ybodychange",
        "d0e886c344cb4c5b6f4e05bf0b85d911b371b2e6": "Ybodychange",
        "8c39e2823ecdc3c423132971269315e5a73158dd": "Ybodychange",
        "40597002e9d4a3e53f8e19df712a9e5652281ddb": "Ybodychange",
        "bda2f0a852f01a25211fc3837dcfbd28d4639224": "Ybodychange",
        "aeb7903be8f287e8096d5221092a126019748855": "Ybodychange",
        "12acb2cf093c7fde7afcf3297735084628f3574c": "Ybodychange",
        "f059f91ff4b6f4f5e556a09dbb41426969da82fb": "Ybodychange",
        "a979433f918f569a13890bd9f2485385c29690e2": "Ybodychange",
        "c6b707c442b9116b26a99fac16cd067c27628ae2": "Ybodychange",
        "4a72aafd567489304824b89d8ab3e0765b76a4d8": "Ymultichange(Yexceptionschange,Ybodychange)",
        "4979cb6a219abc529850c1b451c0b0e221574b1d": "Ymultichange(Yreturntypechange,Ybodychange)",
        "2d682dc2a3ecd32a179d4455c1b7a0e675768945": "Ybodychange",
        "32738273e07e56d755334adaf91795f83474a2d1": "Ybodychange",
        "df2f9d9d50510eeffdc1e29fce74172edd2beef5": "Ybodychange",
        "a30c36d8e2ae7ad3ea5d7577c2c1e806e24ad560": "Ybodychange",
        "d4348ab4d75c2db7befbe59b050a98f8a70a27fd": "Ybodychange",
        "4ac032c65752d1822ab8e15551a032f05286aece": "Yintroduced"
    },
    "changeHistoryDetails": {
        "629034624626b722128e0fcc6b3ec9d406cb3706": {
            "type": "Ybodychange",
            "commitMessage": "Remove \"Content-Length\" when decoding HTTP/1.1 message with both \"Tra\u2026 (#10003)\n\nMotivation\r\n\r\nAs part of a recent commit for issue\r\nhttps://github.com/netty/netty/issues/9861 the HttpObjectDecoder was\r\nchanged to throw an IllegalArgumentException (and produce a failed\r\ndecoder result) when decoding a message with both \"Transfer-Encoding:\r\nchunked\" and \"Content-Length\".\r\n\r\nWhile it seems correct for Netty to try to sanitize these types of\r\nmessages, the spec explicitly mentions that the Content-Length header\r\nshould be *removed* in this scenario.\r\n\r\nBoth Nginx 1.15.9 and Tomcat 9.0.31 also opt to remove the header:\r\nhttps://github.com/apache/tomcat/blob/b693d7c1981fa7f51e58bc8c8e72e3fe80b7b773/java/org/apache/coyote/http11/Http11Processor.java#L747-L755\r\nhttps://github.com/nginx/nginx/blob/0ad4393e30c119d250415cb769e3d8bc8dce5186/src/http/ngx_http_request.c#L1946-L1953\r\n\r\nModifications\r\n\r\n* Change the default behavior from throwing an IllegalArgumentException\r\nto removing the \"Content-Length\" header\r\n* Extract the behavior to a new protected method,\r\nhandleChunkedEncodingWithContentLength(), that can be overridden to\r\nchange this behavior (or capture metrics)\r\n\r\nResult\r\n\r\nMessages of this nature will now be successfully decoded and have their\r\n\"Content-Length\" header removed, rather than creating invalid messages\r\n(decoder result failures). Users will be allowed to override and\r\nconfigure this behavior.",
            "commitDate": "10/02/20 1:41 AM",
            "commitName": "629034624626b722128e0fcc6b3ec9d406cb3706",
            "commitAuthor": "Bennett Lynch",
            "commitDateOld": "12/12/19 11:53 PM",
            "commitNameOld": "8494b046ec7e4f28dbd44bc699cc4c4c92251729",
            "commitAuthorOld": "Norman Maurer",
            "daysBetweenCommits": 59.08,
            "commitsBetweenForRepo": 61,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,91 +1,77 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAtUnsafe(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     //please do not make one line from below code\n                     //as it breaks +XX:OptimizeStringConcat optimization\n                     String trimmedLine = line.toString().trim();\n                     String valueStr = String.valueOf(value);\n                     value = valueStr + ' ' + trimmedLine;\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n \n         // reset name and value fields\n         name = null;\n         value = null;\n \n         List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n         int contentLengthValuesCount = values.size();\n \n         if (contentLengthValuesCount > 0) {\n             // Guard against multiple Content-Length headers as stated in\n             // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n             //\n             // If a message is received that has multiple Content-Length header\n             //   fields with field-values consisting of the same decimal value, or a\n             //   single Content-Length header field with a field value containing a\n             //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n             //   indicating that duplicate Content-Length header fields have been\n             //   generated or combined by an upstream message processor, then the\n             //   recipient MUST either reject the message as invalid or replace the\n             //   duplicated field-values with a single valid Content-Length field\n             //   containing that decimal value prior to determining the message body\n             //   length or forwarding the message.\n             if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                 throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n             }\n             contentLength = Long.parseLong(values.get(0));\n         }\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n             return State.SKIP_CONTROL_CHARS;\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n-            // See https://tools.ietf.org/html/rfc7230#section-3.3.3\n-            //\n-            //       If a message is received with both a Transfer-Encoding and a\n-            //       Content-Length header field, the Transfer-Encoding overrides the\n-            //       Content-Length.  Such a message might indicate an attempt to\n-            //       perform request smuggling (Section 9.5) or response splitting\n-            //       (Section 9.4) and ought to be handled as an error.  A sender MUST\n-            //       remove the received Content-Length field prior to forwarding such\n-            //       a message downstream.\n-            //\n-            // This is also what http_parser does:\n-            // https://github.com/nodejs/http-parser/blob/v2.9.2/http_parser.c#L1769\n             if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n-                throw new IllegalArgumentException(\n-                        \"Both 'Content-Length: \" + contentLength + \"' and 'Transfer-Encoding: chunked' found\");\n+                handleTransferEncodingChunkedWithContentLength(message);\n             }\n-\n             return State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             return State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             return State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        int contentLengthValuesCount = values.size();\n\n        if (contentLengthValuesCount > 0) {\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            //\n            // If a message is received that has multiple Content-Length header\n            //   fields with field-values consisting of the same decimal value, or a\n            //   single Content-Length header field with a field value containing a\n            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n            //   indicating that duplicate Content-Length header fields have been\n            //   generated or combined by an upstream message processor, then the\n            //   recipient MUST either reject the message as invalid or replace the\n            //   duplicated field-values with a single valid Content-Length field\n            //   containing that decimal value prior to determining the message body\n            //   length or forwarding the message.\n            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n            }\n            contentLength = Long.parseLong(values.get(0));\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                handleTransferEncodingChunkedWithContentLength(message);\n            }\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "8494b046ec7e4f28dbd44bc699cc4c4c92251729": {
            "type": "Ybodychange",
            "commitMessage": "Verify we do not receive multiple content-length headers or a content-length and transfer-encoding: chunked header when using HTTP/1.1 (#9865)\n\nMotivation:\r\n\r\nRFC7230 states that we should not accept multiple content-length headers and also should not accept a content-length header in combination with transfer-encoding: chunked\r\n\r\nModifications:\r\n\r\n- Check for multiple content-length headers and if found mark message as invalid\r\n- Check if we found a content-length header and also a transfer-encoding: chunked and if so mark the message as invalid\r\n- Add unit test\r\n\r\nResult:\r\n\r\nFixes https://github.com/netty/netty/issues/9861",
            "commitDate": "12/12/19 11:53 PM",
            "commitName": "8494b046ec7e4f28dbd44bc699cc4c4c92251729",
            "commitAuthor": "Norman Maurer",
            "commitDateOld": "11/12/19 6:49 AM",
            "commitNameOld": "a7c18d44b46e02dadfe3da225a06e5091f5f328e",
            "commitAuthorOld": "Norman Maurer",
            "daysBetweenCommits": 1.71,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,53 +1,91 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAtUnsafe(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     //please do not make one line from below code\n                     //as it breaks +XX:OptimizeStringConcat optimization\n                     String trimmedLine = line.toString().trim();\n                     String valueStr = String.valueOf(value);\n                     value = valueStr + ' ' + trimmedLine;\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n+\n         // reset name and value fields\n         name = null;\n         value = null;\n \n-        State nextState;\n+        List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n+        int contentLengthValuesCount = values.size();\n+\n+        if (contentLengthValuesCount > 0) {\n+            // Guard against multiple Content-Length headers as stated in\n+            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n+            //\n+            // If a message is received that has multiple Content-Length header\n+            //   fields with field-values consisting of the same decimal value, or a\n+            //   single Content-Length header field with a field value containing a\n+            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n+            //   indicating that duplicate Content-Length header fields have been\n+            //   generated or combined by an upstream message processor, then the\n+            //   recipient MUST either reject the message as invalid or replace the\n+            //   duplicated field-values with a single valid Content-Length field\n+            //   containing that decimal value prior to determining the message body\n+            //   length or forwarding the message.\n+            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n+                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n+            }\n+            contentLength = Long.parseLong(values.get(0));\n+        }\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n-            nextState = State.SKIP_CONTROL_CHARS;\n+            return State.SKIP_CONTROL_CHARS;\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n-            nextState = State.READ_CHUNK_SIZE;\n+            // See https://tools.ietf.org/html/rfc7230#section-3.3.3\n+            //\n+            //       If a message is received with both a Transfer-Encoding and a\n+            //       Content-Length header field, the Transfer-Encoding overrides the\n+            //       Content-Length.  Such a message might indicate an attempt to\n+            //       perform request smuggling (Section 9.5) or response splitting\n+            //       (Section 9.4) and ought to be handled as an error.  A sender MUST\n+            //       remove the received Content-Length field prior to forwarding such\n+            //       a message downstream.\n+            //\n+            // This is also what http_parser does:\n+            // https://github.com/nodejs/http-parser/blob/v2.9.2/http_parser.c#L1769\n+            if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n+                throw new IllegalArgumentException(\n+                        \"Both 'Content-Length: \" + contentLength + \"' and 'Transfer-Encoding: chunked' found\");\n+            }\n+\n+            return State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n-            nextState = State.READ_FIXED_LENGTH_CONTENT;\n+            return State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n-            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n+            return State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n-        return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        List<String> values = headers.getAll(HttpHeaderNames.CONTENT_LENGTH);\n        int contentLengthValuesCount = values.size();\n\n        if (contentLengthValuesCount > 0) {\n            // Guard against multiple Content-Length headers as stated in\n            // https://tools.ietf.org/html/rfc7230#section-3.3.2:\n            //\n            // If a message is received that has multiple Content-Length header\n            //   fields with field-values consisting of the same decimal value, or a\n            //   single Content-Length header field with a field value containing a\n            //   list of identical decimal values (e.g., \"Content-Length: 42, 42\"),\n            //   indicating that duplicate Content-Length header fields have been\n            //   generated or combined by an upstream message processor, then the\n            //   recipient MUST either reject the message as invalid or replace the\n            //   duplicated field-values with a single valid Content-Length field\n            //   containing that decimal value prior to determining the message body\n            //   length or forwarding the message.\n            if (contentLengthValuesCount > 1 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\"Multiple Content-Length headers found\");\n            }\n            contentLength = Long.parseLong(values.get(0));\n        }\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            return State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            // See https://tools.ietf.org/html/rfc7230#section-3.3.3\n            //\n            //       If a message is received with both a Transfer-Encoding and a\n            //       Content-Length header field, the Transfer-Encoding overrides the\n            //       Content-Length.  Such a message might indicate an attempt to\n            //       perform request smuggling (Section 9.5) or response splitting\n            //       (Section 9.4) and ought to be handled as an error.  A sender MUST\n            //       remove the received Content-Length field prior to forwarding such\n            //       a message downstream.\n            //\n            // This is also what http_parser does:\n            // https://github.com/nodejs/http-parser/blob/v2.9.2/http_parser.c#L1769\n            if (contentLengthValuesCount > 0 && message.protocolVersion() == HttpVersion.HTTP_1_1) {\n                throw new IllegalArgumentException(\n                        \"Both 'Content-Length: \" + contentLength + \"' and 'Transfer-Encoding: chunked' found\");\n            }\n\n            return State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            return State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            return State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "85fcf4e58164806645b79239d0e6bf00287e26dc": {
            "type": "Ybodychange",
            "commitMessage": "Use `AppendableCharSequence.charAtUnsafe(int)` in `HttpObjectDecoder` (#9492)\n\nMotivation:\r\n\r\n`HttpObjectDecoder` pre-checks that it doesn't request characters\r\noutside of the `AppendableCharSequence`'s length. `0` is always allowed\r\nbecause the minimal length of `AppendableCharSequence` is `1`. We can\r\nlegally skip index check by using\r\n`AppendableCharSequence.charAtUnsafe(int)` in all existing cases in\r\n`HttpObjectDecoder`.\r\n\r\nModifications:\r\n\r\n- Use `AppendableCharSequence.charAtUnsafe(int)` instead of\r\n`AppendableCharSequence.charAt(int)` in `HttpObjectDecoder`.\r\n\r\nResult:\r\n\r\nNo unnecessary index checks in `HttpObjectDecoder`.",
            "commitDate": "22/08/19 4:58 AM",
            "commitName": "85fcf4e58164806645b79239d0e6bf00287e26dc",
            "commitAuthor": "Idel Pivnitskiy",
            "commitDateOld": "04/02/19 7:01 AM",
            "commitNameOld": "4c64c98f348131e0792ba4a92ce3d0003237d56a",
            "commitAuthorOld": "\u7530\u6b27",
            "daysBetweenCommits": 198.87,
            "commitsBetweenForRepo": 310,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,53 +1,53 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n-                char firstChar = line.charAt(0);\n+                char firstChar = line.charAtUnsafe(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     //please do not make one line from below code\n                     //as it breaks +XX:OptimizeStringConcat optimization\n                     String trimmedLine = line.toString().trim();\n                     String valueStr = String.valueOf(value);\n                     value = valueStr + ' ' + trimmedLine;\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAtUnsafe(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "81f9434ec70136ac2c7277937c3c837cbd7c80d2": {
            "type": "Ybodychange",
            "commitMessage": "Added test for multi header, HttpObjectDecoder performance improvement for multi header, removed empty else block.\n\nMotivation:\n\nFor multi-line headers HttpObjectDecoder uses StringBuilder.append(a).append(b) pattern that could be easily replaced with regular a + b. Also oparations with a and b moved out from concat operation to make it friendly for StringOptimizeConcat optimization and thus - faster.\n\nModification:\n\nStringBuilder.append(a).append(b) reaplced with a + b. Operations with a and b moved out from concat oparation.\n\nResult:\nCode simpler to read and faster.\n",
            "commitDate": "19/06/17 10:11 PM",
            "commitName": "81f9434ec70136ac2c7277937c3c837cbd7c80d2",
            "commitAuthor": "Dmitriy Dumanskiy",
            "commitDateOld": "28/03/17 2:58 AM",
            "commitNameOld": "71b338ce17036bcb448c6c73e9a35b4971254733",
            "commitAuthorOld": "cdn",
            "daysBetweenCommits": 83.8,
            "commitsBetweenForRepo": 161,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,54 +1,53 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n+                    //please do not make one line from below code\n+                    //as it breaks +XX:OptimizeStringConcat optimization\n                     String trimmedLine = line.toString().trim();\n-                    StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);\n-                    buf.append(value)\n-                       .append(' ')\n-                       .append(trimmedLine);\n-                    value = buf.toString();\n+                    String valueStr = String.valueOf(value);\n+                    value = valueStr + ' ' + trimmedLine;\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    //please do not make one line from below code\n                    //as it breaks +XX:OptimizeStringConcat optimization\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "506f0d8f8c10e1b24924f7d992a726d7bdd2e486": {
            "type": "Ybodychange",
            "commitMessage": "Cleanup : String.length() == 0 replaced with String.isEmpty, removed unnecessary assert, class cast\n",
            "commitDate": "14/02/17 6:36 AM",
            "commitName": "506f0d8f8c10e1b24924f7d992a726d7bdd2e486",
            "commitAuthor": "Dmitriy Dumanskiy",
            "commitDateOld": "22/09/16 10:58 AM",
            "commitNameOld": "dd1ba2a2521dca5f25bbe34314a8d66fe462b053",
            "commitAuthorOld": "Scott Mitchell",
            "daysBetweenCommits": 144.86,
            "commitsBetweenForRepo": 256,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,53 +1,54 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n-                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n+                    String trimmedLine = line.toString().trim();\n+                    StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);\n                     buf.append(value)\n                        .append(' ')\n-                       .append(line.toString().trim());\n+                       .append(trimmedLine);\n                     value = buf.toString();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    StringBuilder buf = new StringBuilder(value.length() + trimmedLine.length() + 1);\n                    buf.append(value)\n                       .append(' ')\n                       .append(trimmedLine);\n                    value = buf.toString();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "b6a4f5de9d213cdbe32ff7772be4bcf6a1ba9094": {
            "type": "Ybodychange",
            "commitMessage": "Refactor of HttpUtil and HttpHeaderUtil\n\nMotivation:\nThere currently exists http.HttpUtil, http2.HttpUtil, and http.HttpHeaderUtil. Having 2 HttpUtil methods can be confusing and the utilty methods in the http package could be consolidated.\n\nModifications:\n- Rename http2.HttpUtil to http2.HttpConversionUtil\n- Move http.HttpHeaderUtil methods into http.HttpUtil\n\nResult:\nConsolidated utilities whose names don't overlap.\nFixes https://github.com/netty/netty/issues/4120\n",
            "commitDate": "27/08/15 8:49 AM",
            "commitName": "b6a4f5de9d213cdbe32ff7772be4bcf6a1ba9094",
            "commitAuthor": "Scott Mitchell",
            "commitDateOld": "20/08/15 10:28 PM",
            "commitNameOld": "50b97689285003618dc8b7c43365eb4cda0ffc1d",
            "commitAuthorOld": "Norman Maurer",
            "daysBetweenCommits": 6.43,
            "commitsBetweenForRepo": 17,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,53 +1,53 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                     buf.append(value)\n                        .append(' ')\n                        .append(line.toString().trim());\n                     value = buf.toString();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n-            HttpHeaderUtil.setTransferEncodingChunked(message, false);\n+            HttpUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n+        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                    buf.append(value)\n                       .append(' ')\n                       .append(line.toString().trim());\n                    value = buf.toString();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "35db3c671070aaf5ee8f5cc0e026d3a3574f7f1b": {
            "type": "Ybodychange",
            "commitMessage": "Small performance improvements\n\nMotivation:\n\nFound performance issues via FindBugs and PMD.\n\nModifications:\n\n- Removed unnecessary boxing/unboxing operations in DefaultTextHeaders.convertToInt(CharSequence) and DefaultTextHeaders.convertToLong(CharSequence). A boxed primitive is created from a string, just to extract the unboxed primitive value.\n- Added a static modifier for DefaultHttp2Connection.ParentChangedEvent class. This class is an inner class, but does not use its embedded reference to the object which created it. This reference makes the instances of the class larger, and may keep the reference to the creator object alive longer than necessary.\n- Added a static compiled Pattern to avoid compile it each time it is used when we need to replace some part of authority.\n- Improved using of StringBuilders.\n\nResult:\n\nPerformance improvements.\n",
            "commitDate": "19/11/14 9:10 PM",
            "commitName": "35db3c671070aaf5ee8f5cc0e026d3a3574f7f1b",
            "commitAuthor": "Idel Pivnitskiy",
            "commitDateOld": "12/11/14 5:29 AM",
            "commitNameOld": "fda8808210c4f4f092a93da5929df43062c3aa6c",
            "commitAuthorOld": "Idel Pivnitskiy",
            "daysBetweenCommits": 7.65,
            "commitsBetweenForRepo": 7,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,53 +1,53 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line == null) {\n             return null;\n         }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n-                    buf.append(value);\n-                    buf.append(' ');\n-                    buf.append(line.toString().trim());\n+                    buf.append(value)\n+                       .append(' ')\n+                       .append(line.toString().trim());\n                     value = buf.toString();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n                 if (line == null) {\n                     return null;\n                 }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaderUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                    buf.append(value)\n                       .append(' ')\n                       .append(line.toString().trim());\n                    value = buf.toString();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaderUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "fda8808210c4f4f092a93da5929df43062c3aa6c": {
            "type": "Ybodychange",
            "commitMessage": "Rewrite HttpObjectDecoder to make use of proper state machine\n\nMotivation:\n\nHttpObjectDecoder extended ReplayDecoder which is slightly slower then ByteToMessageDecoder.\n\nModifications:\n\n- Changed super class of HttpObjectDecoder from ReplayDecoder to ByteToMessageDecoder.\n- Rewrote decode() method of HttpObjectDecoder to use proper state machine.\n- Changed private methods HeaderParser.parse(ByteBuf), readHeaders(ByteBuf) and readTrailingHeaders(ByteBuf), skipControlCharacters(ByteBuf) to consider available bytes.\n- Set HeaderParser and LineParser as static inner classes.\n- Replaced not safe actualReadableBytes() with buffer.readableBytes().\n\nResult:\n\nImproved performance of HttpObjectDecoder by approximately 177%.\n",
            "commitDate": "12/11/14 5:29 AM",
            "commitName": "fda8808210c4f4f092a93da5929df43062c3aa6c",
            "commitAuthor": "Idel Pivnitskiy",
            "commitDateOld": "31/10/14 9:00 AM",
            "commitNameOld": "4ce994dd4fe58a03fa25b0911e5b3a2079b33692",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 11.89,
            "commitsBetweenForRepo": 7,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,47 +1,53 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n+        if (line == null) {\n+            return null;\n+        }\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                     buf.append(value);\n                     buf.append(' ');\n                     buf.append(line.toString().trim());\n                     value = buf.toString();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n+                if (line == null) {\n+                    return null;\n+                }\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaderUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                    buf.append(value);\n                    buf.append(' ');\n                    buf.append(line.toString().trim());\n                    value = buf.toString();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaderUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "4ce994dd4fe58a03fa25b0911e5b3a2079b33692": {
            "type": "Ybodychange",
            "commitMessage": "Fix backward compatibility from the previous backport\n\nMotivation:\n\nThe commit 50e06442c3f2753c9b2a506f68ea70273b829e21 changed the type of\nthe constants in HttpHeaders.Names and HttpHeaders.Values, making 4.1\nbackward-incompatible with 4.0.\n\nIt also introduces newer utility classes such as HttpHeaderUtil, which\ndeprecates most static methods in HttpHeaders.  To ease the migration\nbetween 4.1 and 5.0, we should deprecate all static methods that are\nnon-existent in 5.0, and provide proper counterpart.\n\nModification:\n\n- Revert the changes in HttpHeaders.Names and Values\n- Deprecate all static methods in HttpHeaders in favor of:\n  - HttpHeaderUtil\n  - the member methods of HttpHeaders\n  - AsciiString\n- Add integer and date access methods to HttpHeaders for easier future\n  migration to 5.0\n- Add HttpHeaderNames and HttpHeaderValues which provide standard HTTP\n  constants in AsciiString\n  - Deprecate HttpHeaders.Names and Values\n  - Make HttpHeaderValues.WEBSOCKET lowercased because it's actually\n    lowercased in all WebSocket versions but the oldest one\n- Add RtspHeaderNames and RtspHeaderValues which provide standard RTSP\n  constants in AsciiString\n  - Deprecate RtspHeaders.*\n- Do not use AsciiString.equalsIgnoreCase(CharSeq, CharSeq) if one of\n  the parameters are AsciiString\n- Avoid using AsciiString.toString() repetitively\n  - Change the parameter type of some methods from String to\n    CharSequence\n\nResult:\n\nBackward compatibility is recovered.  New classes and methods will make\nthe migration to 5.0 easier, once (Http|Rtsp)Header(Names|Values) are\nported to master.\n",
            "commitDate": "31/10/14 9:00 AM",
            "commitName": "4ce994dd4fe58a03fa25b0911e5b3a2079b33692",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "31/10/14 8:59 AM",
            "commitNameOld": "50e06442c3f2753c9b2a506f68ea70273b829e21",
            "commitAuthorOld": "Scott Mitchell",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,47 +1,47 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                     buf.append(value);\n                     buf.append(' ');\n                     buf.append(line.toString().trim());\n                     value = buf.toString();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n-            HttpHeaders.removeTransferEncodingChunked(message);\n+            HttpHeaderUtil.setTransferEncodingChunked(message, false);\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n+        } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                    buf.append(value);\n                    buf.append(' ');\n                    buf.append(line.toString().trim());\n                    value = buf.toString();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaderUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaderUtil.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "a653a8ecf44adb06ec899c5648ead7b01cdc8c42": {
            "type": "Ybodychange",
            "commitMessage": "Overall cleanup of cf4c464d99f0723d908151c2b4a2b9d2b203061c\n",
            "commitDate": "25/10/14 12:56 AM",
            "commitName": "a653a8ecf44adb06ec899c5648ead7b01cdc8c42",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "25/10/14 12:53 AM",
            "commitNameOld": "cf4c464d99f0723d908151c2b4a2b9d2b203061c",
            "commitAuthorOld": "Norman Maurer",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,43 +1,47 @@\n     private State readHeaders(ByteBuf buffer) {\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n         if (line.length() > 0) {\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n-                    value = value.toString() + ' ' + line.toString().trim();\n+                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n+                    buf.append(value);\n+                    buf.append(' ');\n+                    buf.append(line.toString().trim());\n+                    value = buf.toString();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n             } while (line.length() > 0);\n         }\n \n         // Add the last header.\n         if (name != null) {\n             headers.add(name, value);\n         }\n         // reset name and value fields\n         name = null;\n         value = null;\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    StringBuilder buf = new StringBuilder(value.length() + line.length() + 1);\n                    buf.append(value);\n                    buf.append(' ');\n                    buf.append(line.toString().trim());\n                    value = buf.toString();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "cf4c464d99f0723d908151c2b4a2b9d2b203061c": {
            "type": "Ybodychange",
            "commitMessage": "Modify HttpObjectDecoder to allow parsing the HTTP headers in multiple steps.\n\nMotivation:\nAt the moment the whole HTTP header must be parsed at once which can lead to multiple parsing of the same bytes. We can do better here and allow to parse it in multiple steps.\n\nModifications:\n\n - Not parse headers multiple times\n - Simplify the code\n - Eliminate uncessary String[] creations\n - Use readSlice(...).retain() when possible.\n\nResult:\n\nPerformance improvements as shown in the included benchmark below.\n\nBefore change:\n[nmaurer@xxx]~% ./wrk-benchmark\nRunning 2m test @ http://xxx:8080/plaintext\n  16 threads and 256 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    21.55ms   15.10ms 245.02ms   90.26%\n    Req/Sec   196.33k    30.17k  297.29k    76.03%\n  373954750 requests in 2.00m, 50.15GB read\nRequests/sec: 3116466.08\nTransfer/sec:    427.98MB\n\nAfter change:\n[nmaurer@xxx]~% ./wrk-benchmark\nRunning 2m test @ http://xxx:8080/plaintext\n  16 threads and 256 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    20.91ms   36.79ms   1.26s    98.24%\n    Req/Sec   206.67k    21.69k  243.62k    94.96%\n  393071191 requests in 2.00m, 52.71GB read\nRequests/sec: 3275971.50\nTransfer/sec:    449.89MB\n",
            "commitDate": "25/10/14 12:53 AM",
            "commitName": "cf4c464d99f0723d908151c2b4a2b9d2b203061c",
            "commitAuthor": "Norman Maurer",
            "commitDateOld": "02/07/14 3:55 AM",
            "commitNameOld": "d0912f27091e4548466df81f545c017a25c9d256",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 114.87,
            "commitsBetweenForRepo": 206,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,46 +1,43 @@\n     private State readHeaders(ByteBuf buffer) {\n-        headerSize = 0;\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = headerParser.parse(buffer);\n-        String name = null;\n-        String value = null;\n         if (line.length() > 0) {\n-            headers.clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n-                    value = value + ' ' + line.toString().trim();\n+                    value = value.toString() + ' ' + line.toString().trim();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n-                    String[] header = splitHeader(line);\n-                    name = header[0];\n-                    value = header[1];\n+                    splitHeader(line);\n                 }\n \n                 line = headerParser.parse(buffer);\n             } while (line.length() > 0);\n-\n-            // Add the last header.\n-            if (name != null) {\n-                headers.add(name, value);\n-            }\n         }\n \n+        // Add the last header.\n+        if (name != null) {\n+            headers.add(name, value);\n+        }\n+        // reset name and value fields\n+        name = null;\n+        value = null;\n+\n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        if (line.length() > 0) {\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value.toString() + ' ' + line.toString().trim();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n\n                line = headerParser.parse(buffer);\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "faf8becf2e12fdb46ba256c39eedab501ed3cdcb": {
            "type": "Ybodychange",
            "commitMessage": "Make use of ByteBufProcessor for extract initial line and headers\n\nThis gives some nice performance boost as readByte() is quite expensive because of the index / replay checks.\n",
            "commitDate": "16/01/14 11:14 AM",
            "commitName": "faf8becf2e12fdb46ba256c39eedab501ed3cdcb",
            "commitAuthor": "Norman Maurer",
            "commitDateOld": "09/01/14 11:17 PM",
            "commitNameOld": "b24494abeb3515fac9c5392a14f7a92b1f9550f2",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 6.5,
            "commitsBetweenForRepo": 24,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,46 +1,46 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n-        AppendableCharSequence line = readHeader(buffer);\n+        AppendableCharSequence line = headerParser.parse(buffer);\n         String name = null;\n         String value = null;\n         if (line.length() > 0) {\n             headers.clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.toString().trim();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n-                line = readHeader(buffer);\n+                line = headerParser.parse(buffer);\n             } while (line.length() > 0);\n \n             // Add the last header.\n             if (name != null) {\n                 headers.add(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = headerParser.parse(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() > 0) {\n            headers.clear();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.toString().trim();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = headerParser.parse(buffer);\n            } while (line.length() > 0);\n\n            // Add the last header.\n            if (name != null) {\n                headers.add(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "0052d83db18ce710be65d8a6732c994227bf31fe": {
            "type": "Ybodychange",
            "commitMessage": "Limit the access of the HttpHeaders for performance reasons\n",
            "commitDate": "18/12/13 6:13 AM",
            "commitName": "0052d83db18ce710be65d8a6732c994227bf31fe",
            "commitAuthor": "Norman Maurer",
            "commitDateOld": "18/12/13 6:13 AM",
            "commitNameOld": "e9f09ea9f5f1b371fbdce95c6ddc97030f9b5c58",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,46 +1,46 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n         AppendableCharSequence line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (line.length() > 0) {\n             headers.clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.toString().trim();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() > 0);\n \n             // Add the last header.\n             if (name != null) {\n                 headers.add(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n-        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n+        } else if (contentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() > 0) {\n            headers.clear();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.toString().trim();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() > 0);\n\n            // Add the last header.\n            if (name != null) {\n                headers.add(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "05c10fae051163b3b3925ac1bd9b179fc3e3bb00": {
            "type": "Ybodychange",
            "commitMessage": "Replace usage of StringBuilder by AppendableCharSequence for performance reasons\n",
            "commitDate": "03/12/13 3:04 AM",
            "commitName": "05c10fae051163b3b3925ac1bd9b179fc3e3bb00",
            "commitAuthor": "Norman Maurer",
            "commitDateOld": "29/11/13 8:43 AM",
            "commitNameOld": "818bc602ee2ed0223ccc7b7fe440b931ae556b13",
            "commitAuthorOld": "Norman Maurer",
            "daysBetweenCommits": 3.76,
            "commitsBetweenForRepo": 5,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,46 +1,46 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n-        StringBuilder line = readHeader(buffer);\n+        AppendableCharSequence line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (line.length() > 0) {\n             headers.clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.toString().trim();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() > 0);\n \n             // Add the last header.\n             if (name != null) {\n                 headers.add(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        AppendableCharSequence line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() > 0) {\n            headers.clear();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.toString().trim();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() > 0);\n\n            // Add the last header.\n            if (name != null) {\n                headers.add(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {}
        },
        "acb28e3ac8d04feffa15cdceaeda1284b3338b7e": {
            "type": "Ybodychange",
            "commitMessage": "Multiple optimizations in the HttpObjectDecoder\n\n* Minimize allocation of StringBuilder and also minimize char array copy\n* Try to detect HttpVersion without calling toUpperCase() for performance reasons\n",
            "commitDate": "31/07/13 12:23 AM",
            "commitName": "acb28e3ac8d04feffa15cdceaeda1284b3338b7e",
            "commitAuthor": "Norman Maurer",
            "commitDateOld": "09/07/13 7:51 AM",
            "commitNameOld": "cbd88179051a51e66abac4c65d4af865c203c337",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 21.69,
            "commitsBetweenForRepo": 190,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,46 +1,46 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         final HttpHeaders headers = message.headers();\n \n-        String line = readHeader(buffer);\n+        StringBuilder line = readHeader(buffer);\n         String name = null;\n         String value = null;\n-        if (!line.isEmpty()) {\n+        if (line.length() > 0) {\n             headers.clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n-                    value = value + ' ' + line.trim();\n+                    value = value + ' ' + line.toString().trim();\n                 } else {\n                     if (name != null) {\n                         headers.add(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n-            } while (!line.isEmpty());\n+            } while (line.length() > 0);\n \n             // Add the last header.\n             if (name != null) {\n                 headers.add(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        StringBuilder line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() > 0) {\n            headers.clear();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.toString().trim();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() > 0);\n\n            // Add the last header.\n            if (name != null) {\n                headers.add(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "11"
        },
        "3b79008eda1315e7515aadaeac7224b4cda073ad": {
            "type": "Ybodychange",
            "commitMessage": "Change the WebSocket API to use HttpHeaders instead of Map<String, String> for custom headers / Cleanup\n",
            "commitDate": "16/01/13 7:33 AM",
            "commitName": "3b79008eda1315e7515aadaeac7224b4cda073ad",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "16/01/13 6:46 AM",
            "commitNameOld": "34820511ff677667d46c0447f72527a7842dfa42",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.03,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,44 +1,46 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n+        final HttpHeaders headers = message.headers();\n+\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (!line.isEmpty()) {\n-            message.headers().clear();\n+            headers.clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n-                        message.headers().add(name, value);\n+                        headers.add(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n-                message.headers().add(name, value);\n+                headers.add(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        final HttpHeaders headers = message.headers();\n\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (!line.isEmpty()) {\n            headers.clear();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                headers.add(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "20"
        },
        "34820511ff677667d46c0447f72527a7842dfa42": {
            "type": "Ybodychange",
            "commitMessage": "Second HTTP overhaul\n\n- Rename message types for clarity\n  - HttpMessage -> FullHttpMessage\n  - HttpHeader -> HttpMessage\n  - HttpRequest -> FullHttpRequest\n  - HttpResponse -> FulllHttpResponse\n  - HttpRequestHeader -> HttpRequest\n  - HttpResponseHeader -> HttpResponse\n- HttpContent now extends ByteBufHolder; no more content() method\n- Make HttpHeaders abstract, make its header access methods public, and\n  add DefaultHttpHeaders\n- Header accessor methods in HttpMessage and LastHttpContent are\n  replaced with HttpMessage.headers() and\n  LastHttpContent.trailingHeaders(). Both methods return HttpHeaders.\n- Remove setters wherever possible and remove 'get' prefix\n- Instead of calling setContent(), a user can either specify the content\n  when constructing a message or write content into the buffer.\n  (e.g. m.content().writeBytes(...))\n- Overall cleanup & fixes\n",
            "commitDate": "16/01/13 6:46 AM",
            "commitName": "34820511ff677667d46c0447f72527a7842dfa42",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "15/01/13 8:51 AM",
            "commitNameOld": "b7de868003691e9c72e8995273dfcd20245f680a",
            "commitAuthorOld": "Norman Maurer",
            "daysBetweenCommits": 0.91,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,44 +1,44 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n-        final HttpHeader message = this.message;\n+        final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (!line.isEmpty()) {\n-            message.clearHeaders();\n+            message.headers().clear();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n-                        message.addHeader(name, value);\n+                        message.headers().add(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n-                message.addHeader(name, value);\n+                message.headers().add(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (!line.isEmpty()) {\n            message.headers().clear();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.headers().add(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                message.headers().add(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "247"
        },
        "b7de868003691e9c72e8995273dfcd20245f680a": {
            "type": "Ymultichange(Yfilerename,Ybodychange)",
            "commitMessage": "[#677] Overhaul HTTP codec\n\nThis commit tries to simplify the handling of Http easier and more consistent. This has a effect of many channges. Including:\n - HttpMessage was renamed to HttpHeader and the setContent and getContent methods were removed\n - HttpChunk was renamed to HttpContent\n - HttpChunkTrailer was renamed to LastHttpContent\n - HttpCodecUtil was merged into HttpHeaders\n\nNow a \"complete\" Http message (request or response) contains of the following parts:\n - HttpHeader (HttpRequestHeader or HttpResponseHeader)\n - 0 - n HttpContent objects which contains parts of the content of the message\n - 1 LastHttpContent which marks the end of the message and contains the remaining data of the content\n\nI also changed the sematic of HttpResponse and HttpRequest, these now represent a \"complete\" message which contains the HttpHeader and the HttpLastContent, and so can be used to eeasily send requests. The HttpMessageAggregator was renamed to HttpObjectAggregator and produce HttpResponse / HttpRequest message.\n",
            "commitDate": "15/01/13 8:51 AM",
            "commitName": "b7de868003691e9c72e8995273dfcd20245f680a",
            "commitAuthor": "Norman Maurer",
            "subchanges": [
                {
                    "type": "Yfilerename",
                    "commitMessage": "[#677] Overhaul HTTP codec\n\nThis commit tries to simplify the handling of Http easier and more consistent. This has a effect of many channges. Including:\n - HttpMessage was renamed to HttpHeader and the setContent and getContent methods were removed\n - HttpChunk was renamed to HttpContent\n - HttpChunkTrailer was renamed to LastHttpContent\n - HttpCodecUtil was merged into HttpHeaders\n\nNow a \"complete\" Http message (request or response) contains of the following parts:\n - HttpHeader (HttpRequestHeader or HttpResponseHeader)\n - 0 - n HttpContent objects which contains parts of the content of the message\n - 1 LastHttpContent which marks the end of the message and contains the remaining data of the content\n\nI also changed the sematic of HttpResponse and HttpRequest, these now represent a \"complete\" message which contains the HttpHeader and the HttpLastContent, and so can be used to eeasily send requests. The HttpMessageAggregator was renamed to HttpObjectAggregator and produce HttpResponse / HttpRequest message.\n",
                    "commitDate": "15/01/13 8:51 AM",
                    "commitName": "b7de868003691e9c72e8995273dfcd20245f680a",
                    "commitAuthor": "Norman Maurer",
                    "commitDateOld": "15/01/13 7:38 AM",
                    "commitNameOld": "506474f56951c2191070839cff24dd37a9c8dc13",
                    "commitAuthorOld": "Trustin Lee",
                    "daysBetweenCommits": 0.05,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,45 +1,44 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n-        final HttpMessage message = this.message;\n+        final HttpHeader message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (!line.isEmpty()) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n-            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n+            HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n-            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n+        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpHeader message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (!line.isEmpty()) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
                    "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
                    "extendedDetails": {
                        "oldPath": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
                        "newPath": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "[#677] Overhaul HTTP codec\n\nThis commit tries to simplify the handling of Http easier and more consistent. This has a effect of many channges. Including:\n - HttpMessage was renamed to HttpHeader and the setContent and getContent methods were removed\n - HttpChunk was renamed to HttpContent\n - HttpChunkTrailer was renamed to LastHttpContent\n - HttpCodecUtil was merged into HttpHeaders\n\nNow a \"complete\" Http message (request or response) contains of the following parts:\n - HttpHeader (HttpRequestHeader or HttpResponseHeader)\n - 0 - n HttpContent objects which contains parts of the content of the message\n - 1 LastHttpContent which marks the end of the message and contains the remaining data of the content\n\nI also changed the sematic of HttpResponse and HttpRequest, these now represent a \"complete\" message which contains the HttpHeader and the HttpLastContent, and so can be used to eeasily send requests. The HttpMessageAggregator was renamed to HttpObjectAggregator and produce HttpResponse / HttpRequest message.\n",
                    "commitDate": "15/01/13 8:51 AM",
                    "commitName": "b7de868003691e9c72e8995273dfcd20245f680a",
                    "commitAuthor": "Norman Maurer",
                    "commitDateOld": "15/01/13 7:38 AM",
                    "commitNameOld": "506474f56951c2191070839cff24dd37a9c8dc13",
                    "commitAuthorOld": "Trustin Lee",
                    "daysBetweenCommits": 0.05,
                    "commitsBetweenForRepo": 1,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,45 +1,44 @@\n     private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n-        final HttpMessage message = this.message;\n+        final HttpHeader message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (!line.isEmpty()) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n-            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n+            HttpHeaders.removeTransferEncodingChunked(message);\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n-            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n+        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpHeader message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (!line.isEmpty()) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            HttpHeaders.removeTransferEncodingChunked(message);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpHeaders.isTransferEncodingChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
                    "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "137"
        },
        "d6a0fe54fd866917d2fd7d13894cb7527563f467": {
            "type": "Yexceptionschange",
            "commitMessage": "Remove unnecessary throws clauses for unchecked exceptions\n",
            "commitDate": "09/11/12 2:07 PM",
            "commitName": "d6a0fe54fd866917d2fd7d13894cb7527563f467",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "09/11/12 8:55 AM",
            "commitNameOld": "27dc582e2bb4888f082806756e2181bd463c8db4",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.22,
            "commitsBetweenForRepo": 10,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,45 +1,45 @@\n-    private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n+    private State readHeaders(ByteBuf buffer) {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (!line.isEmpty()) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n             message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (!line.isEmpty()) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {
                "oldValue": "[TooLongFrameException]",
                "newValue": "[]"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "13"
        },
        "27dc582e2bb4888f082806756e2181bd463c8db4": {
            "type": "Ybodychange",
            "commitMessage": "Fix a regression in HttpMessageDecoder due to a mistake during yak shaving\n",
            "commitDate": "09/11/12 8:55 AM",
            "commitName": "27dc582e2bb4888f082806756e2181bd463c8db4",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "09/11/12 8:24 AM",
            "commitNameOld": "bbcb035246423895b5ae73c323434784ac7b5245",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.02,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,45 +1,45 @@\n     private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n-        if (line.isEmpty()) {\n+        if (!line.isEmpty()) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n             message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (!line.isEmpty()) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "bbcb035246423895b5ae73c323434784ac7b5245": {
            "type": "Ybodychange",
            "commitMessage": "Prefer isEmpty() over size() == 0 or length() == 0\n",
            "commitDate": "09/11/12 8:24 AM",
            "commitName": "bbcb035246423895b5ae73c323434784ac7b5245",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "27/09/12 11:20 PM",
            "commitNameOld": "9155f58c6418751d21dd6868851ef46cfe06e4df",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 42.42,
            "commitsBetweenForRepo": 92,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,45 +1,45 @@\n     private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n-        if (line.length() != 0) {\n+        if (line.isEmpty()) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n-            } while (line.length() != 0);\n+            } while (!line.isEmpty());\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n             message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.isEmpty()) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (!line.isEmpty());\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "14"
        },
        "602f976e4111d66b807f9b2c1cbf09a8f245cd01": {
            "type": "Ybodychange",
            "commitMessage": "[#527] Add a new property to HttpMessage to help clarify its transfer encoding\n    \n- Add an enum: HttpTransferEncoding\n  - consists of SINGLE, STREAMED, and CHUNKED\n- Add HttpMessage.transferEncoding\n  - replaces is/setChunked()\n",
            "commitDate": "19/08/12 3:06 AM",
            "commitName": "602f976e4111d66b807f9b2c1cbf09a8f245cd01",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "04/07/12 6:27 AM",
            "commitNameOld": "a7a4081e70ac468d96d9a8799ae27347fb13c4c9",
            "commitAuthorOld": "norman",
            "daysBetweenCommits": 45.86,
            "commitsBetweenForRepo": 181,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,49 +1,45 @@\n     private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n+            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (message.isChunked()) {\n-            // HttpMessage.isChunked() returns true when either:\n-            // 1) HttpMessage.setChunked(true) was called or\n-            // 2) 'Transfer-Encoding' is 'chunked'.\n-            // Because this decoder did not call HttpMessage.setChunked(true)\n-            // yet, HttpMessage.isChunked() should return true only when\n-            // 'Transfer-Encoding' is 'chunked'.\n+        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n+            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.SINGLE);\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (HttpCodecUtil.isTransferEncodingChunked(message)) {\n            message.setTransferEncoding(HttpTransferEncoding.CHUNKED);\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "19"
        },
        "5164d91255a5cd68bcd1fade07e6ef4fdb3c7646": {
            "type": "Yparameterchange",
            "commitMessage": "Rename ChannelBuffer to ByteBuf as discussed before\n\n- ChannelBuffer gives a perception that it's a buffer of a\n  channel, but channel's buffer is now a byte buffer or a message\n  buffer.  Therefore letting it be as is is going to be confusing.\n  ",
            "commitDate": "09/06/12 7:08 PM",
            "commitName": "5164d91255a5cd68bcd1fade07e6ef4fdb3c7646",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "06/06/12 10:52 PM",
            "commitNameOld": "5e93d206ffeb637f9b4885643860ff63a8412dc6",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 2.84,
            "commitsBetweenForRepo": 27,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,49 +1,49 @@\n-    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n+    private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String name = null;\n         String value = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     value = value + ' ' + line.trim();\n                 } else {\n                     if (name != null) {\n                         message.addHeader(name, value);\n                     }\n                     String[] header = splitHeader(line);\n                     name = header[0];\n                     value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n \n             // Add the last header.\n             if (name != null) {\n                 message.addHeader(name, value);\n             }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             // HttpMessage.isChunked() returns true when either:\n             // 1) HttpMessage.setChunked(true) was called or\n             // 2) 'Transfer-Encoding' is 'chunked'.\n             // Because this decoder did not call HttpMessage.setChunked(true)\n             // yet, HttpMessage.isChunked() should return true only when\n             // 'Transfer-Encoding' is 'chunked'.\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ByteBuf buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            // HttpMessage.isChunked() returns true when either:\n            // 1) HttpMessage.setChunked(true) was called or\n            // 2) 'Transfer-Encoding' is 'chunked'.\n            // Because this decoder did not call HttpMessage.setChunked(true)\n            // yet, HttpMessage.isChunked() should return true only when\n            // 'Transfer-Encoding' is 'chunked'.\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {
                "oldValue": "[buffer-ChannelBuffer]",
                "newValue": "[buffer-ByteBuf]"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "243"
        },
        "8663716d38040537f6660cf2b81ee74549e0ab6d": {
            "type": "Yfilerename",
            "commitMessage": "Issue #60: Make the project multi-module\n\nSplit the project into the following modules:\n* common\n* buffer\n* codec\n* codec-http\n* transport\n* transport-*\n* handler\n* example\n* testsuite (integration tests that involve 2+ modules)\n* all (does nothing yet, but will make it generate netty.jar)\n\nThis commit also fixes the compilation errors with transport-sctp on\nnon-Linux systems.  It will at least compile without complaints.\n",
            "commitDate": "28/12/11 2:44 AM",
            "commitName": "8663716d38040537f6660cf2b81ee74549e0ab6d",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "18/12/11 1:56 PM",
            "commitNameOld": "8ad4cd0528ff0dffd91ff2777ddcbb79869a5928",
            "commitAuthorOld": "Vibul Imtarnasan",
            "daysBetweenCommits": 9.53,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            // HttpMessage.isChunked() returns true when either:\n            // 1) HttpMessage.setChunked(true) was called or\n            // 2) 'Transfer-Encoding' is 'chunked'.\n            // Because this decoder did not call HttpMessage.setChunked(true)\n            // yet, HttpMessage.isChunked() should return true only when\n            // 'Transfer-Encoding' is 'chunked'.\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {
                "oldPath": "src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
                "newPath": "codec-http/src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java"
            },
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "7518e9852501ed5cda45f88ce0d3671eeb866631": {
            "type": "Yfilerename",
            "commitMessage": "org.jboss.netty -> io.netty\n",
            "commitDate": "08/12/11 7:40 PM",
            "commitName": "7518e9852501ed5cda45f88ce0d3671eeb866631",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "08/12/11 7:38 PM",
            "commitNameOld": "6fdb7d91165f7e82c5608c07ee911bc9b6fcdf5a",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            // HttpMessage.isChunked() returns true when either:\n            // 1) HttpMessage.setChunked(true) was called or\n            // 2) 'Transfer-Encoding' is 'chunked'.\n            // Because this decoder did not call HttpMessage.setChunked(true)\n            // yet, HttpMessage.isChunked() should return true only when\n            // 'Transfer-Encoding' is 'chunked'.\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {
                "oldPath": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
                "newPath": "src/main/java/io/netty/handler/codec/http/HttpMessageDecoder.java"
            },
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        },
        "1c6813a06d85178c56bae1894a76199b49b3e8a3": {
            "type": "Ybodychange",
            "commitMessage": "Fixed issue: NETTY-337 Multi-line headers truncated\n",
            "commitDate": "06/07/10 11:43 PM",
            "commitName": "1c6813a06d85178c56bae1894a76199b49b3e8a3",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "27/05/10 5:38 AM",
            "commitNameOld": "0d0b0c56c33bd801f3f82f5c450be77f5012ccfa",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 40.75,
            "commitsBetweenForRepo": 46,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,43 +1,49 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n-        String lastHeader = null;\n+        String name = null;\n+        String value = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n-                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n-                    List<String> current = message.getHeaders(lastHeader);\n-                    int lastPos = current.size() - 1;\n-                    String newString = current.get(lastPos) + line.trim();\n-                    current.set(lastPos, newString);\n+                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n+                    value = value + ' ' + line.trim();\n                 } else {\n+                    if (name != null) {\n+                        message.addHeader(name, value);\n+                    }\n                     String[] header = splitHeader(line);\n-                    message.addHeader(header[0], header[1]);\n-                    lastHeader = header[0];\n+                    name = header[0];\n+                    value = header[1];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n+\n+            // Add the last header.\n+            if (name != null) {\n+                message.addHeader(name, value);\n+            }\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             // HttpMessage.isChunked() returns true when either:\n             // 1) HttpMessage.setChunked(true) was called or\n             // 2) 'Transfer-Encoding' is 'chunked'.\n             // Because this decoder did not call HttpMessage.setChunked(true)\n             // yet, HttpMessage.isChunked() should return true only when\n             // 'Transfer-Encoding' is 'chunked'.\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String name = null;\n        String value = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    value = value + ' ' + line.trim();\n                } else {\n                    if (name != null) {\n                        message.addHeader(name, value);\n                    }\n                    String[] header = splitHeader(line);\n                    name = header[0];\n                    value = header[1];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n\n            // Add the last header.\n            if (name != null) {\n                message.addHeader(name, value);\n            }\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            // HttpMessage.isChunked() returns true when either:\n            // 1) HttpMessage.setChunked(true) was called or\n            // 2) 'Transfer-Encoding' is 'chunked'.\n            // Because this decoder did not call HttpMessage.setChunked(true)\n            // yet, HttpMessage.isChunked() should return true only when\n            // 'Transfer-Encoding' is 'chunked'.\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "d0e886c344cb4c5b6f4e05bf0b85d911b371b2e6": {
            "type": "Ybodychange",
            "commitMessage": "Resolved issues: NETTY-280 Add convenient getters and setters for HTTP headers\nResolved issues: NETTY-281 Allow non-string values for HTTP header values\n",
            "commitDate": "25/01/10 8:31 PM",
            "commitName": "d0e886c344cb4c5b6f4e05bf0b85d911b371b2e6",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "21/11/09 7:51 AM",
            "commitNameOld": "44ab3dd94a62f8b3eb8c4ebd16c747328589d0da",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 65.53,
            "commitsBetweenForRepo": 124,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,43 +1,43 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     List<String> current = message.getHeaders(lastHeader);\n                     int lastPos = current.size() - 1;\n                     String newString = current.get(lastPos) + line.trim();\n                     current.set(lastPos, newString);\n                 } else {\n                     String[] header = splitHeader(line);\n                     message.addHeader(header[0], header[1]);\n                     lastHeader = header[0];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             // HttpMessage.isChunked() returns true when either:\n             // 1) HttpMessage.setChunked(true) was called or\n             // 2) 'Transfer-Encoding' is 'chunked'.\n             // Because this decoder did not call HttpMessage.setChunked(true)\n             // yet, HttpMessage.isChunked() should return true only when\n             // 'Transfer-Encoding' is 'chunked'.\n             nextState = State.READ_CHUNK_SIZE;\n-        } else if (message.getContentLength(-1) >= 0) {\n+        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                } else {\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            // HttpMessage.isChunked() returns true when either:\n            // 1) HttpMessage.setChunked(true) was called or\n            // 2) 'Transfer-Encoding' is 'chunked'.\n            // Because this decoder did not call HttpMessage.setChunked(true)\n            // yet, HttpMessage.isChunked() should return true only when\n            // 'Transfer-Encoding' is 'chunked'.\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (HttpHeaders.getContentLength(message, -1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "20"
        },
        "8c39e2823ecdc3c423132971269315e5a73158dd": {
            "type": "Ybodychange",
            "commitMessage": "* HttpMessage.isChunked() checks the 'Transfer-Encoding' header\n",
            "commitDate": "16/11/09 11:39 PM",
            "commitName": "8c39e2823ecdc3c423132971269315e5a73158dd",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "16/11/09 11:19 PM",
            "commitNameOld": "40597002e9d4a3e53f8e19df712a9e5652281ddb",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,37 +1,43 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     List<String> current = message.getHeaders(lastHeader);\n                     int lastPos = current.size() - 1;\n                     String newString = current.get(lastPos) + line.trim();\n                     current.set(lastPos, newString);\n                 } else {\n                     String[] header = splitHeader(line);\n                     message.addHeader(header[0], header[1]);\n                     lastHeader = header[0];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (isChunked(message)) {\n+        } else if (message.isChunked()) {\n+            // HttpMessage.isChunked() returns true when either:\n+            // 1) HttpMessage.setChunked(true) was called or\n+            // 2) 'Transfer-Encoding' is 'chunked'.\n+            // Because this decoder did not call HttpMessage.setChunked(true)\n+            // yet, HttpMessage.isChunked() should return true only when\n+            // 'Transfer-Encoding' is 'chunked'.\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                } else {\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            // HttpMessage.isChunked() returns true when either:\n            // 1) HttpMessage.setChunked(true) was called or\n            // 2) 'Transfer-Encoding' is 'chunked'.\n            // Because this decoder did not call HttpMessage.setChunked(true)\n            // yet, HttpMessage.isChunked() should return true only when\n            // 'Transfer-Encoding' is 'chunked'.\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "40597002e9d4a3e53f8e19df712a9e5652281ddb": {
            "type": "Ybodychange",
            "commitMessage": "resolved issue: NETTY-250 HttpMessageDecoder violates HTTP/1.0 by converting a message into chunked encoding\n* HttpMessageDecoder does not add the 'Transfer-Encoding' header anymore\n* Added HttpMessage.setChunked()\n* The semantic of the HttpMessage.chunked has been changed\n\n",
            "commitDate": "16/11/09 11:19 PM",
            "commitName": "40597002e9d4a3e53f8e19df712a9e5652281ddb",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "16/11/09 10:02 PM",
            "commitNameOld": "ce48ab00582bdc2cd1e0f61684e19dc2b3f54585",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.05,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,37 +1,37 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     List<String> current = message.getHeaders(lastHeader);\n                     int lastPos = current.size() - 1;\n                     String newString = current.get(lastPos) + line.trim();\n                     current.set(lastPos, newString);\n                 } else {\n                     String[] header = splitHeader(line);\n                     message.addHeader(header[0], header[1]);\n                     lastHeader = header[0];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n-        } else if (message.isChunked()) {\n+        } else if (isChunked(message)) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                } else {\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (isChunked(message)) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "bda2f0a852f01a25211fc3837dcfbd28d4639224": {
            "type": "Ybodychange",
            "commitMessage": "Fixed incorrect state management for HTTP header size\n",
            "commitDate": "15/06/09 1:45 AM",
            "commitName": "bda2f0a852f01a25211fc3837dcfbd28d4639224",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "15/06/09 1:35 AM",
            "commitNameOld": "aeb7903be8f287e8096d5221092a126019748855",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,36 +1,37 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n+        headerSize = 0;\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     List<String> current = message.getHeaders(lastHeader);\n                     int lastPos = current.size() - 1;\n                     String newString = current.get(lastPos) + line.trim();\n                     current.set(lastPos, newString);\n                 } else {\n                     String[] header = splitHeader(line);\n                     message.addHeader(header[0], header[1]);\n                     lastHeader = header[0];\n                 }\n \n                 line = readHeader(buffer);\n             } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        headerSize = 0;\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                } else {\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "aeb7903be8f287e8096d5221092a126019748855": {
            "type": "Ybodychange",
            "commitMessage": "Fixed a mistake during optimization\n",
            "commitDate": "15/06/09 1:35 AM",
            "commitName": "aeb7903be8f287e8096d5221092a126019748855",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "15/06/09 1:13 AM",
            "commitNameOld": "12acb2cf093c7fde7afcf3297735084628f3574c",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,35 +1,36 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n                 char firstChar = line.charAt(0);\n                 if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     List<String> current = message.getHeaders(lastHeader);\n                     int lastPos = current.size() - 1;\n                     String newString = current.get(lastPos) + line.trim();\n                     current.set(lastPos, newString);\n                 } else {\n                     String[] header = splitHeader(line);\n                     message.addHeader(header[0], header[1]);\n                     lastHeader = header[0];\n-                    line = readHeader(buffer);\n                 }\n+\n+                line = readHeader(buffer);\n             } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                } else {\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                }\n\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "12acb2cf093c7fde7afcf3297735084628f3574c": {
            "type": "Ybodychange",
            "commitMessage": "Fixed a NPE in HttpMessageDecoder.readHeaders() on a particular malformed header\n",
            "commitDate": "15/06/09 1:13 AM",
            "commitName": "12acb2cf093c7fde7afcf3297735084628f3574c",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "15/06/09 1:05 AM",
            "commitNameOld": "f059f91ff4b6f4f5e556a09dbb41426969da82fb",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.01,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,36 +1,35 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         if (line.length() != 0) {\n             message.clearHeaders();\n             do {\n-                switch (line.charAt(0)) {\n-                case ' ': case '\\t':\n+                char firstChar = line.charAt(0);\n+                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                     List<String> current = message.getHeaders(lastHeader);\n                     int lastPos = current.size() - 1;\n                     String newString = current.get(lastPos) + line.trim();\n                     current.set(lastPos, newString);\n-                    break;\n-                default:\n+                } else {\n                     String[] header = splitHeader(line);\n                     message.addHeader(header[0], header[1]);\n                     lastHeader = header[0];\n+                    line = readHeader(buffer);\n                 }\n-                line = readHeader(buffer);\n             } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                char firstChar = line.charAt(0);\n                if (lastHeader != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                } else {\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                    line = readHeader(buffer);\n                }\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "f059f91ff4b6f4f5e556a09dbb41426969da82fb": {
            "type": "Ybodychange",
            "commitMessage": "Code simplification / optimization\n",
            "commitDate": "15/06/09 1:05 AM",
            "commitName": "f059f91ff4b6f4f5e556a09dbb41426969da82fb",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "15/06/09 12:30 AM",
            "commitNameOld": "160866e1a009a52ec37a8023f9e5aa1c68b04a3a",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.02,
            "commitsBetweenForRepo": 3,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,35 +1,36 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n-        message.clearHeaders();\n+        final HttpMessage message = this.message;\n         String line = readHeader(buffer);\n         String lastHeader = null;\n-        while (line.length() != 0) {\n-            char firstChar = line.charAt(0);\n-            switch (firstChar) {\n-            case ' ': case '\\t':\n-                List<String> current = message.getHeaders(lastHeader);\n-                int lastPos = current.size() - 1;\n-                String newString = current.get(lastPos) + line.trim();\n-                current.remove(lastPos);\n-                current.add(newString);\n-                break;\n-            default:\n-                String[] header = splitHeader(line);\n-                message.addHeader(header[0], header[1]);\n-                lastHeader = header[0];\n-            }\n-            line = readHeader(buffer);\n+        if (line.length() != 0) {\n+            message.clearHeaders();\n+            do {\n+                switch (line.charAt(0)) {\n+                case ' ': case '\\t':\n+                    List<String> current = message.getHeaders(lastHeader);\n+                    int lastPos = current.size() - 1;\n+                    String newString = current.get(lastPos) + line.trim();\n+                    current.set(lastPos, newString);\n+                    break;\n+                default:\n+                    String[] header = splitHeader(line);\n+                    message.addHeader(header[0], header[1]);\n+                    lastHeader = header[0];\n+                }\n+                line = readHeader(buffer);\n+            } while (line.length() != 0);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        final HttpMessage message = this.message;\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        if (line.length() != 0) {\n            message.clearHeaders();\n            do {\n                switch (line.charAt(0)) {\n                case ' ': case '\\t':\n                    List<String> current = message.getHeaders(lastHeader);\n                    int lastPos = current.size() - 1;\n                    String newString = current.get(lastPos) + line.trim();\n                    current.set(lastPos, newString);\n                    break;\n                default:\n                    String[] header = splitHeader(line);\n                    message.addHeader(header[0], header[1]);\n                    lastHeader = header[0];\n                }\n                line = readHeader(buffer);\n            } while (line.length() != 0);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "a979433f918f569a13890bd9f2485385c29690e2": {
            "type": "Ybodychange",
            "commitMessage": "Tiny optimization in HttpMessageDecoder.readHeaders()\n",
            "commitDate": "14/06/09 11:29 PM",
            "commitName": "a979433f918f569a13890bd9f2485385c29690e2",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "03/06/09 11:01 PM",
            "commitNameOld": "02ba3b553a835a052afce2a9dcb82523ea352b7f",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 11.02,
            "commitsBetweenForRepo": 39,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,33 +1,35 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         message.clearHeaders();\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n-            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n+            char firstChar = line.charAt(0);\n+            switch (firstChar) {\n+            case ' ': case '\\t':\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n-            }\n-            else {\n+                break;\n+            default:\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readHeader(buffer);\n         }\n \n         State nextState;\n \n         if (isContentAlwaysEmpty(message)) {\n             nextState = State.SKIP_CONTROL_CHARS;\n         } else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        message.clearHeaders();\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            char firstChar = line.charAt(0);\n            switch (firstChar) {\n            case ' ': case '\\t':\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n                break;\n            default:\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readHeader(buffer);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "c6b707c442b9116b26a99fac16cd067c27628ae2": {
            "type": "Ybodychange",
            "commitMessage": "Fixed issue: NETTY-137 HttpChunkAggregator should not wait for content when the response status code implies empty content.\n* Applied the same fix to HttpMessageDecoder\n",
            "commitDate": "29/03/09 7:14 PM",
            "commitName": "c6b707c442b9116b26a99fac16cd067c27628ae2",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "10/03/09 1:57 AM",
            "commitNameOld": "e523b8ec0f2f07d8dcd9874b915fdeb0f914ff91",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 19.72,
            "commitsBetweenForRepo": 89,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,30 +1,33 @@\n     private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         message.clearHeaders();\n         String line = readHeader(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readHeader(buffer);\n         }\n \n         State nextState;\n-        if (message.isChunked()) {\n+\n+        if (isContentAlwaysEmpty(message)) {\n+            nextState = State.SKIP_CONTROL_CHARS;\n+        } else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        message.clearHeaders();\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readHeader(buffer);\n        }\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {\n            nextState = State.SKIP_CONTROL_CHARS;\n        } else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "3"
        },
        "4a72aafd567489304824b89d8ab3e0765b76a4d8": {
            "type": "Ymultichange(Yexceptionschange,Ybodychange)",
            "commitMessage": "Resolved issue: NETTY-133 Limit the length of HTTP header lines.\n* Added maxHeaderSize option\n* Added maxInitialLineLength option\n* Overall HTTP code cleanup\n",
            "commitDate": "10/03/09 12:20 AM",
            "commitName": "4a72aafd567489304824b89d8ab3e0765b76a4d8",
            "commitAuthor": "Trustin Lee",
            "subchanges": [
                {
                    "type": "Yexceptionschange",
                    "commitMessage": "Resolved issue: NETTY-133 Limit the length of HTTP header lines.\n* Added maxHeaderSize option\n* Added maxInitialLineLength option\n* Overall HTTP code cleanup\n",
                    "commitDate": "10/03/09 12:20 AM",
                    "commitName": "4a72aafd567489304824b89d8ab3e0765b76a4d8",
                    "commitAuthor": "Trustin Lee",
                    "commitDateOld": "09/03/09 1:50 AM",
                    "commitNameOld": "832ed0c19839472364f84761055b1351d340ac64",
                    "commitAuthorOld": "Trustin Lee",
                    "daysBetweenCommits": 0.94,
                    "commitsBetweenForRepo": 7,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,30 +1,30 @@\n-    private State readHeaders(ChannelBuffer buffer) {\n+    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         message.clearHeaders();\n-        String line = readIntoCurrentLine(buffer);\n+        String line = readHeader(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n-            line = readIntoCurrentLine(buffer);\n+            line = readHeader(buffer);\n         }\n \n         State nextState;\n         if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        message.clearHeaders();\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readHeader(buffer);\n        }\n\n        State nextState;\n        if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
                    "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
                    "extendedDetails": {
                        "oldValue": "[]",
                        "newValue": "[TooLongFrameException]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Resolved issue: NETTY-133 Limit the length of HTTP header lines.\n* Added maxHeaderSize option\n* Added maxInitialLineLength option\n* Overall HTTP code cleanup\n",
                    "commitDate": "10/03/09 12:20 AM",
                    "commitName": "4a72aafd567489304824b89d8ab3e0765b76a4d8",
                    "commitAuthor": "Trustin Lee",
                    "commitDateOld": "09/03/09 1:50 AM",
                    "commitNameOld": "832ed0c19839472364f84761055b1351d340ac64",
                    "commitAuthorOld": "Trustin Lee",
                    "daysBetweenCommits": 0.94,
                    "commitsBetweenForRepo": 7,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,30 +1,30 @@\n-    private State readHeaders(ChannelBuffer buffer) {\n+    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n         message.clearHeaders();\n-        String line = readIntoCurrentLine(buffer);\n+        String line = readHeader(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n-            line = readIntoCurrentLine(buffer);\n+            line = readHeader(buffer);\n         }\n \n         State nextState;\n         if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         return nextState;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    private State readHeaders(ChannelBuffer buffer) throws TooLongFrameException {\n        message.clearHeaders();\n        String line = readHeader(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readHeader(buffer);\n        }\n\n        State nextState;\n        if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
                    "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "4979cb6a219abc529850c1b451c0b0e221574b1d": {
            "type": "Ymultichange(Yreturntypechange,Ybodychange)",
            "commitMessage": "A little bit of code clean up\n",
            "commitDate": "04/03/09 5:50 AM",
            "commitName": "4979cb6a219abc529850c1b451c0b0e221574b1d",
            "commitAuthor": "Trustin Lee",
            "subchanges": [
                {
                    "type": "Yreturntypechange",
                    "commitMessage": "A little bit of code clean up\n",
                    "commitDate": "04/03/09 5:50 AM",
                    "commitName": "4979cb6a219abc529850c1b451c0b0e221574b1d",
                    "commitAuthor": "Trustin Lee",
                    "commitDateOld": "26/02/09 1:08 AM",
                    "commitNameOld": "6200d39bdd0023922204d9da70caf728510fc67d",
                    "commitAuthorOld": "Trustin Lee",
                    "daysBetweenCommits": 6.2,
                    "commitsBetweenForRepo": 26,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,30 +1,30 @@\n-    private void readHeaders(ChannelBuffer buffer) {\n+    private State readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n \n         State nextState;\n         if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n-        checkpoint(nextState);\n+        return nextState;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    private State readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        State nextState;\n        if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
                    "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
                    "extendedDetails": {
                        "oldValue": "void",
                        "newValue": "State"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "A little bit of code clean up\n",
                    "commitDate": "04/03/09 5:50 AM",
                    "commitName": "4979cb6a219abc529850c1b451c0b0e221574b1d",
                    "commitAuthor": "Trustin Lee",
                    "commitDateOld": "26/02/09 1:08 AM",
                    "commitNameOld": "6200d39bdd0023922204d9da70caf728510fc67d",
                    "commitAuthorOld": "Trustin Lee",
                    "daysBetweenCommits": 6.2,
                    "commitsBetweenForRepo": 26,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,30 +1,30 @@\n-    private void readHeaders(ChannelBuffer buffer) {\n+    private State readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n \n         State nextState;\n         if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n             nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n-        checkpoint(nextState);\n+        return nextState;\n     }\n\\ No newline at end of file\n",
                    "actualSource": "    private State readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        State nextState;\n        if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n    }",
                    "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "2d682dc2a3ecd32a179d4455c1b7a0e675768945": {
            "type": "Ybodychange",
            "commitMessage": "Fixed NETTY-107 HttpMessageDecoder can not handle the content with no 'Content-Length' header.\n* Added HttpMessage.getContentLength(int defaultValue)\n* Renamed state enum values\n",
            "commitDate": "11/02/09 11:17 PM",
            "commitName": "2d682dc2a3ecd32a179d4455c1b7a0e675768945",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "11/02/09 10:27 PM",
            "commitNameOld": "602c99c53200a10b76e8a5a93b1e4dbd86f03c09",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 0.03,
            "commitsBetweenForRepo": 6,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,30 +1,30 @@\n     private void readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n \n         State nextState;\n         if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n-        } else if (message.getContentLength() >= 0) {\n+        } else if (message.getContentLength(-1) >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         } else {\n-            nextState = State.READ_CONTENT;\n+            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n         }\n         checkpoint(nextState);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private void readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        State nextState;\n        if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength(-1) >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        checkpoint(nextState);\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "32738273e07e56d755334adaf91795f83474a2d1": {
            "type": "Ybodychange",
            "commitMessage": "Related issue: NETTY-116 HTTP issues including chunked request / response patch\n* Applied Dave's patch for HttpMessageDecoder\n",
            "commitDate": "11/02/09 8:37 PM",
            "commitName": "32738273e07e56d755334adaf91795f83474a2d1",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "08/12/08 1:02 AM",
            "commitNameOld": "1fa791c4a41689a72a2c7bb9dbfad631a19cc366",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 65.82,
            "commitsBetweenForRepo": 217,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,32 +1,30 @@\n     private void readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n \n         State nextState;\n-        if (message.getContentLength() >= 0) {\n-            nextState = State.READ_FIXED_LENGTH_CONTENT;\n-        }\n-        else if (message.isChunked()) {\n+        if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n-        }\n-        else {\n+        } else if (message.getContentLength() >= 0) {\n+            nextState = State.READ_FIXED_LENGTH_CONTENT;\n+        } else {\n             nextState = State.READ_CONTENT;\n         }\n         checkpoint(nextState);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private void readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        State nextState;\n        if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (message.getContentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        } else {\n            nextState = State.READ_CONTENT;\n        }\n        checkpoint(nextState);\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "df2f9d9d50510eeffdc1e29fce74172edd2beef5": {
            "type": "Ybodychange",
            "commitMessage": "Removed System.out.printlns\n",
            "commitDate": "04/12/08 6:05 PM",
            "commitName": "df2f9d9d50510eeffdc1e29fce74172edd2beef5",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "03/12/08 1:00 AM",
            "commitNameOld": "a30c36d8e2ae7ad3ea5d7577c2c1e806e24ad560",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 1.71,
            "commitsBetweenForRepo": 11,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,37 +1,32 @@\n     private void readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n \n-        for (String n: message.getHeaderNames()) {\n-            for (String v: message.getHeaders(n)) {\n-                System.out.println(n + \": \" + v);\n-            }\n-        }\n         State nextState;\n         if (message.getContentLength() >= 0) {\n             nextState = State.READ_FIXED_LENGTH_CONTENT;\n         }\n         else if (message.isChunked()) {\n             nextState = State.READ_CHUNK_SIZE;\n         }\n         else {\n             nextState = State.READ_CONTENT;\n         }\n         checkpoint(nextState);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private void readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        State nextState;\n        if (message.getContentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        }\n        else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        }\n        else {\n            nextState = State.READ_CONTENT;\n        }\n        checkpoint(nextState);\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "a30c36d8e2ae7ad3ea5d7577c2c1e806e24ad560": {
            "type": "Ybodychange",
            "commitMessage": "* APIviz tagging\n* Added missing @version tags\n\n\n",
            "commitDate": "03/12/08 1:00 AM",
            "commitName": "a30c36d8e2ae7ad3ea5d7577c2c1e806e24ad560",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "30/11/08 8:29 AM",
            "commitNameOld": "e213b54b71921c658aafbf631a1cfd154beea72a",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 2.69,
            "commitsBetweenForRepo": 31,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,37 +1,37 @@\n     private void readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n         while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n \n         for (String n: message.getHeaderNames()) {\n             for (String v: message.getHeaders(n)) {\n                 System.out.println(n + \": \" + v);\n             }\n         }\n-        ResponseState nextState;\n+        State nextState;\n         if (message.getContentLength() >= 0) {\n-            nextState = ResponseState.READ_FIXED_LENGTH_CONTENT;\n+            nextState = State.READ_FIXED_LENGTH_CONTENT;\n         }\n         else if (message.isChunked()) {\n-            nextState = ResponseState.READ_CHUNK_SIZE;\n+            nextState = State.READ_CHUNK_SIZE;\n         }\n         else {\n-            nextState = ResponseState.READ_CONTENT;\n+            nextState = State.READ_CONTENT;\n         }\n         checkpoint(nextState);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private void readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        for (String n: message.getHeaderNames()) {\n            for (String v: message.getHeaders(n)) {\n                System.out.println(n + \": \" + v);\n            }\n        }\n        State nextState;\n        if (message.getContentLength() >= 0) {\n            nextState = State.READ_FIXED_LENGTH_CONTENT;\n        }\n        else if (message.isChunked()) {\n            nextState = State.READ_CHUNK_SIZE;\n        }\n        else {\n            nextState = State.READ_CONTENT;\n        }\n        checkpoint(nextState);\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "d4348ab4d75c2db7befbe59b050a98f8a70a27fd": {
            "type": "Ybodychange",
            "commitMessage": "Fixed NETTY-86 (HttpResponseDecoder decodes the initial line incorrectly.)\n",
            "commitDate": "30/11/08 8:22 AM",
            "commitName": "d4348ab4d75c2db7befbe59b050a98f8a70a27fd",
            "commitAuthor": "Trustin Lee",
            "commitDateOld": "20/11/08 12:15 AM",
            "commitNameOld": "8ac3b2905df3cddb36d6f76227bfa959692116e8",
            "commitAuthorOld": "Trustin Lee",
            "daysBetweenCommits": 10.34,
            "commitsBetweenForRepo": 35,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,31 +1,37 @@\n     private void readHeaders(ChannelBuffer buffer) {\n         message.clearHeaders();\n         String line = readIntoCurrentLine(buffer);\n         String lastHeader = null;\n-        while (!line.equals(\"\")) {\n+        while (line.length() != 0) {\n             if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                 List<String> current = message.getHeaders(lastHeader);\n                 int lastPos = current.size() - 1;\n                 String newString = current.get(lastPos) + line.trim();\n                 current.remove(lastPos);\n                 current.add(newString);\n             }\n             else {\n                 String[] header = splitHeader(line);\n                 message.addHeader(header[0], header[1]);\n                 lastHeader = header[0];\n             }\n             line = readIntoCurrentLine(buffer);\n         }\n+\n+        for (String n: message.getHeaderNames()) {\n+            for (String v: message.getHeaders(n)) {\n+                System.out.println(n + \": \" + v);\n+            }\n+        }\n         ResponseState nextState;\n-        if (message.getContentLength() > 0) {\n+        if (message.getContentLength() >= 0) {\n             nextState = ResponseState.READ_FIXED_LENGTH_CONTENT;\n         }\n         else if (message.isChunked()) {\n             nextState = ResponseState.READ_CHUNK_SIZE;\n         }\n         else {\n             nextState = ResponseState.READ_CONTENT;\n         }\n         checkpoint(nextState);\n     }\n\\ No newline at end of file\n",
            "actualSource": "    private void readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (line.length() != 0) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n\n        for (String n: message.getHeaderNames()) {\n            for (String v: message.getHeaders(n)) {\n                System.out.println(n + \": \" + v);\n            }\n        }\n        ResponseState nextState;\n        if (message.getContentLength() >= 0) {\n            nextState = ResponseState.READ_FIXED_LENGTH_CONTENT;\n        }\n        else if (message.isChunked()) {\n            nextState = ResponseState.READ_CHUNK_SIZE;\n        }\n        else {\n            nextState = ResponseState.READ_CONTENT;\n        }\n        checkpoint(nextState);\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "4ac032c65752d1822ab8e15551a032f05286aece": {
            "type": "Yintroduced",
            "commitMessage": "Merged the HTTP branch into the trunk\n",
            "commitDate": "18/11/08 11:22 PM",
            "commitName": "4ac032c65752d1822ab8e15551a032f05286aece",
            "commitAuthor": "Trustin Lee",
            "diff": "@@ -0,0 +1,31 @@\n+    private void readHeaders(ChannelBuffer buffer) {\n+        message.clearHeaders();\n+        String line = readIntoCurrentLine(buffer);\n+        String lastHeader = null;\n+        while (!line.equals(\"\")) {\n+            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n+                List<String> current = message.getHeaders(lastHeader);\n+                int lastPos = current.size() - 1;\n+                String newString = current.get(lastPos) + line.trim();\n+                current.remove(lastPos);\n+                current.add(newString);\n+            }\n+            else {\n+                String[] header = splitHeader(line);\n+                message.addHeader(header[0], header[1]);\n+                lastHeader = header[0];\n+            }\n+            line = readIntoCurrentLine(buffer);\n+        }\n+        ResponseState nextState;\n+        if (message.getContentLength() > 0) {\n+            nextState = ResponseState.READ_FIXED_LENGTH_CONTENT;\n+        }\n+        else if (message.isChunked()) {\n+            nextState = ResponseState.READ_CHUNK_SIZE;\n+        }\n+        else {\n+            nextState = ResponseState.READ_CONTENT;\n+        }\n+        checkpoint(nextState);\n+    }\n\\ No newline at end of file\n",
            "actualSource": "    private void readHeaders(ChannelBuffer buffer) {\n        message.clearHeaders();\n        String line = readIntoCurrentLine(buffer);\n        String lastHeader = null;\n        while (!line.equals(\"\")) {\n            if (line.startsWith(\" \") || line.startsWith(\"\\t\")) {\n                List<String> current = message.getHeaders(lastHeader);\n                int lastPos = current.size() - 1;\n                String newString = current.get(lastPos) + line.trim();\n                current.remove(lastPos);\n                current.add(newString);\n            }\n            else {\n                String[] header = splitHeader(line);\n                message.addHeader(header[0], header[1]);\n                lastHeader = header[0];\n            }\n            line = readIntoCurrentLine(buffer);\n        }\n        ResponseState nextState;\n        if (message.getContentLength() > 0) {\n            nextState = ResponseState.READ_FIXED_LENGTH_CONTENT;\n        }\n        else if (message.isChunked()) {\n            nextState = ResponseState.READ_CHUNK_SIZE;\n        }\n        else {\n            nextState = ResponseState.READ_CONTENT;\n        }\n        checkpoint(nextState);\n    }",
            "path": "src/main/java/org/jboss/netty/handler/codec/http/HttpMessageDecoder.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "9054.json"
}