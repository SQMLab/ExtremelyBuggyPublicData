{
    "origin": "codeshovel",
    "repositoryName": "jgit",
    "repositoryPath": "/home/shaiful/research/codeshovel/codeshovel-projects/jgit/.git",
    "startCommitName": "HEAD",
    "sourceFileName": "DirCacheCheckout.java",
    "functionName": "processEntry",
    "functionId": "processEntry___h-CanonicalTreeParser__m-CanonicalTreeParser__i-DirCacheBuildIterator__f-WorkingTreeIterator",
    "sourceFilePath": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
    "functionStartLine": 710,
    "functionEndLine": 1170,
    "numCommitsSeen": 149,
    "timeTaken": 4072,
    "changeHistory": [
        "2059ed205ebdf1b6837077db6cea6d29a4fbcf4a",
        "3f78650c9af941634022f4f8422e51cab40ca85f",
        "220cd43482c803b2e1ba6cdacc6e03644658b737",
        "e3881de258b4db6a0d9284e6154a11f3c7eacf37",
        "11fd0fe03ae471d1a6528070b4fee884b0ffea1d",
        "0d7dd6625a11a149d83e17f1d7defab9237aa6f6",
        "2bb8da040578d98b4d1c4ee3c1287e115a36efa3",
        "576abf64d138606814e4b67c8110c4ee1ae1b2ac",
        "ed7b322186a872bdd4f41a1a31554a7e90d74de6",
        "0fb0e8440507e3e969432ea1115b806e5e04138c",
        "d364fb2d4f17866162a206d10ff89e19be7ac8e3",
        "42d7565ba9b97effdee3f737e32541b26b7341ab",
        "51c20b27acdef57dcb1d79ac995cd49f2e9c2f91",
        "1c4ee41dc093266c19d4452879afe5c0f7f387f4",
        "af40635aba91a78ec248503906996ca89898e888",
        "e0502ebb032f78227437a7863eea9ca91678e593",
        "5404e70dc64201786cd6a21efb41310912860122",
        "078a9f60664fee1f7e85f0c3ab3fd067c0f674cc",
        "73c8e70797c5517972d06f03f2aadfb9aacfb223",
        "7aa3358c40959ab996697f3c739acc86ded7f6ff",
        "1a9f12277313c12830b24b63559bb31eb584b241",
        "cf9b01b09a320de4afb8da8f2ec5002fd0441831",
        "8456927b1bbb344cc6a768b1f491dddd50d4ce7c",
        "5fe44ed3ee025404dc34966ec996641f47f8490b",
        "530812d93645a4238ff33b6ca2f600ceb7ea8143",
        "e406d500de01b9ae7155e296baebf3ec8024869d",
        "98cdca9b5a830f1c2ceca52379d662a68109d43e",
        "64f2407f19330d182728feeaf3d2c1a4092a2051"
    ],
    "changeHistoryShort": {
        "64f2407f19330d182728feeaf3d2c1a4092a2051": "Ybodychange",
        "98cdca9b5a830f1c2ceca52379d662a68109d43e": "Ybodychange",
        "e406d500de01b9ae7155e296baebf3ec8024869d": "Ybodychange",
        "530812d93645a4238ff33b6ca2f600ceb7ea8143": "Ybodychange",
        "5fe44ed3ee025404dc34966ec996641f47f8490b": "Ybodychange",
        "8456927b1bbb344cc6a768b1f491dddd50d4ce7c": "Ybodychange",
        "cf9b01b09a320de4afb8da8f2ec5002fd0441831": "Ybodychange",
        "1a9f12277313c12830b24b63559bb31eb584b241": "Ybodychange",
        "7aa3358c40959ab996697f3c739acc86ded7f6ff": "Ybodychange",
        "73c8e70797c5517972d06f03f2aadfb9aacfb223": "Ybodychange",
        "078a9f60664fee1f7e85f0c3ab3fd067c0f674cc": "Ybodychange",
        "5404e70dc64201786cd6a21efb41310912860122": "Ybodychange",
        "e0502ebb032f78227437a7863eea9ca91678e593": "Ybodychange",
        "af40635aba91a78ec248503906996ca89898e888": "Ybodychange",
        "1c4ee41dc093266c19d4452879afe5c0f7f387f4": "Ybodychange",
        "51c20b27acdef57dcb1d79ac995cd49f2e9c2f91": "Ybodychange",
        "42d7565ba9b97effdee3f737e32541b26b7341ab": "Ymultichange(Yparameterchange,Ybodychange)",
        "d364fb2d4f17866162a206d10ff89e19be7ac8e3": "Ybodychange",
        "0fb0e8440507e3e969432ea1115b806e5e04138c": "Ybodychange",
        "ed7b322186a872bdd4f41a1a31554a7e90d74de6": "Ybodychange",
        "576abf64d138606814e4b67c8110c4ee1ae1b2ac": "Ybodychange",
        "2bb8da040578d98b4d1c4ee3c1287e115a36efa3": "Ybodychange",
        "0d7dd6625a11a149d83e17f1d7defab9237aa6f6": "Ybodychange",
        "11fd0fe03ae471d1a6528070b4fee884b0ffea1d": "Ybodychange",
        "e3881de258b4db6a0d9284e6154a11f3c7eacf37": "Ybodychange",
        "220cd43482c803b2e1ba6cdacc6e03644658b737": "Ybodychange",
        "3f78650c9af941634022f4f8422e51cab40ca85f": "Ybodychange",
        "2059ed205ebdf1b6837077db6cea6d29a4fbcf4a": "Yintroduced"
    },
    "changeHistoryDetails": {
        "64f2407f19330d182728feeaf3d2c1a4092a2051": {
            "type": "Ybodychange",
            "commitMessage": "WorkingTreeModifiedEvent: must be fired explicitly after merge\n\nA merge may write files to the working tree. After a successful\nmerge one must fire a WorkingTreeModifiedEvent explicitly if\ngetModifiedFiles() is not empty.\n\nAlso, any touched files must be reported by the\nWorkingTreeModifiedEvent fired by DirCacheCheckout.checkout().\n\nBug: 552636\nChange-Id: I5fab8279ed8be8a4ae34cddfa726836b9277aea6\nSigned-off-by: Thomas Wolf <thomas.wolf@paranor.ch>",
            "commitDate": "03/11/19 1:10 AM",
            "commitName": "64f2407f19330d182728feeaf3d2c1a4092a2051",
            "commitAuthor": "Thomas Wolf",
            "commitDateOld": "16/10/19 6:20 PM",
            "commitNameOld": "98cdca9b5a830f1c2ceca52379d662a68109d43e",
            "commitAuthorOld": "David Pursehouse",
            "daysBetweenCommits": 17.33,
            "commitsBetweenForRepo": 25,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,461 +1,461 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n-\t\t\t\tkeep(dce, f);\n+\t\t\t\tkeep(name, dce, f);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n-\t\t\t\t\tkeep(dce, f); // 5 6\n+\t\t\t\t\tkeep(name, dce, f); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n-\t\t\t\tkeep(dce, f);\n+\t\t\t\tkeep(name, dce, f);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n-\t\t\t\tkeep(dce, f);\n+\t\t\t\tkeep(name, dce, f);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tif ((ffMask & 0x222) == 0) {\n \t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n \t\t\t// folder)\n \t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n \t\t\t\t// -> no problem\n \t\t\t\treturn;\n \t\t\t}\n \t\t\t// the workingtree entry exists and is not a folder\n \t\t\tif (!idEqual(h, m)) {\n \t\t\t\t// Because HEAD and MERGE differ we will try to update the\n \t\t\t\t// workingtree with a folder -> return a conflict\n \t\t\t\tconflict(name, null, null, null);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null && !f.isEntryIgnored()) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n \t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (initialCheckout)\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\telse\n-\t\t\t\t\t\tkeep(dce, f);\n+\t\t\t\t\t\tkeep(name, dce, f);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n-\t\t\t\t\t\tkeep(dce, f);\n+\t\t\t\t\t\tkeep(name, dce, f);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n \t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode)) {\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n \t\t\t\t\t\t\t// removed. That's a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t\t}\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n-\t\t\t\t\tkeep(dce, f);\n+\t\t\t\t\tkeep(name, dce, f);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(name, dce, f);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(name, dce, f); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(name, dce, f);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(name, dce, f);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask & 0x222) == 0) {\n\t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n\t\t\t// folder)\n\t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n\t\t\t\t// -> no problem\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// the workingtree entry exists and is not a folder\n\t\t\tif (!idEqual(h, m)) {\n\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n\t\t\t\t// workingtree with a folder -> return a conflict\n\t\t\t\tconflict(name, null, null, null);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null && !f.isEntryIgnored()) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (initialCheckout)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(name, dce, f);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(name, dce, f);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode)) {\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(name, dce, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {}
        },
        "98cdca9b5a830f1c2ceca52379d662a68109d43e": {
            "type": "Ybodychange",
            "commitMessage": "Enable and fix \"Statement unnecessarily nested within else clause\" warnings\n\nSince [1] the gerrit project includes jgit as a submodule, and has this\nwarning enabled, resulting in 100s of warnings in the console.\n\nAlso enable the warning here, and fix them.\n\nAt the same time, add missing braces around adjacent and nearby one-line\nblocks.\n\n[1] https://gerrit-review.googlesource.com/c/gerrit/+/227897\n\nChange-Id: I81df3fc7ed6eedf6874ce1a3bedfa727a1897e4c\nSigned-off-by: David Pursehouse <david.pursehouse@gmail.com>\n",
            "commitDate": "16/10/19 6:20 PM",
            "commitName": "98cdca9b5a830f1c2ceca52379d662a68109d43e",
            "commitAuthor": "David Pursehouse",
            "commitDateOld": "09/08/19 5:32 AM",
            "commitNameOld": "3cea3676c75127dd720ea4c0b86d92ed040f7fa7",
            "commitAuthorOld": "",
            "daysBetweenCommits": 68.53,
            "commitsBetweenForRepo": 179,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,460 +1,461 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce, f);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce, f); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce, f);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce, f);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tif ((ffMask & 0x222) == 0) {\n \t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n \t\t\t// folder)\n \t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n \t\t\t\t// -> no problem\n \t\t\t\treturn;\n-\t\t\t} else {\n-\t\t\t\t// the workingtree entry exists and is not a folder\n-\t\t\t\tif (!idEqual(h, m)) {\n-\t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n-\t\t\t\t\t// workingtree with a folder -> return a conflict\n-\t\t\t\t\tconflict(name, null, null, null);\n-\t\t\t\t}\n-\t\t\t\treturn;\n \t\t\t}\n+\t\t\t// the workingtree entry exists and is not a folder\n+\t\t\tif (!idEqual(h, m)) {\n+\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n+\t\t\t\t// workingtree with a folder -> return a conflict\n+\t\t\t\tconflict(name, null, null, null);\n+\t\t\t}\n+\t\t\treturn;\n \t\t}\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null && !f.isEntryIgnored()) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n \t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (initialCheckout)\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\telse\n \t\t\t\t\t\tkeep(dce, f);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce, f);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n-\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n+\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode)) {\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n-\t\t\t\t\t\t\t\t// removed. That's a conflict\n-\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n-\t\t\t\t\t\t} else\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n+\t\t\t\t\t\t\t// removed. That's a conflict\n+\t\t\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n-\t\t\t\t\t} else\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce, f);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce, f);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce, f); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce, f);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce, f);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask & 0x222) == 0) {\n\t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n\t\t\t// folder)\n\t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n\t\t\t\t// -> no problem\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// the workingtree entry exists and is not a folder\n\t\t\tif (!idEqual(h, m)) {\n\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n\t\t\t\t// workingtree with a folder -> return a conflict\n\t\t\t\tconflict(name, null, null, null);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null && !f.isEntryIgnored()) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (initialCheckout)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(dce, f);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce, f);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode)) {\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {}
        },
        "e406d500de01b9ae7155e296baebf3ec8024869d": {
            "type": "Ybodychange",
            "commitMessage": "Fix \"jgit checkout -f\" to overwrite dirty worktree files\n\nCheckoutCommand had a setForce() method. But this didn't correspond\nto native git's 'git checkout -f' option. Deprecate the old setForce()\nmethod and move its implementation to a new method setForceRefUpdate()\nand use it to implement the -B option in the CLI class Checkout.\n\nAdd a setForced() method and use it to fix the associated '-f' option of\nthe CLI Checkout class to behave like native git's 'git checkout -f'\nwhich overwrites dirty worktree files during checkout.\n\nThis is still not fully matching native git's behavior: updating\nadditionally dirty index entries is not done yet.\n\nBug: 530771\nChange-Id: I776b78eb623b6ea0aca42f681788f2e4b1667f15\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
            "commitDate": "08/01/19 1:01 AM",
            "commitName": "e406d500de01b9ae7155e296baebf3ec8024869d",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "02/01/19 6:18 PM",
            "commitNameOld": "530812d93645a4238ff33b6ca2f600ceb7ea8143",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 5.28,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,460 +1,460 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n-\t\t\t\tkeep(dce);\n+\t\t\t\tkeep(dce, f);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n-\t\t\t\t\tkeep(dce); // 5 6\n+\t\t\t\t\tkeep(dce, f); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n-\t\t\t\tkeep(dce);\n+\t\t\t\tkeep(dce, f);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n-\t\t\t\tkeep(dce);\n+\t\t\t\tkeep(dce, f);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tif ((ffMask & 0x222) == 0) {\n \t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n \t\t\t// folder)\n \t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n \t\t\t\t// -> no problem\n \t\t\t\treturn;\n \t\t\t} else {\n \t\t\t\t// the workingtree entry exists and is not a folder\n \t\t\t\tif (!idEqual(h, m)) {\n \t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n \t\t\t\t\t// workingtree with a folder -> return a conflict\n \t\t\t\t\tconflict(name, null, null, null);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null && !f.isEntryIgnored()) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n \t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (initialCheckout)\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\telse\n-\t\t\t\t\t\tkeep(dce);\n+\t\t\t\t\t\tkeep(dce, f);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n-\t\t\t\t\t\tkeep(dce);\n+\t\t\t\t\t\tkeep(dce, f);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n \t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n \t\t\t\t\t\t\t\t// removed. That's a conflict\n \t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\t} else\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n-\t\t\t\t\tkeep(dce);\n+\t\t\t\t\tkeep(dce, f);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce, f);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce, f); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce, f);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce, f);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask & 0x222) == 0) {\n\t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n\t\t\t// folder)\n\t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n\t\t\t\t// -> no problem\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// the workingtree entry exists and is not a folder\n\t\t\t\tif (!idEqual(h, m)) {\n\t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n\t\t\t\t\t// workingtree with a folder -> return a conflict\n\t\t\t\t\tconflict(name, null, null, null);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null && !f.isEntryIgnored()) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (initialCheckout)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(dce, f);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce, f);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {}
        },
        "530812d93645a4238ff33b6ca2f600ceb7ea8143": {
            "type": "Ybodychange",
            "commitMessage": "Fix detection of \"initial checkout\"\n\nA checkout done directly after cloning (the \"initial\ncheckout\") has a different semantic as a default\ncheckout. That is defined in the documentation of\n\"git read-tree\" [1]. JGit was detecting that it is\ndoing an initial checkout differently from native\ngit: jgit used to check that the index is empty\nbut native git required that the index file does\nnot exist [2]. Teach JGit to behave like native\ngit.\n\n[1] https://github.com/git/git/blob/master/Documentation/git-read-tree.txt#L187\n[2] https://marc.info/?t=154150811200001&r=1&w=2\n\nChange-Id: I1dd0f1ede7cd7ea60d28607916d0165269a9f628\n",
            "commitDate": "02/01/19 6:18 PM",
            "commitName": "530812d93645a4238ff33b6ca2f600ceb7ea8143",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "20/10/18 3:53 AM",
            "commitNameOld": "d056a543846ccf9b8cd0f59cc2f5920427fc4559",
            "commitAuthorOld": "Ned Twigg",
            "daysBetweenCommits": 74.64,
            "commitsBetweenForRepo": 129,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,460 +1,460 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\tif ((ffMask & 0x222) == 0) {\n \t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n \t\t\t// folder)\n \t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n \t\t\t\t// -> no problem\n \t\t\t\treturn;\n \t\t\t} else {\n \t\t\t\t// the workingtree entry exists and is not a folder\n \t\t\t\tif (!idEqual(h, m)) {\n \t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n \t\t\t\t\t// workingtree with a folder -> return a conflict\n \t\t\t\t\tconflict(name, null, null, null);\n \t\t\t\t}\n \t\t\t\treturn;\n \t\t\t}\n \t\t}\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null && !f.isEntryIgnored()) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n \t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n-\t\t\t\t\tif (emptyDirCache)\n+\t\t\t\t\tif (initialCheckout)\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\telse\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n \t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n \t\t\t\t\t\t\t\t// removed. That's a conflict\n \t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\t} else\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask & 0x222) == 0) {\n\t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n\t\t\t// folder)\n\t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n\t\t\t\t// -> no problem\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// the workingtree entry exists and is not a folder\n\t\t\t\tif (!idEqual(h, m)) {\n\t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n\t\t\t\t\t// workingtree with a folder -> return a conflict\n\t\t\t\t\tconflict(name, null, null, null);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null && !f.isEntryIgnored()) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (initialCheckout)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {}
        },
        "5fe44ed3ee025404dc34966ec996641f47f8490b": {
            "type": "Ybodychange",
            "commitMessage": "Fix DirCacheCheckout to return CheckoutConflictException\n\nProblem occurs when the checkout wants to create a file 'd/f' but\nthe workingtree contains a dirty file 'd'. In order to create d/f the\nfile 'd' would have to be deleted and since the file is dirty that\ncontent would be lost. This should lead to a CheckoutConflictException\nfor d/f when failOnConflict was set to true.\n\nThis fix also changes jgit checkout semantics to be more like native\ngits checkout semantics. If during a checkout jgit wants to delete a\nfolder but finds that the working tree contains a dirty file at this\npath then JGit will now throw an exception instead of silently keeping\nthe dirty file. Like in this example:\n\n\tgit init\n\ttouch b\n\tgit add b\n\tgit commit -m addB\n\tmkdir a\n\ttouch a/c\n\tgit add a/c\n\tgit commit -m addAC\n\trm -fr a\n\ttouch a\n\tgit checkout HEAD~\n\nChange-Id: I9089123179e09dd565285d50b0caa308d290cccd\nSigned-off-by: R\u00fcdiger Herrmann <ruediger.herrmann@gmx.de>\nAlso-by: R\u00fcdiger Herrmann <ruediger.herrmann@gmx.de>\n",
            "commitDate": "23/06/16 12:34 AM",
            "commitName": "5fe44ed3ee025404dc34966ec996641f47f8490b",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "18/05/16 4:29 AM",
            "commitNameOld": "0afd62efa868791895eb1f563bb08f6511fe9a79",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 35.84,
            "commitsBetweenForRepo": 40,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,447 +1,460 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n-\t\t// if we have no file at all then there is nothing to do\n-\t\tif ((ffMask & 0x222) == 0\n-\t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n-\t\t\treturn;\n+\t\tif ((ffMask & 0x222) == 0) {\n+\t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n+\t\t\t// folder)\n+\t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n+\t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n+\t\t\t\t// -> no problem\n+\t\t\t\treturn;\n+\t\t\t} else {\n+\t\t\t\t// the workingtree entry exists and is not a folder\n+\t\t\t\tif (!idEqual(h, m)) {\n+\t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n+\t\t\t\t\t// workingtree with a folder -> return a conflict\n+\t\t\t\t\tconflict(name, null, null, null);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null && !f.isEntryIgnored()) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n \t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (emptyDirCache)\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\telse\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n \t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n \t\t\t\t\t\t\t\t// removed. That's a conflict\n \t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\t} else\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif ((ffMask & 0x222) == 0) {\n\t\t\t// HEAD, MERGE and index don't contain a file (e.g. all contain a\n\t\t\t// folder)\n\t\t\tif (f == null || FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t\t// the workingtree entry doesn't exist or also contains a folder\n\t\t\t\t// -> no problem\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// the workingtree entry exists and is not a folder\n\t\t\t\tif (!idEqual(h, m)) {\n\t\t\t\t\t// Because HEAD and MERGE differ we will try to update the\n\t\t\t\t\t// workingtree with a folder -> return a conflict\n\t\t\t\t\tconflict(name, null, null, null);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null && !f.isEntryIgnored()) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (emptyDirCache)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {}
        },
        "8456927b1bbb344cc6a768b1f491dddd50d4ce7c": {
            "type": "Ybodychange",
            "commitMessage": "Make sure checkout doesn't report conflicts on ignored paths\n\nIn a situation where a certain path was ignored but a working tree file\nwith this path existed jgit didn't allow to checkout a branch which\ndidn't ignore this path but contained different content. JGit considered\nthis to be a checkout conflict to prevent overwriting the file in the\nworking tree and raised an error. This commit fixes this by ensuring\nthat ignored dirty working tree files don't lead to a checkout conflict.\n\nBug: 450169\nChange-Id: I90288d314ffac73c24a9c70a5181f8243bd4679a\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
            "commitDate": "06/11/14 12:27 PM",
            "commitName": "8456927b1bbb344cc6a768b1f491dddd50d4ce7c",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "25/07/14 12:31 AM",
            "commitNameOld": "cf9b01b09a320de4afb8da8f2ec5002fd0441831",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 104.54,
            "commitsBetweenForRepo": 116,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,447 +1,447 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0\n \t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n-\t\t\tif (f != null) {\n+\t\t\tif (f != null && !f.isEntryIgnored()) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n \t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (emptyDirCache)\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\telse\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n \t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n \t\t\t\t\t\t\t\t// removed. That's a conflict\n \t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\t} else\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0\n\t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null && !f.isEntryIgnored()) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (emptyDirCache)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "cf9b01b09a320de4afb8da8f2ec5002fd0441831": {
            "type": "Ybodychange",
            "commitMessage": "Handle initial checkout correctly\n\nAs described in native gits file \"git-read-tree.txt\" git has in a\nspecial mode when doing the \"initial\" checkout. \"Initial\" means that the\nindex is empty before the checkout. This was not handled correctly in\nJGit and is fixed in this commit. Also see\nhttps://github.com/git/git/blob/master/Documentation/git-read-tree.txt#L181\n\nChange-Id: I9b9d1bd9ebf349cfca420c891c7b099a18d07ba4\n",
            "commitDate": "25/07/14 12:31 AM",
            "commitName": "cf9b01b09a320de4afb8da8f2ec5002fd0441831",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "17/05/14 10:06 AM",
            "commitNameOld": "1a9f12277313c12830b24b63559bb31eb584b241",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 68.6,
            "commitsBetweenForRepo": 68,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,443 +1,447 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0\n \t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n-\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n+\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n+\t\t\t *                                               , otherwise use M\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n-\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n-\t\t\t\t\tkeep(dce);\n-\t\t\t\telse\n+\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n+\t\t\t\t\tif (emptyDirCache)\n+\t\t\t\t\t\tupdate(name, mId, mMode);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tkeep(dce);\n+\t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null\n \t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f != null\n \t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \n \t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n \t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n \t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n \t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n \t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\telse\n \t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n \t\t\t\t\t\t\t\t// removed. That's a conflict\n \t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\t} else\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n \t\t\t\t\t\theadCommitTree)\n \t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n \t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0\n\t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index if not in initial checkout\n\t\t\t *                                               , otherwise use M\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (emptyDirCache)\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\telse\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "1a9f12277313c12830b24b63559bb31eb584b241": {
            "type": "Ybodychange",
            "commitMessage": "Fix a number of failing conflict situations\n\nAdds further tests where the working tree is dirty (differs from\nindex) and where we have staged but uncommitted changes.\n\nFixed the test case 9 for file/directory conflicts.\n\nBug: 428819\nChange-Id: Ie44a288b052abe936ebb74272d0fefef3b218a7a\nSigned-off-by: Axel Richard <axel.richard@obeo.fr>\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
            "commitDate": "17/05/14 10:06 AM",
            "commitName": "1a9f12277313c12830b24b63559bb31eb584b241",
            "commitAuthor": "Robin Rosenberg",
            "commitDateOld": "13/05/14 3:52 PM",
            "commitNameOld": "292cfab10d76fd372f76c672e96e9d168f8d7abf",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 3.76,
            "commitsBetweenForRepo": 4,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,430 +1,443 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n-\t\t * 9    F        D       F       Y         N       N       N           Update\n+\t\t * 9    F        D       F                 N       N       N           Conflict\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n-\t\t\t\tif (isModified(name)) {\n+\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n-\t\t\t\t\tif (isModified(name))\n+\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n-\t\t\t\t} else if (!isModified(name))\n-\t\t\t\t\tupdate(name, mId, mMode); // 9\n-\t\t\t\telse\n-\t\t\t\t\t// To be confirmed - this case is not in the table.\n-\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t} else\n+\t\t\t\t\tconflict(name, dce, h, m); // 9\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n-\t\t\t\t\tif (f == null\n-\t\t\t\t\t\t\t|| f.isModified(dce, true,\n+\t\t\t\t\tif (f != null\n+\t\t\t\t\t\t\t&& f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n-\t\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n \t\t\t\t\telse\n-\t\t\t\t\t\tremove(name);\n+\t\t\t\t\t\tremove(name); // 12\n \t\t\t\telse\n-\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\tconflict(name, dce, h, m); // 14\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n-\t\t\t\tif (!isModified(name))\n+\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n-\t\tif ((ffMask & 0x222) == 0)\n+\t\tif ((ffMask & 0x222) == 0\n+\t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n+\t\t\treturn;\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n-\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n+\t\t\t\tif (m == null\n+\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n+\t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n-\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n+\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n-\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n+\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n+\t\t\t\t\t\t\theadCommitTree)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n-\t\t\t\t\t\tif (f == null\n-\t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n-\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n+\t\t\t\t\t\tif (f != null\n+\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n-\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n-\t\t\t\t\t\t\t// a conflict\n-\t\t\t\t\t\t\tconflict(name, dce, h, m);\n-\t\t\t\t\t\telse\n+\n+\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n+\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n+\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n+\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n+\t\t\t\t\t\t\t\treturn;\n+\t\t\t\t\t\t\telse\n+\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n+\t\t\t\t\t\t\t\t// removed. That's a conflict\n+\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\t\t} else\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n-\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n-\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n+\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n+\t\t\t\t\t\t\t\theadCommitTree)\n+\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n+\t\t\t\t\t\t\t\tmergeCommitTree))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n-\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n-\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n+\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n+\t\t\t\t\t\theadCommitTree)\n+\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n+\t\t\t\t\t\t\t\tmergeCommitTree)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F                 N       N       N           Conflict\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (f != null && isModifiedSubtree_IndexWorkingtree(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m); // 9\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 13\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name); // 12\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 14\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModifiedSubtree_IndexWorkingtree(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0\n\t\t\t\t&& (f == null || FileMode.TREE.equals(f.getEntryFileMode())))\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t\treturn;\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null\n\t\t\t\t\t\t|| !isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  keep file\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\theadCommitTree)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f != null\n\t\t\t\t\t\t\t\t&& f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())) {\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\n\t\t\t\t\t\t\tif (!FileMode.TREE.equals(f.getEntryFileMode())\n\t\t\t\t\t\t\t\t\t&& FileMode.TREE.equals(iMode))\n\t\t\t\t\t\t\t\t// The workingtree contains a file and the index semantically contains a folder.\n\t\t\t\t\t\t\t\t// Git considers the workingtree file as untracked. Just keep the untracked file.\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t// -> file is dirty and tracked but is should be\n\t\t\t\t\t\t\t\t// removed. That's a conflict\n\t\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\tif (!isModified_IndexTree(name, iId, iMode, hId, hMode,\n\t\t\t\t\t\theadCommitTree)\n\t\t\t\t\t\t&& isModified_IndexTree(name, iId, iMode, mId, mMode,\n\t\t\t\t\t\t\t\tmergeCommitTree)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "5"
        },
        "7aa3358c40959ab996697f3c739acc86ded7f6ff": {
            "type": "Ybodychange",
            "commitMessage": "Add missing break\n\nIt does not really matter functionally, but it looked bad,\n\nChange-Id: Icb5b73b38fcaa19f7d1c5a0235c3e8dd125b888b\n",
            "commitDate": "09/03/14 1:39 AM",
            "commitName": "7aa3358c40959ab996697f3c739acc86ded7f6ff",
            "commitAuthor": "Robin Rosenberg",
            "commitDateOld": "26/02/14 6:35 AM",
            "commitNameOld": "73c8e70797c5517972d06f03f2aadfb9aacfb223",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 10.79,
            "commitsBetweenForRepo": 21,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,429 +1,430 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n+\t\t\t\tbreak;\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n \t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\t\tbreak;\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "73c8e70797c5517972d06f03f2aadfb9aacfb223": {
            "type": "Ybodychange",
            "commitMessage": "Don't raise checkout conflict for file missing in working tree\n\nDuring a checkout we want to prevent to overwrite unsaved local file\ncontent. Jgit was therefore checking whether the file to overwrite is\ndirty or missing and would raise a conflict if this was the case. That\nwas wrong. It should only check if the file is dirty. It's ok to\n\"overwrite\" a missing/non-existing file.\n\nChange-Id: I63c3a94f663c87f09170fdf8b1b1bf4ed5246fc5\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
            "commitDate": "26/02/14 6:35 AM",
            "commitName": "73c8e70797c5517972d06f03f2aadfb9aacfb223",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "10/02/14 1:53 PM",
            "commitNameOld": "078a9f60664fee1f7e85f0c3ab3fd067c0f674cc",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 15.7,
            "commitsBetweenForRepo": 30,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,429 +1,429 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n \t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n-\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n+\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n-\t\t\t\t\t\t// File doesn't exist or is dirty\n+\t\t\t\t\t\t// File exists and is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\t// File exists and is clean\n+\t\t\t\t\t\t// File doesn't exist or is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f != null && f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File exists and is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File doesn't exist or is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "078a9f60664fee1f7e85f0c3ab3fd067c0f674cc": {
            "type": "Ybodychange",
            "commitMessage": "Add symlink support to JGit\n\nThe change includes comparing symbolic links between disk and index,\nadding symbolic links to the index, creating/modifying links on\ncheckout. The behavior is controlled by the core.symlinks setting, just\nas C Git does. When a new repository is created core.symlinks will be\nset depending on the capabilities of the operating system and Java\nruntime.\n\nIf core.symlinks is set to true, the assumption is that symlinks are\nsupported, which may result in runtime errors if this turns out not to\nbe the case.\n\nMeasuring the cost of jgit status on a repository with ~70000 files,\nof which ~30000 are tracked reveals a penalty of about 10% for using\nthe Java7 (really NIO2) support module.\n\nBug: 354367\nChange-Id: I12f0fdd9d26212324a586896ef7eb1f6ff89c39c\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
            "commitDate": "10/02/14 1:53 PM",
            "commitName": "078a9f60664fee1f7e85f0c3ab3fd067c0f674cc",
            "commitAuthor": "Robin Rosenberg",
            "commitDateOld": "05/02/14 1:47 AM",
            "commitNameOld": "e03f18941f5d996d23bc004ad63049bcfc0e53d3",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 5.5,
            "commitsBetweenForRepo": 4,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,430 +1,429 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n-\t\t// \"file\",\n-\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n-\t\t// non-existing\n+\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n+\t\t// non-existing. Symbolic links and git links are treated as File here.\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n \t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File doesn't exist or is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File exists and is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\", a \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing. Symbolic links and git links are treated as File here.\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File doesn't exist or is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File exists and is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "14"
        },
        "5404e70dc64201786cd6a21efb41310912860122": {
            "type": "Ybodychange",
            "commitMessage": "Fix for core.autocrlf=input resulting in modified file\n\nThis version does not attempt to unsmudge, unlike the first attempt\nin Idafad150553df14827eccfde2e3b95760e16a8b6.\n\nBug: 372834\nChange-Id: I9300e735cb16d6208e1df963abb1ff69f688155d\nAlso-by: Robin Stocker <robin@nibor.org>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\nSigned-off-by: Robin Stocker <robin@nibor.org>\n",
            "commitDate": "02/02/14 4:16 AM",
            "commitName": "5404e70dc64201786cd6a21efb41310912860122",
            "commitAuthor": "Robin Rosenberg",
            "commitDateOld": "03/12/13 2:10 PM",
            "commitNameOld": "e0502ebb032f78227437a7863eea9ca91678e593",
            "commitAuthorOld": "Robin Stocker",
            "daysBetweenCommits": 60.59,
            "commitsBetweenForRepo": 35,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,424 +1,430 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null)\n \t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n-\t\t\t\t\tif (f == null || f.isModified(dce, true))\n+\t\t\t\t\tif (f == null\n+\t\t\t\t\t\t\t|| f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n-\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n+\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n-\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n+\t\t\t\t\t\tif (f == null\n+\t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n \t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n-\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n+\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n \t\t\t\t\t\t// File doesn't exist or is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File exists and is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader())))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t\t|| f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tthis.walk.getObjectReader()))) {\n\t\t\t\t\t\t// File doesn't exist or is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File exists and is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "11"
        },
        "e0502ebb032f78227437a7863eea9ca91678e593": {
            "type": "Ybodychange",
            "commitMessage": "More helpful InvalidPathException messages (include reason)\n\nInstead of just a generic \"Invalid path: $path\", add a reason for the\ncases where it's not obvious what the problem is (e.g. \"aux\" being\nreserved on Windows).\n\nBug: 413915\nChange-Id: Ia6436bd2560e4f049c92d9aac907cb87348605e0\nSigned-off-by: Robin Stocker <robin@nibor.org>\n",
            "commitDate": "03/12/13 2:10 PM",
            "commitName": "e0502ebb032f78227437a7863eea9ca91678e593",
            "commitAuthor": "Robin Stocker",
            "commitDateOld": "29/11/13 1:32 PM",
            "commitNameOld": "af40635aba91a78ec248503906996ca89898e888",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 4.03,
            "commitsBetweenForRepo": 6,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,424 +1,424 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n-\t\tif (m != null && !isValidPath(m))\n-\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n+\t\tif (m != null)\n+\t\t\tcheckValidPath(m);\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 5b 6 6b\n \t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n \t\t\t\t\tkeep(dce); // 5 6\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n \t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\t// File doesn't exist or is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File exists and is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null)\n\t\t\tcheckValidPath(m);\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\t// File doesn't exist or is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File exists and is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "4"
        },
        "af40635aba91a78ec248503906996ca89898e888": {
            "type": "Ybodychange",
            "commitMessage": "Fix handling of file/folder conflicts during a checkout\n\nJGit was not handling certain file/folder conflicts during a checkout\ncorrectly. This was reported by Axel Richard in\nhttp://dev.eclipse.org/mhonarc/lists/jgit-dev/msg02358.html.\nThis commit fixes this problem.\n\nStill JGit behaves intentionally different than native git.\nIf HEAD contains a tree, and workingtree, Index and Merge contain a file\nwith same content ... then JGit allows a conflict free checkout of\nMerge. Native git always complains that it doesn't want to overwrite\nlocal changes. But there is no need to update the working tree because\nIndex and Merge are already equal.\n\nA shell script which shows how native git behaves can be found here.\nhttps://gist.github.com/chalstrick/7694959#file-gistfile1-sh\n\nChange-Id: Ifd6a68974d61cd4fa23bc575f3a40773db66cafc\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
            "commitDate": "29/11/13 1:32 PM",
            "commitName": "af40635aba91a78ec248503906996ca89898e888",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "01/11/13 8:43 AM",
            "commitNameOld": "98bc384d2bd62f3abe7f8b14d8098b3445b6b6e3",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 28.24,
            "commitsBetweenForRepo": 42,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,418 +1,424 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null && !isValidPath(m))\n \t\t\tthrow new InvalidPathException(m.getEntryPathString());\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n+\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n+\t\t * 6b   D        F       F       N         N       N       N           Conflict\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n-\t\t\tcase 0xDFF: // 5 6\n+\t\t\tcase 0xDFF: // 5 5b 6 6b\n+\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n+\t\t\t\t\tkeep(dce); // 5 6\n+\t\t\t\telse\n+\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// Nothing in Index\n \t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t\t// -> only Merge contains something for this path. Use it!\n \t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> only Head contains something for this path and it should\n \t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Nothing in Index\n \t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n \t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n \t\t\t\t// called before). Ignore the cached deletion and use what we\n \t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n \t\t\t// Something in Index\n \t\t\tif (h == null) {\n \t\t\t\t// Nothing in Head\n \t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\t// No file or file is dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n \t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n \t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// A file is present and file is not dirty\n \t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n \t\t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n \t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n \t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Something in Merge or current path is not part of\n \t\t\t\t\t\t// File/Folder conflict\n \t\t\t\t\t\t// Merge contains nothing or the same as Index\n \t\t\t\t\t\t// Nothing in Head\n \t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\t// Merge contains something and it is not the same as Index\n \t\t\t\t\t// Nothing in Head\n \t\t\t\t\t// Something in Index\n \t\t\t\t\t// -> Index contains something new (different from Head)\n \t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \t\t\t\t// Nothing in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// A submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\t// file is dirty\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n \t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\t// file doesn't exist or is clean\n \t\t\t\t\t\t\t// Index contains the same as Head\n \t\t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\t// Index contains something different from Head\n \t\t\t\t\t\t// Something different from a submodule in Index\n \t\t\t\t\t\t// Nothing in Merge\n \t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n \t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n \t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// Something in Merge\n \t\t\t\t// Something in Head\n \t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n \t\t\t\t\t// other\n \t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n \t\t\t\t\t\t// differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n \t\t\t\t\t\t// Potentially updates the file\n \n \t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n \t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\t// File doesn't exist or is dirty\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Merge wants the index and file to be updated\n \t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\t// File exists and is clean\n \t\t\t\t\t\t// Head and Index don't contain a submodule\n \t\t\t\t\t\t// Head contains the same as Index. Merge differs\n \t\t\t\t\t\t// Something in Merge\n \t\t\t\t\t\t// -> Standard case when switching between branches:\n \t\t\t\t\t\t// Nothing new in index but something different in\n \t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\t// Head differs from index or merge is same as index\n \t\t\t\t\t// At least two of the contents of Head, Index, Merge\n \t\t\t\t\t// are the same\n \t\t\t\t\t// Something in Merge\n \t\t\t\t\t// Something in Head\n \t\t\t\t\t// Something in Index\n \n \t\t\t\t\t// Can be formulated as: Either all three states are\n \t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n \t\t\t\t\t// to the other one.\n \t\t\t\t\t// -> In all three cases we don't touch index and file.\n \n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null && !isValidPath(m))\n\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 5b   D        F       F       Y         N       N       N           Conflict\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 6b   D        F       F       N         N       N       N           Conflict\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 5b 6 6b\n\t\t\t\tif (equalIdAndMode(iId, iMode, mId, mMode))\n\t\t\t\t\tkeep(dce); // 5 6\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m); // 5b 6b\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\t// File doesn't exist or is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File exists and is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "1c4ee41dc093266c19d4452879afe5c0f7f387f4": {
            "type": "Ybodychange",
            "commitMessage": "Add better documentation to DirCacheCheckout\n\nChange-Id: I282b702d9e4cb19063d8e9503604538f80e955b7\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\n",
            "commitDate": "06/02/13 3:05 PM",
            "commitName": "1c4ee41dc093266c19d4452879afe5c0f7f387f4",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "27/12/12 7:57 AM",
            "commitNameOld": "c310fa0c802f40a774edb58641de3ac5bfad0e2c",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 41.3,
            "commitsBetweenForRepo": 62,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,280 +1,418 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null && !isValidPath(m))\n \t\t\tthrow new InvalidPathException(m.getEntryPathString());\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Keep\n \t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n+\t\t\t// Nothing in Index\n+\t\t\t// At least one of Head, Index, Merge is not empty\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t          I (index)     H        M     H==M  Result\n \t\t\t * \t        -------------------------------------------\n \t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n \t\t\t * \t        1 nothing    nothing  exists         use M\n \t\t\t * \t        2 nothing    exists   nothing        remove path from index\n \t\t\t * \t        3 nothing    exists   exists   yes   keep index\n \t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n+\t\t\t\t// Nothing in Head\n+\t\t\t\t// Nothing in Index\n+\t\t\t\t// At least one of Head, Index, Merge is not empty\n+\t\t\t\t// -> only Merge contains something for this path. Use it!\n+\t\t\t\t// Potentially update the file\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n+\t\t\t\t// Nothing in Merge\n+\t\t\t\t// Something in Head\n+\t\t\t\t// Nothing in Index\n+\t\t\t\t// -> only Head contains something for this path and it should\n+\t\t\t\t// be deleted. Potentially removes the file!\n \t\t\t\tremove(name); // 2\n \t\t\telse { // 3\n+\t\t\t\t// Something in Merge\n+\t\t\t\t// Something in Head\n+\t\t\t\t// Nothing in Index\n+\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n+\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n+\t\t\t\t// called before). Ignore the cached deletion and use what we\n+\t\t\t\t// find in Merge. Potentially updates the file.\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n \t\t\t\t\tkeep(dce);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t}\n \t\t} else {\n+\t\t\t// Something in Index\n \t\t\tif (h == null) {\n+\t\t\t\t// Nothing in Head\n+\t\t\t\t// Something in Index\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n+\t\t\t\t\t// Merge contains nothing or the same as Index\n+\t\t\t\t\t// Nothing in Head\n+\t\t\t\t\t// Something in Index\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n+\t\t\t\t\t\t// Nothing in Merge and current path is part of\n+\t\t\t\t\t\t// File/Folder conflict\n+\t\t\t\t\t\t// Nothing in Head\n+\t\t\t\t\t\t// Something in Index\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n+\t\t\t\t\t\t\t// No file or file is dirty\n+\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n+\t\t\t\t\t\t\t// File/Folder conflict\n+\t\t\t\t\t\t\t// Nothing in Head\n+\t\t\t\t\t\t\t// Something in Index\n+\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n+\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n+\t\t\t\t\t\t\t// report a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n+\t\t\t\t\t\t\t// A file is present and file is not dirty\n+\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n+\t\t\t\t\t\t\t// File/Folder conflict\n+\t\t\t\t\t\t\t// Nothing in Head\n+\t\t\t\t\t\t\t// Something in Index\n+\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n+\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n+\t\t\t\t\t\t\t// file and index entry\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n+\t\t\t\t\t\t// Something in Merge or current path is not part of\n+\t\t\t\t\t\t// File/Folder conflict\n+\t\t\t\t\t\t// Merge contains nothing or the same as Index\n+\t\t\t\t\t\t// Nothing in Head\n+\t\t\t\t\t\t// Something in Index\n+\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n+\t\t\t\t\t// Merge contains something and it is not the same as Index\n+\t\t\t\t\t// Nothing in Head\n+\t\t\t\t\t// Something in Index\n+\t\t\t\t\t// -> Index contains something new (different from Head)\n+\t\t\t\t\t// and Merge is different from Index. Report a conflict\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n+\t\t\t\t// Nothing in Merge\n+\t\t\t\t// Something in Head\n+\t\t\t\t// Something in Index\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n+\t\t\t\t\t// A submodule in Index\n+\t\t\t\t\t// Nothing in Merge\n+\t\t\t\t\t// Something in Head\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n+\t\t\t\t\t// Something different from a submodule in Index\n+\t\t\t\t\t// Nothing in Merge\n+\t\t\t\t\t// Something in Head\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n+\t\t\t\t\t\t// Index contains the same as Head\n+\t\t\t\t\t\t// Something different from a submodule in Index\n+\t\t\t\t\t\t// Nothing in Merge\n+\t\t\t\t\t\t// Something in Head\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n+\t\t\t\t\t\t\t// file is dirty\n+\t\t\t\t\t\t\t// Index contains the same as Head\n+\t\t\t\t\t\t\t// Something different from a submodule in Index\n+\t\t\t\t\t\t\t// Nothing in Merge\n+\t\t\t\t\t\t\t// Something in Head\n+\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n+\t\t\t\t\t\t\t// a conflict\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n+\t\t\t\t\t\t\t// file doesn't exist or is clean\n+\t\t\t\t\t\t\t// Index contains the same as Head\n+\t\t\t\t\t\t\t// Something different from a submodule in Index\n+\t\t\t\t\t\t\t// Nothing in Merge\n+\t\t\t\t\t\t\t// Something in Head\n+\t\t\t\t\t\t\t// -> Remove from index and delete the file\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n+\t\t\t\t\t\t// Index contains something different from Head\n+\t\t\t\t\t\t// Something different from a submodule in Index\n+\t\t\t\t\t\t// Nothing in Merge\n+\t\t\t\t\t\t// Something in Head\n+\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n+\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n+\t\t\t\t\t\t// Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n+\t\t\t\t// Something in Merge\n+\t\t\t\t// Something in Head\n+\t\t\t\t// Something in Index\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n+\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n+\t\t\t\t\t// other\n+\t\t\t\t\t// -> All contents differ. Report a conflict.\n \t\t\t\t\tconflict(name, dce, h, m);\n-\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n+\t\t\t\telse\n+\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n+\t\t\t\t\t// are the same\n+\t\t\t\t\t// Something in Merge\n+\t\t\t\t\t// Something in Head\n+\t\t\t\t\t// Something in Index\n+\n+\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n+\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n+\t\t\t\t\t\t// Something in Merge\n+\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n+\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n+\t\t\t\t\t\t// differs\n+\t\t\t\t\t\t// Something in Merge\n+\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n+\t\t\t\t\t\t// Potentially updates the file\n+\n+\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n+\t\t\t\t\t\t// file content\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n+\t\t\t\t\t\t// File doesn't exist or is dirty\n+\t\t\t\t\t\t// Head and Index don't contain a submodule\n+\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n+\t\t\t\t\t\t// Something in Merge\n+\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n+\t\t\t\t\t\t// but the file is dirty. Report a conflict\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n+\t\t\t\t\t\t// File exists and is clean\n+\t\t\t\t\t\t// Head and Index don't contain a submodule\n+\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n+\t\t\t\t\t\t// Something in Merge\n+\t\t\t\t\t\t// -> Standard case when switching between branches:\n+\t\t\t\t\t\t// Nothing new in index but something different in\n+\t\t\t\t\t\t// Merge. Update index and file\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n+\t\t\t\t\t// Head differs from index or merge is same as index\n+\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n+\t\t\t\t\t// are the same\n+\t\t\t\t\t// Something in Merge\n+\t\t\t\t\t// Something in Head\n+\t\t\t\t\t// Something in Index\n+\n+\t\t\t\t\t// Can be formulated as: Either all three states are\n+\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n+\t\t\t\t\t// to the other one.\n+\t\t\t\t\t// -> In all three cases we don't touch index and file.\n+\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null && !isValidPath(m))\n\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// Nothing in Index\n\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// At least one of Head, Index, Merge is not empty\n\t\t\t\t// -> only Merge contains something for this path. Use it!\n\t\t\t\t// Potentially update the file\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> only Head contains something for this path and it should\n\t\t\t\t// be deleted. Potentially removes the file!\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Nothing in Index\n\t\t\t\t// -> Head and Merge contain something (maybe not the same) and\n\t\t\t\t// in the index there is nothing (e.g. 'git rm ...' was\n\t\t\t\t// called before). Ignore the cached deletion and use what we\n\t\t\t\t// find in Merge. Potentially updates the file.\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\t// Something in Index\n\t\t\tif (h == null) {\n\t\t\t\t// Nothing in Head\n\t\t\t\t// Something in Index\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\t// No file or file is dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this\n\t\t\t\t\t\t\t// path to be removed. Since the file is dirty\n\t\t\t\t\t\t\t// report a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// A file is present and file is not dirty\n\t\t\t\t\t\t\t// Nothing in Merge and current path is part of\n\t\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t\t// -> File folder conflict and Merge wants this path\n\t\t\t\t\t\t\t// to be removed. Since the file is not dirty remove\n\t\t\t\t\t\t\t// file and index entry\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Something in Merge or current path is not part of\n\t\t\t\t\t\t// File/Folder conflict\n\t\t\t\t\t\t// Merge contains nothing or the same as Index\n\t\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t\t// Something in Index\n\t\t\t\t\t\t// -> Merge contains nothing new. Keep the index.\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\t// Merge contains something and it is not the same as Index\n\t\t\t\t\t// Nothing in Head\n\t\t\t\t\t// Something in Index\n\t\t\t\t\t// -> Index contains something new (different from Head)\n\t\t\t\t\t// and Merge is different from Index. Report a conflict\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\t\t\t\t// Nothing in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// A submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\t// file is dirty\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> file is dirty but is should be removed. That's\n\t\t\t\t\t\t\t// a conflict\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t// file doesn't exist or is clean\n\t\t\t\t\t\t\t// Index contains the same as Head\n\t\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t\t// -> Remove from index and delete the file\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\t// Index contains something different from Head\n\t\t\t\t\t\t// Something different from a submodule in Index\n\t\t\t\t\t\t// Nothing in Merge\n\t\t\t\t\t\t// Something in Head\n\t\t\t\t\t\t// -> Something new is in index (and maybe even on the\n\t\t\t\t\t\t// filesystem). But Merge wants the path to be removed.\n\t\t\t\t\t\t// Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Something in Merge\n\t\t\t\t// Something in Head\n\t\t\t\t// Something in Index\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\t// All three contents in Head, Merge, Index differ from each\n\t\t\t\t\t// other\n\t\t\t\t\t// -> All contents differ. Report a conflict.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\t// Index and Head contain the same submodule. Merge\n\t\t\t\t\t\t// differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Nothing new in index. Move to merge.\n\t\t\t\t\t\t// Potentially updates the file\n\n\t\t\t\t\t\t// TODO check that we don't overwrite some unsaved\n\t\t\t\t\t\t// file content\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\t// File doesn't exist or is dirty\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Merge wants the index and file to be updated\n\t\t\t\t\t\t// but the file is dirty. Report a conflict\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// File exists and is clean\n\t\t\t\t\t\t// Head and Index don't contain a submodule\n\t\t\t\t\t\t// Head contains the same as Index. Merge differs\n\t\t\t\t\t\t// Something in Merge\n\t\t\t\t\t\t// -> Standard case when switching between branches:\n\t\t\t\t\t\t// Nothing new in index but something different in\n\t\t\t\t\t\t// Merge. Update index and file\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Head differs from index or merge is same as index\n\t\t\t\t\t// At least two of the contents of Head, Index, Merge\n\t\t\t\t\t// are the same\n\t\t\t\t\t// Something in Merge\n\t\t\t\t\t// Something in Head\n\t\t\t\t\t// Something in Index\n\n\t\t\t\t\t// Can be formulated as: Either all three states are\n\t\t\t\t\t// equal or Merge is equal to Head or Index and differs\n\t\t\t\t\t// to the other one.\n\t\t\t\t\t// -> In all three cases we don't touch index and file.\n\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "51c20b27acdef57dcb1d79ac995cd49f2e9c2f91": {
            "type": "Ybodychange",
            "commitMessage": "DirCacheCheckout: Fix handling of files not in index\n\nWhen a file is not in the index and neither contents nor mode differ\nbetween \"head\" and \"merge\", the index state should be kept. If they\ndiffer, a checkout conflict should occur. This is described in Git's\ngit-read-tree.txt.\n\nJGit used to replace the index state with \"merge\" in both of the above\ncases.\n\nA confusing effect of this was that when one removed a file and then did\na rebase, the file silently reappeared again.\n\nThe changes to dir/file conflict handling are a consequence of this\nchange, as the index handling change made tests in DirCacheCheckoutTest\nbreak. I compared these cases to C Git and the new behavior there also\nmatches what C Git does.\n\nBug: 387390\nChange-Id: I5beb781f12172a68f98c67d4c8029eb51ceae62d\nSigned-off-by: Robin Stocker <robin@nibor.org>\n",
            "commitDate": "01/09/12 4:29 AM",
            "commitName": "51c20b27acdef57dcb1d79ac995cd49f2e9c2f91",
            "commitAuthor": "Robin Stocker",
            "commitDateOld": "21/08/12 3:37 PM",
            "commitNameOld": "9570e0d4a9783df132cc117827275eb5724d41d6",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 10.54,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,278 +1,280 @@\n \tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (m != null && !isValidPath(m))\n \t\t\tthrow new InvalidPathException(m.getEntryPathString());\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n-\t\t * 3    D        F       D                 Y       N       N           Update\n-\t\t * 4    D        F       D                 N       N       N           Update\n+\t\t * 3    D        F       D                 Y       N       N           Keep\n+\t\t * 4    D        F       D                 N       N       N           Conflict\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n-\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n-\t\t\t\t// that's what our tests expect\n-\t\t\t\t// updated.put(name, mId);\n-\t\t\t\tremove(name);\n+\t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n-\t\t\t * \t\t    I (index)                H        M        Result\n-\t\t\t * \t        -------------------------------------------------------\n-\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n-\t\t\t * \t        1 nothing             nothing  exists   use M\n-\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n-\t\t\t * \t        3 nothing             exists   exists   use M\n+\t\t\t * \t          I (index)     H        M     H==M  Result\n+\t\t\t * \t        -------------------------------------------\n+\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n+\t\t\t * \t        1 nothing    nothing  exists         use M\n+\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n+\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n+\t\t\t * \t          nothing    exists   exists   no    fail\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n-\t\t\telse\n-\t\t\t\tupdate(name, mId, mMode); // 3\n+\t\t\telse { // 3\n+\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n+\t\t\t\t\tkeep(dce);\n+\t\t\t\telse\n+\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t}\n \t\t} else {\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null && !isValidPath(m))\n\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Keep\n\t\t * 4    D        F       D                 N       N       N           Conflict\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t          I (index)     H        M     H==M  Result\n\t\t\t * \t        -------------------------------------------\n\t\t\t * \t        0 nothing    nothing  nothing        (does not happen)\n\t\t\t * \t        1 nothing    nothing  exists         use M\n\t\t\t * \t        2 nothing    exists   nothing        remove path from index\n\t\t\t * \t        3 nothing    exists   exists   yes   keep index\n\t\t\t * \t          nothing    exists   exists   no    fail\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse { // 3\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode))\n\t\t\t\t\tkeep(dce);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t}\n\t\t} else {\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "42d7565ba9b97effdee3f737e32541b26b7341ab": {
            "type": "Ymultichange(Yparameterchange,Ybodychange)",
            "commitMessage": "Validate paths during DirCheckout\n\nDirCacheCheckout and CanonicalTreeParser cooperate. CanonicalTreeParser\ncan detect malformed, potentially malicious tree entries and sets a\nflag, while DirCacheCheckout refuses to work with such paths.\n\nMalicious tree entries are \".\", \"..\", \".git\" (case insensitive), any\nname containing '/' and (on Windows '\\') and also (on Windows)\nany paths ending in a combination of '.' or space or containing a ':'.\nWe also forbid all special names like \"con\" etc on Windows.\n\nSome of the test can execute on any platform by enabling partial\nplatform emulation.\n\nA new runtime exception, InvalidPathException, is introduced. For\nbackwards compatibility it extends InvalidArgumentException.\n\nChange-Id: I86199105814b63d4340e5de0e471d0da6b579ead\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
            "commitDate": "23/04/12 1:37 PM",
            "commitName": "42d7565ba9b97effdee3f737e32541b26b7341ab",
            "commitAuthor": "Robin Rosenberg",
            "subchanges": [
                {
                    "type": "Yparameterchange",
                    "commitMessage": "Validate paths during DirCheckout\n\nDirCacheCheckout and CanonicalTreeParser cooperate. CanonicalTreeParser\ncan detect malformed, potentially malicious tree entries and sets a\nflag, while DirCacheCheckout refuses to work with such paths.\n\nMalicious tree entries are \".\", \"..\", \".git\" (case insensitive), any\nname containing '/' and (on Windows '\\') and also (on Windows)\nany paths ending in a combination of '.' or space or containing a ':'.\nWe also forbid all special names like \"con\" etc on Windows.\n\nSome of the test can execute on any platform by enabling partial\nplatform emulation.\n\nA new runtime exception, InvalidPathException, is introduced. For\nbackwards compatibility it extends InvalidArgumentException.\n\nChange-Id: I86199105814b63d4340e5de0e471d0da6b579ead\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
                    "commitDate": "23/04/12 1:37 PM",
                    "commitName": "42d7565ba9b97effdee3f737e32541b26b7341ab",
                    "commitAuthor": "Robin Rosenberg",
                    "commitDateOld": "17/04/12 12:51 AM",
                    "commitNameOld": "95ed300b04f52e6d0625dfb5a6e0e52aac4bc412",
                    "commitAuthorOld": "Robin Rosenberg",
                    "daysBetweenCommits": 6.53,
                    "commitsBetweenForRepo": 3,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,275 +1,278 @@\n-\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n+\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n+\t\tif (m != null && !isValidPath(m))\n+\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n+\n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, mMode); // 3\n \t\t} else {\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
                    "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null && !isValidPath(m))\n\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, mMode); // 3\n\t\t} else {\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
                    "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
                    "extendedDetails": {
                        "oldValue": "[h-AbstractTreeIterator, m-AbstractTreeIterator, i-DirCacheBuildIterator, f-WorkingTreeIterator]",
                        "newValue": "[h-CanonicalTreeParser, m-CanonicalTreeParser, i-DirCacheBuildIterator, f-WorkingTreeIterator]"
                    }
                },
                {
                    "type": "Ybodychange",
                    "commitMessage": "Validate paths during DirCheckout\n\nDirCacheCheckout and CanonicalTreeParser cooperate. CanonicalTreeParser\ncan detect malformed, potentially malicious tree entries and sets a\nflag, while DirCacheCheckout refuses to work with such paths.\n\nMalicious tree entries are \".\", \"..\", \".git\" (case insensitive), any\nname containing '/' and (on Windows '\\') and also (on Windows)\nany paths ending in a combination of '.' or space or containing a ':'.\nWe also forbid all special names like \"con\" etc on Windows.\n\nSome of the test can execute on any platform by enabling partial\nplatform emulation.\n\nA new runtime exception, InvalidPathException, is introduced. For\nbackwards compatibility it extends InvalidArgumentException.\n\nChange-Id: I86199105814b63d4340e5de0e471d0da6b579ead\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
                    "commitDate": "23/04/12 1:37 PM",
                    "commitName": "42d7565ba9b97effdee3f737e32541b26b7341ab",
                    "commitAuthor": "Robin Rosenberg",
                    "commitDateOld": "17/04/12 12:51 AM",
                    "commitNameOld": "95ed300b04f52e6d0625dfb5a6e0e52aac4bc412",
                    "commitAuthorOld": "Robin Rosenberg",
                    "daysBetweenCommits": 6.53,
                    "commitsBetweenForRepo": 3,
                    "commitsBetweenForFile": 1,
                    "diff": "@@ -1,275 +1,278 @@\n-\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n+\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n+\t\tif (m != null && !isValidPath(m))\n+\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n+\n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, mMode); // 3\n \t\t} else {\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
                    "actualSource": "\tvoid processEntry(CanonicalTreeParser h, CanonicalTreeParser m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (m != null && !isValidPath(m))\n\t\t\tthrow new InvalidPathException(m.getEntryPathString());\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, mMode); // 3\n\t\t} else {\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
                    "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
                    "extendedDetails": {}
                }
            ],
            "BugCommit": "0",
            "TangledWMoveandFileRename": "6"
        },
        "d364fb2d4f17866162a206d10ff89e19be7ac8e3": {
            "type": "Ybodychange",
            "commitMessage": "Remove null access warning in DirCacheCheckout\n\nInitially fill in the current DirCacheEntry field guarding \nagainst a null index tree and use that variable instead of\ncalling getDirCacheEntry() on a possibly null DirCacheBuildIterator.\n\nChange-Id: I16f388a16636aefdb07d66dae5d05655009e2a0e\n",
            "commitDate": "02/03/12 3:01 PM",
            "commitName": "d364fb2d4f17866162a206d10ff89e19be7ac8e3",
            "commitAuthor": "Kevin Sawicki",
            "commitDateOld": "29/02/12 3:07 PM",
            "commitNameOld": "0fb0e8440507e3e969432ea1115b806e5e04138c",
            "commitAuthorOld": "Kevin Sawicki",
            "daysBetweenCommits": 2.0,
            "commitsBetweenForRepo": 13,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,277 +1,275 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n-\t\tDirCacheEntry dce;\n+\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n+\t\t\t\t\tconflict(name, dce, h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n-\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n+\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n-\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n+\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n-\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\tkeep(dce);\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n-\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n-\t\t\t\t\tdce = i.getDirCacheEntry();\n+\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n-\t\t\t\t} else\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\telse\n+\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n-\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\tkeep(dce);\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, mMode); // 3\n \t\t} else {\n-\t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n-\t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n+\t\t\t\tif (iMode == FileMode.GITLINK) {\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce = i != null ? i.getDirCacheEntry() : null;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, dce, h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, dce, h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(dce);\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode))\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(dce);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, mMode); // 3\n\t\t} else {\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (iMode == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "0fb0e8440507e3e969432ea1115b806e5e04138c": {
            "type": "Ybodychange",
            "commitMessage": "Reuse existing modes and ids\n\nThis change replaces calls to getEntryObjectId and getEntryFileMode\nwith the existing method local variables for the index, merge, and\nhead tree iterators.\n\nChange-Id: I75d1edfdd192a009fc916102ec052434c6302d00\n",
            "commitDate": "29/02/12 3:07 PM",
            "commitName": "0fb0e8440507e3e969432ea1115b806e5e04138c",
            "commitAuthor": "Kevin Sawicki",
            "commitDateOld": "13/02/12 12:39 AM",
            "commitNameOld": "ed7b322186a872bdd4f41a1a31554a7e90d74de6",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 16.6,
            "commitsBetweenForRepo": 10,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,279 +1,277 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n \t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n \t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n-\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n+\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n-\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n-\t\t\t\t\t: 0x0F0;\n+\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n \t\tif (m != null)\n-\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n-\t\t\t\t\t: 0x00F;\n+\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n-\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n+\t\t\t\t\tupdate(name, mId, mMode); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n-\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n-\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n+\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n \t\t\t\t} else if (!isModified(name))\n-\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n+\t\t\t\t\tupdate(name, mId, mMode); // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n-\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n-\t\t\t\tif (!FileMode.GITLINK.equals(m.getEntryFileMode())) {\n+\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n \t\t\t\t\tif (mId == null\n \t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n \t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n-\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n+\t\t\t\tupdate(name, mId, mMode); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n-\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n+\t\t\t\tupdate(name, mId, mMode); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n \t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n \t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n \t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n-\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\t\t\tupdate(name, mId, mMode);\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(hMode) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(iMode) ? 0x0D0 : 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(mMode) ? 0x00D : 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, mId, mMode); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, mMode); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode); // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(mMode)) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, mMode); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, mMode); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, mMode);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "ed7b322186a872bdd4f41a1a31554a7e90d74de6": {
            "type": "Ybodychange",
            "commitMessage": "Generate conflicts and index updates on file mode changes\n\nHandle more cases for file mode changes. Especially make sure that the\nfollowing cases are handled correctly.\n\nCase 1)\n\n  An entry in the working tree, HEAD tree, and merge tree have\n  different modes and different content.\n\n  Prior Outcome:\n    Dirty working tree content is replaced and file mode\n    changes are lost.\n\n  New Outcome:\n    Conflict is generated.\n\nCase 2)\n\n  An entry in the index and merge tree have the same content\n  but different modes but both modes are file type modes.\n\n  Prior Outcome:\n    File mode in working tree is not updated and the working\n    directory is dirty.\n\n  New Outcome:\n    Index is updated and the working directory is clean.\n\nBug: 363772\nChange-Id: I224602d68228eb419813986807f1eeab77e9c302\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nAlso-by: Kevin Sawicki <kevin@github.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\n",
            "commitDate": "13/02/12 12:39 AM",
            "commitName": "ed7b322186a872bdd4f41a1a31554a7e90d74de6",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "10/01/12 2:15 PM",
            "commitNameOld": "76dd9d1d46007fc49639d264631658114f4fbd24",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 33.43,
            "commitsBetweenForRepo": 21,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,271 +1,279 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n+\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n+\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n+\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n-\t\t\t\t// if (!iId.equals(mId))\n+\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n-\t\t\t\tif (hId.equals(mId)) {\n+\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n-\t\t\t\tif (hId.equals(iId)) {\n+\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// A submodule is not a file. We should ignore it\n \t\t\t\tif (!FileMode.GITLINK.equals(m.getEntryFileMode())) {\n \t\t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t\t// workingtree-file\n-\t\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n+\t\t\t\t\tif (mId == null\n+\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n+\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n \t\t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n-\t\t\t\tif (m == null || mId.equals(iId)) {\n+\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n \t\t\t\t\t// Submodules that disappear from the checkout must\n \t\t\t\t\t// be removed from the index, but not deleted from disk.\n \t\t\t\t\tremove(name);\n \t\t\t\t} else {\n-\t\t\t\t\tif (hId.equals(iId)) {\n+\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n \t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t}\n \t\t\t} else {\n-\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n+\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n+\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n+\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n \t\t\t\t\tconflict(name, dce, h, m);\n-\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n+\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n+\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n \t\t\t\t\t// For submodules just update the index with the new SHA-1\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t\t} else if (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t} else {\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\t\tFileMode iMode = (i == null ? null : i.getEntryFileMode());\n\t\tFileMode mMode = (m == null ? null : m.getEntryFileMode());\n\t\tFileMode hMode = (h == null ? null : h.getEntryFileMode());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!equalIdAndMode(iId, iMode, mId, mMode)\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (equalIdAndMode(hId, hMode, mId, mMode)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(m.getEntryFileMode())) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null\n\t\t\t\t\t\t\t|| !equalIdAndMode(mId, mMode,\n\t\t\t\t\t\t\t\t\tf.getEntryObjectId(), f.getEntryFileMode())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (equalIdAndMode(hId, hMode, iId, iMode)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!equalIdAndMode(hId, hMode, mId, mMode)\n\t\t\t\t\t\t&& !equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (equalIdAndMode(hId, hMode, iId, iMode)\n\t\t\t\t\t\t&& !equalIdAndMode(mId, mMode, iId, iMode)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "576abf64d138606814e4b67c8110c4ee1ae1b2ac": {
            "type": "Ybodychange",
            "commitMessage": "Ignore submodule on checkout instead of deleting it\n\nThe purpose of this commit is to prevent destruction of\nsubmodules on checkout from a tree with a submodule to\nanother. For consistency we handle the reverse case too,\nwhen we checkout a branch that has a submodule and the\nsubmodule directory exists. And finally we ignore the\ncase where the submodule changes.\n\nWe do not update the submodules, we just try to ignore\nthem harder.\n\nBug: 356664\nChange-Id: I202c695a57af99b13d0d7220803fd08def3d9b5e\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\n",
            "commitDate": "08/09/11 7:46 AM",
            "commitName": "576abf64d138606814e4b67c8110c4ee1ae1b2ac",
            "commitAuthor": "Robin Rosenberg",
            "commitDateOld": "08/09/11 7:46 AM",
            "commitNameOld": "2bb8da040578d98b4d1c4ee3c1287e115a36efa3",
            "commitAuthorOld": "Robin Rosenberg",
            "daysBetweenCommits": 0.0,
            "commitsBetweenForRepo": 1,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,256 +1,271 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n-\t\t\t\t// a dirty worktree: the index is empty but we have a\n-\t\t\t\t// workingtree-file\n-\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n-\t\t\t\t\tconflict(name, null, h, m);\n-\t\t\t\t\treturn;\n+\t\t\t\t// A submodule is not a file. We should ignore it\n+\t\t\t\tif (!FileMode.GITLINK.equals(m.getEntryFileMode())) {\n+\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n+\t\t\t\t\t// workingtree-file\n+\t\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n+\t\t\t\t\t\tconflict(name, null, h, m);\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n-\t\t\t\tif (hId.equals(iId)) {\n-\t\t\t\t\tif (f == null || f.isModified(dce, true))\n+\t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n+\t\t\t\t\t// Submodules that disappear from the checkout must\n+\t\t\t\t\t// be removed from the index, but not deleted from disk.\n+\t\t\t\t\tremove(name);\n+\t\t\t\t} else {\n+\t\t\t\t\tif (hId.equals(iId)) {\n+\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n+\t\t\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tremove(name);\n+\t\t\t\t\t} else\n \t\t\t\t\t\tconflict(name, dce, h, m);\n-\t\t\t\t\telse\n-\t\t\t\t\t\tremove(name);\n-\t\t\t\t} else\n-\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n \t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n-\t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n-\t\t\t\t\t\tconflict(name, dce, h, m);\n-\t\t\t\t\telse\n+\t\t\t\t\t// For submodules just update the index with the new SHA-1\n+\t\t\t\t\tif (dce != null\n+\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\t\t} else if (dce != null\n+\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n+\t\t\t\t\t\tconflict(name, dce, h, m);\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\t\t}\n \t\t\t\t} else {\n \t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// A submodule is not a file. We should ignore it\n\t\t\t\tif (!FileMode.GITLINK.equals(m.getEntryFileMode())) {\n\t\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t\t// workingtree-file\n\t\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n\t\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (dce.getFileMode() == FileMode.GITLINK) {\n\t\t\t\t\t// Submodules that disappear from the checkout must\n\t\t\t\t\t// be removed from the index, but not deleted from disk.\n\t\t\t\t\tremove(name);\n\t\t\t\t} else {\n\t\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\t// For submodules just update the index with the new SHA-1\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& FileMode.GITLINK.equals(dce.getFileMode())) {\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t\t} else if (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true))) {\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "2bb8da040578d98b4d1c4ee3c1287e115a36efa3": {
            "type": "Ybodychange",
            "commitMessage": "cleanup: Reuse local variable for current DirCacheEntry\n\nSince we already have assigned i.getDirCacheEntry() to dce,\nuse dce instead.\n\nChange-Id: I107713ad0b356516d75c29203f945b056bad3ac7\nSigned-off-by: Robin Rosenberg <robin.rosenberg@dewire.com>\n",
            "commitDate": "08/09/11 7:46 AM",
            "commitName": "2bb8da040578d98b4d1c4ee3c1287e115a36efa3",
            "commitAuthor": "Robin Rosenberg",
            "commitDateOld": "02/08/11 8:54 AM",
            "commitNameOld": "1067f82f562231cca1a7d75c6f0c2d2ce04c7381",
            "commitAuthorOld": "Matthias Sohn",
            "daysBetweenCommits": 36.95,
            "commitsBetweenForRepo": 36,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,256 +1,256 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n-\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t// make sure not to overwrite untracked files\n \t\t\tif (f != null) {\n \t\t\t\t// a dirty worktree: the index is empty but we have a\n \t\t\t\t// workingtree-file\n \t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n \t\t\t\t\tconflict(name, null, h, m);\n \t\t\t\t\treturn;\n \t\t\t\t}\n \t\t\t}\n \n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n-\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n-\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\t\t\tkeep(dce);\n \t\t\t\t} else\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n-\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n-\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n \t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n-\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\t\tconflict(name, dce, h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t} else {\n-\t\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\t\tkeep(dce);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t// workingtree-file\n\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(dce);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\tconflict(name, dce, h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(dce);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "0d7dd6625a11a149d83e17f1d7defab9237aa6f6": {
            "type": "Ybodychange",
            "commitMessage": "Make sure not to overwrite untracked not-ignored files\n\nWhen DirCacheCheckout was checking out it was silently\noverwriting untracked files. This is only ok if the\nfiles are also ignored. Untracked and not ignored files\nshould not be overwritten. This fix adds checks for\nthis situation.\nBecause this change in the behaviour also broke tests\nwhich expected that a checkout will overwrite untracked\nfiles (PullCommandTest) these tests have to be modified\nalso.\n\nBug: 333093\nChange-Id: I26806d2108ceb64c51abaa877e11b584bf527fc9\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
            "commitDate": "26/01/11 9:41 AM",
            "commitName": "0d7dd6625a11a149d83e17f1d7defab9237aa6f6",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "26/01/11 8:17 AM",
            "commitNameOld": "4cba86bfeaaadbac2d13aa8176965feb424d748c",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 0.06,
            "commitsBetweenForRepo": 6,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,246 +1,256 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n+\t\t\t// make sure not to overwrite untracked files\n+\t\t\tif (f != null) {\n+\t\t\t\t// a dirty worktree: the index is empty but we have a\n+\t\t\t\t// workingtree-file\n+\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n+\t\t\t\t\tconflict(name, null, h, m);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n \t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t} else {\n \t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t// make sure not to overwrite untracked files\n\t\t\tif (f != null) {\n\t\t\t\t// a dirty worktree: the index is empty but we have a\n\t\t\t\t// workingtree-file\n\t\t\t\tif (mId == null || !mId.equals(f.getEntryObjectId())) {\n\t\t\t\t\tconflict(name, null, h, m);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "2"
        },
        "11fd0fe03ae471d1a6528070b4fee884b0ffea1d": {
            "type": "Ybodychange",
            "commitMessage": "Clarify WorkingTreeOptions and filemode usage\n\nTo improve runtime performance, caching the WorkingTreeOptions inside\nof the Config object using the Config.SectionParser API allows\nthe WorkingTreeOptions to be accessed more efficiently whenever a\nFileTreeIterator is constructed for the Repository.\n\nInstead of passing the filemode handling option into isModified(),\nthe WorkingTreeIterator should always honor whatever setting has\nbeen configured in this repository, as defined by its own copy of\nthe WorkingTreeOptions.  This simplifies all of the callers as they\nno longer need to lookup core.filemode on their own.\n\nA few locations were changed from always using a hardcoded \"true\"\non the file mode to passing what is actually configured in the\nrepository.  This is a behavior change, but corrects what should be\nconsidered to be bugs as the core.filemode variable wasn't always\nbeing used.\n\nChange-Id: Idb176736fa0dc97af372f1d652a94ecc72fb457c\nSigned-off-by: Shawn O. Pearce <spearce@spearce.org>\n",
            "commitDate": "08/12/10 10:03 AM",
            "commitName": "11fd0fe03ae471d1a6528070b4fee884b0ffea1d",
            "commitAuthor": "Shawn O. Pearce",
            "commitDateOld": "08/12/10 8:15 AM",
            "commitNameOld": "e3881de258b4db6a0d9284e6154a11f3c7eacf37",
            "commitAuthorOld": "Christian Halstrick",
            "daysBetweenCommits": 0.07,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,249 +1,246 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n-\t\t\t\t\tif (f == null || f.isModified(dce, true, config_filemode()))\n+\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n-\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n-\t\t\t\t\t\t\t\t\t\tconfig_filemode())))\n+\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (hId.equals(iId)) {\n-\t\t\t\t\tif (f == null || f.isModified(dce, true, config_filemode()))\n+\t\t\t\t\tif (f == null || f.isModified(dce, true))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n-\t\t\t\t\tif (dce != null\n-\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n-\t\t\t\t\t\t\t\t\tconfig_filemode())))\n+\t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t} else {\n \t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null || f.isModified(dce, true))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null && (f == null || f.isModified(dce, true)))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "10"
        },
        "e3881de258b4db6a0d9284e6154a11f3c7eacf37": {
            "type": "Ybodychange",
            "commitMessage": "Removed unread parameters\n\nSome method parameters in WorkingTreeIterator are never used. Remove\nthem. Especially the removal of the FS parameter in isModified()\nsimplifies upcoming performance optimizations.\n\nChange-Id: I7c449589283a4a6b6e23f2586cd784febdca8bcd\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
            "commitDate": "08/12/10 8:15 AM",
            "commitName": "e3881de258b4db6a0d9284e6154a11f3c7eacf37",
            "commitAuthor": "Christian Halstrick",
            "commitDateOld": "07/12/10 4:49 PM",
            "commitNameOld": "a02be9725c9f83f0a0280a9a1f00e8d484825885",
            "commitAuthorOld": "Shawn O. Pearce",
            "daysBetweenCommits": 0.64,
            "commitsBetweenForRepo": 2,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,253 +1,249 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n-\t\t\t\t\tif (f == null\n-\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n-\t\t\t\t\t\t\t\t\trepo.getFS()))\n+\t\t\t\t\tif (f == null || f.isModified(dce, true, config_filemode()))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n-\t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n+\t\t\t\t\t\t\t\t\t\tconfig_filemode())))\n \t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (hId.equals(iId)) {\n-\t\t\t\t\tif (f == null\n-\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n-\t\t\t\t\t\t\t\t\trepo.getFS()))\n+\t\t\t\t\tif (f == null || f.isModified(dce, true, config_filemode()))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n-\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n+\t\t\t\t\t\t\t\t\tconfig_filemode())))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t} else {\n \t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null || f.isModified(dce, true, config_filemode()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tconfig_filemode())))\n\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null || f.isModified(dce, true, config_filemode()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tconfig_filemode())))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "10"
        },
        "220cd43482c803b2e1ba6cdacc6e03644658b737": {
            "type": "Ybodychange",
            "commitMessage": "[findBugs] Fix NP_LOAD_OF_KNOWN_NULL_VALUE\n\nThe code analyzer can't know that passing a value known to be null is\nnot a problem. Hence better pass null explicitly instead of the\nparameters being null.\n\nChange-Id: I8db6f8014de6c00dd95974d60f61ecc66191e6d4\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>",
            "commitDate": "07/11/10 11:16 AM",
            "commitName": "220cd43482c803b2e1ba6cdacc6e03644658b737",
            "commitAuthor": "Matthias Sohn",
            "commitDateOld": "29/10/10 5:37 AM",
            "commitNameOld": "3f78650c9af941634022f4f8422e51cab40ca85f",
            "commitAuthorOld": "Robin Stocker",
            "daysBetweenCommits": 9.28,
            "commitsBetweenForRepo": 16,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,253 +1,253 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n-\t\t\t\tconflict(name, null, h, m);\n+\t\t\t\tconflict(name, null, null, null);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n \t\t\t\t\t\t\t\t\trepo.getFS()))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n \t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n \t\t\t\t\t\t\t\t\trepo.getFS()))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t} else {\n \t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, null, null);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n\t\t\t\t\t\t\t\t\trepo.getFS()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n\t\t\t\t\t\t\t\t\trepo.getFS()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "1",
            "TangledWMoveandFileRename": "1"
        },
        "3f78650c9af941634022f4f8422e51cab40ca85f": {
            "type": "Ybodychange",
            "commitMessage": "Remove two \"Dead store to local variable\" warnings\n\nChange-Id: I950de82db15c4610dc5a94f304279971daef971e\n",
            "commitDate": "29/10/10 5:37 AM",
            "commitName": "3f78650c9af941634022f4f8422e51cab40ca85f",
            "commitAuthor": "Robin Stocker",
            "commitDateOld": "26/10/10 11:27 AM",
            "commitNameOld": "07cae6e6c1d6982cf6b919e90e79330793c74a15",
            "commitAuthorOld": "Lluis Sanchez",
            "daysBetweenCommits": 2.76,
            "commitsBetweenForRepo": 9,
            "commitsBetweenForFile": 1,
            "diff": "@@ -1,254 +1,253 @@\n \tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n \t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n \t\tDirCacheEntry dce;\n \n \t\tString name = walk.getPathString();\n \n \t\tif (i == null && m == null && h == null) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tif (walk.isDirectoryFileConflict())\n \t\t\t\t// TODO: check whether it is always correct to report a conflict here\n \t\t\t\tconflict(name, null, h, m);\n \n \t\t\t// file only exists in working tree -> ignore it\n \t\t\treturn;\n \t\t}\n \n \t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n \t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n \t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n \n \t\t/**\n \t\t * <pre>\n \t\t *  File/Directory conflicts:\n \t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n \t\t *  conflicts. I give comments here\n \t\t *\n \t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n \t\t *      ------------------------------------------------------------------\n \t\t * 1    D        D       F       Y         N       Y       N           Update\n \t\t * 2    D        D       F       N         N       Y       N           Conflict\n \t\t * 3    D        F       D                 Y       N       N           Update\n \t\t * 4    D        F       D                 N       N       N           Update\n \t\t * 5    D        F       F       Y         N       N       Y           Keep\n \t\t * 6    D        F       F       N         N       N       Y           Keep\n \t\t * 7    F        D       F       Y         Y       N       N           Update\n \t\t * 8    F        D       F       N         Y       N       N           Conflict\n \t\t * 9    F        D       F       Y         N       N       N           Update\n \t\t * 10   F        D       D                 N       N       Y           Keep\n \t\t * 11   F        D       D                 N       N       N           Conflict\n \t\t * 12   F        F       D       Y         N       Y       N           Update\n \t\t * 13   F        F       D       N         N       Y       N           Conflict\n \t\t * 14   F        F       D                 N       N       N           Conflict\n \t\t * 15   0        F       D                 N       N       N           Conflict\n \t\t * 16   0        D       F       Y         N       N       N           Update\n \t\t * 17   0        D       F                 N       N       N           Conflict\n \t\t * 18   F        0       D                                             Update\n \t\t * 19   D        0       F                                             Update\n \t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n \t\t * </pre>\n \t\t */\n \n \t\t// The information whether head,index,merge iterators are currently\n \t\t// pointing to file/folder/non-existing is encoded into this variable.\n \t\t//\n \t\t// To decode write down ffMask in hexadecimal form. The last digit\n \t\t// represents the state for the merge iterator, the second last the\n \t\t// state for the index iterator and the third last represents the state\n \t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n \t\t// \"file\",\n \t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n \t\t// non-existing\n \t\t//\n \t\t// Examples:\n \t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n \t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n \n \t\tint ffMask = 0;\n \t\tif (h != null)\n \t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n \t\tif (i != null)\n \t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n \t\t\t\t\t: 0x0F0;\n \t\tif (m != null)\n \t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n \t\t\t\t\t: 0x00F;\n \n \t\t// Check whether we have a possible file/folder conflict. Therefore we\n \t\t// need a least one file and one folder.\n \t\tif (((ffMask & 0x222) != 0x000)\n \t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n \n \t\t\t// There are 3*3*3=27 possible combinations of file/folder\n \t\t\t// conflicts. Some of them are not-relevant because\n \t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n \t\t\t// switch processes all relevant cases.\n \t\t\tswitch (ffMask) {\n \t\t\tcase 0xDDF: // 1 2\n \t\t\t\tif (isModified(name)) {\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n \t\t\t\t} else {\n \t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n \t\t\t\t}\n \n \t\t\t\tbreak;\n \t\t\tcase 0xDFD: // 3 4\n \t\t\t\t// CAUTION: I put it into removed instead of updated, because\n \t\t\t\t// that's what our tests expect\n \t\t\t\t// updated.put(name, mId);\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xF0D: // 18\n \t\t\t\tremove(name);\n \t\t\t\tbreak;\n \t\t\tcase 0xDFF: // 5 6\n \t\t\tcase 0xFDD: // 10 11\n \t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n \t\t\t\t// we would like to do something like\n \t\t\t\t// if (!iId.equals(mId))\n \t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t// But since we don't know the id of a tree in the index we do\n \t\t\t\t// nothing here and wait that conflicts between index and merge\n \t\t\t\t// are found later\n \t\t\t\tbreak;\n \t\t\tcase 0xD0F: // 19\n \t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\tbreak;\n \t\t\tcase 0xDF0: // conflict without a rule\n \t\t\tcase 0x0FD: // 15\n \t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFDF: // 7 8 9\n-\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\tif (hId.equals(mId)) {\n \t\t\t\t\tif (isModified(name))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n \t\t\t\t} else if (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n \t\t\t\telse\n \t\t\t\t\t// To be confirmed - this case is not in the table.\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0xFD0: // keep without a rule\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\tbreak;\n \t\t\tcase 0xFFD: // 12 13 14\n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tdce = i.getDirCacheEntry();\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n \t\t\t\t\t\t\t\t\trepo.getFS()))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tcase 0x0DF: // 16 17\n \t\t\t\tif (!isModified(name))\n \t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\telse\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\tbreak;\n \t\t\tdefault:\n \t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t}\n \t\t\treturn;\n \t\t}\n \n \t\t// if we have no file at all then there is nothing to do\n \t\tif ((ffMask & 0x222) == 0)\n \t\t\treturn;\n \n \t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n \t\t\t// File/Directory conflict case #20\n \t\t\tconflict(name, null, h, m);\n \t\t}\n \n \t\tif (i == null) {\n \t\t\t/**\n \t\t\t * <pre>\n \t\t\t * \t\t    I (index)                H        M        Result\n \t\t\t * \t        -------------------------------------------------------\n \t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n \t\t\t * \t        1 nothing             nothing  exists   use M\n \t\t\t * \t        2 nothing             exists   nothing  remove path from index\n \t\t\t * \t        3 nothing             exists   exists   use M\n \t\t\t * </pre>\n \t\t\t */\n \n \t\t\tif (h == null)\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n \t\t\telse if (m == null)\n \t\t\t\tremove(name); // 2\n \t\t\telse\n \t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n \t\t} else {\n \t\t\tdce = i.getDirCacheEntry();\n \t\t\tif (h == null) {\n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t          clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n \t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n \t\t\t\t *\n \t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n \t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n \t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (m == null || mId.equals(iId)) {\n \t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n \t\t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n \t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\t\telse\n \t\t\t\t\t\t\tremove(name);\n \t\t\t\t\t} else\n \t\t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else if (m == null) {\n \n \t\t\t\t/**\n \t\t\t\t * <pre>\n \t\t\t\t * \t           clean I==H  I==M       H        M        Result\n \t\t\t\t * \t         -----------------------------------------------------\n \t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n \t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n \t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n \t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n \t\t\t\t * </pre>\n \t\t\t\t */\n \n \t\t\t\tif (hId.equals(iId)) {\n \t\t\t\t\tif (f == null\n \t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n \t\t\t\t\t\t\t\t\trepo.getFS()))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tremove(name);\n \t\t\t\t} else\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t} else {\n \t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n \t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n \t\t\t\t\tif (dce != null\n \t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n \t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n \t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n \t\t\t\t\telse\n \t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n \t\t\t\t} else {\n \t\t\t\t\tkeep(i.getDirCacheEntry());\n \t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, h, m);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n\t\t\t\t\t\t\t\t\trepo.getFS()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n\t\t\t\t\t\t\t\t\trepo.getFS()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "extendedDetails": {},
            "BugCommit": "0",
            "TangledWMoveandFileRename": "1"
        },
        "2059ed205ebdf1b6837077db6cea6d29a4fbcf4a": {
            "type": "Yintroduced",
            "commitMessage": "Implement a Dircache checkout (needed for merge)\n\nImplementation of a checkout (or 'git read-tree') operation which\nworks together with DirCache. This implementation does similar things\nas WorkDirCheckout which main problem is that it works with deprecated\nGitIndex. Since GitIndex doesn't support multiple stages of a file\nwhich is required in merge situations this new implementation is\nrequired to enable merge support.\n\nChange-Id: I13f0f23ad60d98e5168118a7e7e7308e066ecf9c\nSigned-off-by: Christian Halstrick <christian.halstrick@sap.com>\nSigned-off-by: Matthias Sohn <matthias.sohn@sap.com>\nSigned-off-by: Chris Aniszczyk <caniszczyk@gmail.com>\n",
            "commitDate": "27/08/10 7:06 AM",
            "commitName": "2059ed205ebdf1b6837077db6cea6d29a4fbcf4a",
            "commitAuthor": "Christian Halstrick",
            "diff": "@@ -0,0 +1,254 @@\n+\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n+\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n+\t\tDirCacheEntry dce;\n+\n+\t\tString name = walk.getPathString();\n+\n+\t\tif (i == null && m == null && h == null) {\n+\t\t\t// File/Directory conflict case #20\n+\t\t\tif (walk.isDirectoryFileConflict())\n+\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n+\t\t\t\tconflict(name, null, h, m);\n+\n+\t\t\t// file only exists in working tree -> ignore it\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n+\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n+\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n+\n+\t\t/**\n+\t\t * <pre>\n+\t\t *  File/Directory conflicts:\n+\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n+\t\t *  conflicts. I give comments here\n+\t\t *\n+\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n+\t\t *      ------------------------------------------------------------------\n+\t\t * 1    D        D       F       Y         N       Y       N           Update\n+\t\t * 2    D        D       F       N         N       Y       N           Conflict\n+\t\t * 3    D        F       D                 Y       N       N           Update\n+\t\t * 4    D        F       D                 N       N       N           Update\n+\t\t * 5    D        F       F       Y         N       N       Y           Keep\n+\t\t * 6    D        F       F       N         N       N       Y           Keep\n+\t\t * 7    F        D       F       Y         Y       N       N           Update\n+\t\t * 8    F        D       F       N         Y       N       N           Conflict\n+\t\t * 9    F        D       F       Y         N       N       N           Update\n+\t\t * 10   F        D       D                 N       N       Y           Keep\n+\t\t * 11   F        D       D                 N       N       N           Conflict\n+\t\t * 12   F        F       D       Y         N       Y       N           Update\n+\t\t * 13   F        F       D       N         N       Y       N           Conflict\n+\t\t * 14   F        F       D                 N       N       N           Conflict\n+\t\t * 15   0        F       D                 N       N       N           Conflict\n+\t\t * 16   0        D       F       Y         N       N       N           Update\n+\t\t * 17   0        D       F                 N       N       N           Conflict\n+\t\t * 18   F        0       D                                             Update\n+\t\t * 19   D        0       F                                             Update\n+\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n+\t\t * </pre>\n+\t\t */\n+\n+\t\t// The information whether head,index,merge iterators are currently\n+\t\t// pointing to file/folder/non-existing is encoded into this variable.\n+\t\t//\n+\t\t// To decode write down ffMask in hexadecimal form. The last digit\n+\t\t// represents the state for the merge iterator, the second last the\n+\t\t// state for the index iterator and the third last represents the state\n+\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n+\t\t// \"file\",\n+\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n+\t\t// non-existing\n+\t\t//\n+\t\t// Examples:\n+\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n+\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n+\n+\t\tint ffMask = 0;\n+\t\tif (h != null)\n+\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n+\t\tif (i != null)\n+\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n+\t\t\t\t\t: 0x0F0;\n+\t\tif (m != null)\n+\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n+\t\t\t\t\t: 0x00F;\n+\n+\t\t// Check whether we have a possible file/folder conflict. Therefore we\n+\t\t// need a least one file and one folder.\n+\t\tif (((ffMask & 0x222) != 0x000)\n+\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n+\n+\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n+\t\t\t// conflicts. Some of them are not-relevant because\n+\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n+\t\t\t// switch processes all relevant cases.\n+\t\t\tswitch (ffMask) {\n+\t\t\tcase 0xDDF: // 1 2\n+\t\t\t\tif (isModified(name)) {\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n+\t\t\t\t} else {\n+\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase 0xDFD: // 3 4\n+\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n+\t\t\t\t// that's what our tests expect\n+\t\t\t\t// updated.put(name, mId);\n+\t\t\t\tremove(name);\n+\t\t\t\tbreak;\n+\t\t\tcase 0xF0D: // 18\n+\t\t\t\tremove(name);\n+\t\t\t\tbreak;\n+\t\t\tcase 0xDFF: // 5 6\n+\t\t\tcase 0xFDD: // 10 11\n+\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n+\t\t\t\t// we would like to do something like\n+\t\t\t\t// if (!iId.equals(mId))\n+\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t// But since we don't know the id of a tree in the index we do\n+\t\t\t\t// nothing here and wait that conflicts between index and merge\n+\t\t\t\t// are found later\n+\t\t\t\tbreak;\n+\t\t\tcase 0xD0F: // 19\n+\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\tbreak;\n+\t\t\tcase 0xDF0: // conflict without a rule\n+\t\t\tcase 0x0FD: // 15\n+\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n+\t\t\t\tbreak;\n+\t\t\tcase 0xFDF: // 7 8 9\n+\t\t\t\tdce = i.getDirCacheEntry();\n+\t\t\t\tif (hId.equals(mId)) {\n+\t\t\t\t\tif (isModified(name))\n+\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n+\t\t\t\t\telse\n+\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n+\t\t\t\t} else if (!isModified(name))\n+\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n+\t\t\t\telse\n+\t\t\t\t\t// To be confirmed - this case is not in the table.\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\tbreak;\n+\t\t\tcase 0xFD0: // keep without a rule\n+\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\tbreak;\n+\t\t\tcase 0xFFD: // 12 13 14\n+\t\t\t\tif (hId.equals(iId)) {\n+\t\t\t\t\tdce = i.getDirCacheEntry();\n+\t\t\t\t\tif (f == null\n+\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n+\t\t\t\t\t\t\t\t\trepo.getFS()))\n+\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tremove(name);\n+\t\t\t\t} else\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\tbreak;\n+\t\t\tcase 0x0DF: // 16 17\n+\t\t\t\tif (!isModified(name))\n+\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\telse\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\t// if we have no file at all then there is nothing to do\n+\t\tif ((ffMask & 0x222) == 0)\n+\t\t\treturn;\n+\n+\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n+\t\t\t// File/Directory conflict case #20\n+\t\t\tconflict(name, null, h, m);\n+\t\t}\n+\n+\t\tif (i == null) {\n+\t\t\t/**\n+\t\t\t * <pre>\n+\t\t\t * \t\t    I (index)                H        M        Result\n+\t\t\t * \t        -------------------------------------------------------\n+\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n+\t\t\t * \t        1 nothing             nothing  exists   use M\n+\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n+\t\t\t * \t        3 nothing             exists   exists   use M\n+\t\t\t * </pre>\n+\t\t\t */\n+\n+\t\t\tif (h == null)\n+\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n+\t\t\telse if (m == null)\n+\t\t\t\tremove(name); // 2\n+\t\t\telse\n+\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n+\t\t} else {\n+\t\t\tdce = i.getDirCacheEntry();\n+\t\t\tif (h == null) {\n+\t\t\t\t/**\n+\t\t\t\t * <pre>\n+\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n+\t\t\t\t * \t         -----------------------------------------------------\n+\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n+\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n+\t\t\t\t *\n+\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n+\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n+\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n+\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n+\t\t\t\t * </pre>\n+\t\t\t\t */\n+\n+\t\t\t\tif (m == null || mId.equals(iId)) {\n+\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n+\t\t\t\t\t\tif (dce != null\n+\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n+\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\t\telse\n+\t\t\t\t\t\t\tremove(name);\n+\t\t\t\t\t} else\n+\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\t} else\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t} else if (m == null) {\n+\n+\t\t\t\t/**\n+\t\t\t\t * <pre>\n+\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n+\t\t\t\t * \t         -----------------------------------------------------\n+\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n+\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n+\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n+\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n+\t\t\t\t * </pre>\n+\t\t\t\t */\n+\n+\t\t\t\tif (hId.equals(iId)) {\n+\t\t\t\t\tif (f == null\n+\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n+\t\t\t\t\t\t\t\t\trepo.getFS()))\n+\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tremove(name);\n+\t\t\t\t} else\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t} else {\n+\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n+\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n+\t\t\t\t\tif (dce != null\n+\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n+\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n+\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n+\t\t\t\t\telse\n+\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n+\t\t\t\t} else {\n+\t\t\t\t\tkeep(i.getDirCacheEntry());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n\\ No newline at end of file\n",
            "actualSource": "\tvoid processEntry(AbstractTreeIterator h, AbstractTreeIterator m,\n\t\t\tDirCacheBuildIterator i, WorkingTreeIterator f) throws IOException {\n\t\tDirCacheEntry dce;\n\n\t\tString name = walk.getPathString();\n\n\t\tif (i == null && m == null && h == null) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tif (walk.isDirectoryFileConflict())\n\t\t\t\t// TODO: check whether it is always correct to report a conflict here\n\t\t\t\tconflict(name, null, h, m);\n\n\t\t\t// file only exists in working tree -> ignore it\n\t\t\treturn;\n\t\t}\n\n\t\tObjectId iId = (i == null ? null : i.getEntryObjectId());\n\t\tObjectId mId = (m == null ? null : m.getEntryObjectId());\n\t\tObjectId hId = (h == null ? null : h.getEntryObjectId());\n\n\t\t/**\n\t\t * <pre>\n\t\t *  File/Directory conflicts:\n\t\t *  the following table from ReadTreeTest tells what to do in case of directory/file\n\t\t *  conflicts. I give comments here\n\t\t *\n\t\t *      H        I       M     Clean     H==M     H==I    I==M         Result\n\t\t *      ------------------------------------------------------------------\n\t\t * 1    D        D       F       Y         N       Y       N           Update\n\t\t * 2    D        D       F       N         N       Y       N           Conflict\n\t\t * 3    D        F       D                 Y       N       N           Update\n\t\t * 4    D        F       D                 N       N       N           Update\n\t\t * 5    D        F       F       Y         N       N       Y           Keep\n\t\t * 6    D        F       F       N         N       N       Y           Keep\n\t\t * 7    F        D       F       Y         Y       N       N           Update\n\t\t * 8    F        D       F       N         Y       N       N           Conflict\n\t\t * 9    F        D       F       Y         N       N       N           Update\n\t\t * 10   F        D       D                 N       N       Y           Keep\n\t\t * 11   F        D       D                 N       N       N           Conflict\n\t\t * 12   F        F       D       Y         N       Y       N           Update\n\t\t * 13   F        F       D       N         N       Y       N           Conflict\n\t\t * 14   F        F       D                 N       N       N           Conflict\n\t\t * 15   0        F       D                 N       N       N           Conflict\n\t\t * 16   0        D       F       Y         N       N       N           Update\n\t\t * 17   0        D       F                 N       N       N           Conflict\n\t\t * 18   F        0       D                                             Update\n\t\t * 19   D        0       F                                             Update\n\t\t * 20   0        0       F       N (worktree=dir)                      Conflict\n\t\t * </pre>\n\t\t */\n\n\t\t// The information whether head,index,merge iterators are currently\n\t\t// pointing to file/folder/non-existing is encoded into this variable.\n\t\t//\n\t\t// To decode write down ffMask in hexadecimal form. The last digit\n\t\t// represents the state for the merge iterator, the second last the\n\t\t// state for the index iterator and the third last represents the state\n\t\t// for the head iterator. The hexadecimal constant \"F\" stands for\n\t\t// \"file\",\n\t\t// an \"D\" stands for \"directory\" (tree), and a \"0\" stands for\n\t\t// non-existing\n\t\t//\n\t\t// Examples:\n\t\t// ffMask == 0xFFD -> Head=File, Index=File, Merge=Tree\n\t\t// ffMask == 0xDD0 -> Head=Tree, Index=Tree, Merge=Non-Existing\n\n\t\tint ffMask = 0;\n\t\tif (h != null)\n\t\t\tffMask = FileMode.TREE.equals(h.getEntryFileMode()) ? 0xD00 : 0xF00;\n\t\tif (i != null)\n\t\t\tffMask |= FileMode.TREE.equals(i.getEntryFileMode()) ? 0x0D0\n\t\t\t\t\t: 0x0F0;\n\t\tif (m != null)\n\t\t\tffMask |= FileMode.TREE.equals(m.getEntryFileMode()) ? 0x00D\n\t\t\t\t\t: 0x00F;\n\n\t\t// Check whether we have a possible file/folder conflict. Therefore we\n\t\t// need a least one file and one folder.\n\t\tif (((ffMask & 0x222) != 0x000)\n\t\t\t\t&& (((ffMask & 0x00F) == 0x00D) || ((ffMask & 0x0F0) == 0x0D0) || ((ffMask & 0xF00) == 0xD00))) {\n\n\t\t\t// There are 3*3*3=27 possible combinations of file/folder\n\t\t\t// conflicts. Some of them are not-relevant because\n\t\t\t// they represent no conflict, e.g. 0xFFF, 0xDDD, ... The following\n\t\t\t// switch processes all relevant cases.\n\t\t\tswitch (ffMask) {\n\t\t\tcase 0xDDF: // 1 2\n\t\t\t\tif (isModified(name)) {\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 1\n\t\t\t\t} else {\n\t\t\t\t\tupdate(name, m.getEntryObjectId(), m.getEntryFileMode()); // 2\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\tcase 0xDFD: // 3 4\n\t\t\t\t// CAUTION: I put it into removed instead of updated, because\n\t\t\t\t// that's what our tests expect\n\t\t\t\t// updated.put(name, mId);\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xF0D: // 18\n\t\t\t\tremove(name);\n\t\t\t\tbreak;\n\t\t\tcase 0xDFF: // 5 6\n\t\t\tcase 0xFDD: // 10 11\n\t\t\t\t// TODO: make use of tree extension as soon as available in jgit\n\t\t\t\t// we would like to do something like\n\t\t\t\t// if (!iId.equals(mId))\n\t\t\t\t//   conflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t// But since we don't know the id of a tree in the index we do\n\t\t\t\t// nothing here and wait that conflicts between index and merge\n\t\t\t\t// are found later\n\t\t\t\tbreak;\n\t\t\tcase 0xD0F: // 19\n\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\tbreak;\n\t\t\tcase 0xDF0: // conflict without a rule\n\t\t\tcase 0x0FD: // 15\n\t\t\t\tconflict(name, (i != null) ? i.getDirCacheEntry() : null, h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFDF: // 7 8 9\n\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\tif (hId.equals(mId)) {\n\t\t\t\t\tif (isModified(name))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m); // 8\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 7\n\t\t\t\t} else if (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());  // 9\n\t\t\t\telse\n\t\t\t\t\t// To be confirmed - this case is not in the table.\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0xFD0: // keep without a rule\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\tbreak;\n\t\t\tcase 0xFFD: // 12 13 14\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tdce = i.getDirCacheEntry();\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n\t\t\t\t\t\t\t\t\trepo.getFS()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tcase 0x0DF: // 16 17\n\t\t\t\tif (!isModified(name))\n\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\telse\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// if we have no file at all then there is nothing to do\n\t\tif ((ffMask & 0x222) == 0)\n\t\t\treturn;\n\n\t\tif ((ffMask == 0x00F) && f != null && FileMode.TREE.equals(f.getEntryFileMode())) {\n\t\t\t// File/Directory conflict case #20\n\t\t\tconflict(name, null, h, m);\n\t\t}\n\n\t\tif (i == null) {\n\t\t\t/**\n\t\t\t * <pre>\n\t\t\t * \t\t    I (index)                H        M        Result\n\t\t\t * \t        -------------------------------------------------------\n\t\t\t * \t        0 nothing             nothing  nothing  (does not happen)\n\t\t\t * \t        1 nothing             nothing  exists   use M\n\t\t\t * \t        2 nothing             exists   nothing  remove path from index\n\t\t\t * \t        3 nothing             exists   exists   use M\n\t\t\t * </pre>\n\t\t\t */\n\n\t\t\tif (h == null)\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 1\n\t\t\telse if (m == null)\n\t\t\t\tremove(name); // 2\n\t\t\telse\n\t\t\t\tupdate(name, mId, m.getEntryFileMode()); // 3\n\t\t} else {\n\t\t\tdce = i.getDirCacheEntry();\n\t\t\tif (h == null) {\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t          clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        4 yes   N/A   N/A     nothing  nothing  keep index\n\t\t\t\t * \t        5 no    N/A   N/A     nothing  nothing  keep index\n\t\t\t\t *\n\t\t\t\t * \t        6 yes   N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        7 no    N/A   yes     nothing  exists   keep index\n\t\t\t\t * \t        8 yes   N/A   no      nothing  exists   fail\n\t\t\t\t * \t        9 no    N/A   no      nothing  exists   fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (m == null || mId.equals(iId)) {\n\t\t\t\t\tif (m==null && walk.isDirectoryFileConflict()) {\n\t\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n\t\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tremove(name);\n\t\t\t\t\t} else\n\t\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else if (m == null) {\n\n\t\t\t\t/**\n\t\t\t\t * <pre>\n\t\t\t\t * \t           clean I==H  I==M       H        M        Result\n\t\t\t\t * \t         -----------------------------------------------------\n\t\t\t\t * \t        10 yes   yes   N/A     exists   nothing  remove path from index\n\t\t\t\t * \t        11 no    yes   N/A     exists   nothing  fail\n\t\t\t\t * \t        12 yes   no    N/A     exists   nothing  fail\n\t\t\t\t * \t        13 no    no    N/A     exists   nothing  fail\n\t\t\t\t * </pre>\n\t\t\t\t */\n\n\t\t\t\tif (hId.equals(iId)) {\n\t\t\t\t\tif (f == null\n\t\t\t\t\t\t\t|| f.isModified(dce, true, config_filemode(),\n\t\t\t\t\t\t\t\t\trepo.getFS()))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tremove(name);\n\t\t\t\t} else\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t} else {\n\t\t\t\tif (!hId.equals(mId) && !hId.equals(iId) && !mId.equals(iId))\n\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\telse if (hId.equals(iId) && !mId.equals(iId)) {\n\t\t\t\t\tif (dce != null\n\t\t\t\t\t\t\t&& (f == null || f.isModified(dce, true,\n\t\t\t\t\t\t\t\t\tconfig_filemode(), repo.getFS())))\n\t\t\t\t\t\tconflict(name, i.getDirCacheEntry(), h, m);\n\t\t\t\t\telse\n\t\t\t\t\t\tupdate(name, mId, m.getEntryFileMode());\n\t\t\t\t} else {\n\t\t\t\t\tkeep(i.getDirCacheEntry());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}",
            "path": "org.eclipse.jgit/src/org/eclipse/jgit/dircache/DirCacheCheckout.java",
            "BugCommit": "0",
            "TangledWMoveandFileRename": "0"
        }
    },
    "file": "6032.json"
}